<!-- HTML header for doxygen 1.8.14-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Caffe2 - C++ API: caffe2 Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="icon" href="/static/favicon.png" type="image/x-icon">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="stylesheet.css" rel="stylesheet" type="text/css" />
<link href="main.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo" width="56"><a href="/"><img alt="Logo" src="Caffe2-with-name-55-tall.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Caffe2 - C++ API
   </div>
   <div id="projectbrief">A deep learning, cross platform ML framework</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.html','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">caffe2 Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Copyright (c) 2016-present, Facebook, Inc.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecaffe2_1_1enforce__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2_1_1enforce__detail.html">enforce_detail</a></td></tr>
<tr class="memdesc:namespacecaffe2_1_1enforce__detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rich logging messages. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1AbsCPUFunctor.html">AbsCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1AbsGradientCPUFunctor.html">AbsGradientCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1AbstractLengthsDef.html">AbstractLengthsDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AbstractLengthsGradientOp.html">AbstractLengthsGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AbstractLengthsOp.html">AbstractLengthsOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segment reduction op with optional fused embedding lookup.  <a href="classcaffe2_1_1AbstractLengthsOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AbstractLengthsWithMainInputAndForwardOutputGradientOp.html">AbstractLengthsWithMainInputAndForwardOutputGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AbstractLengthsWithMainInputGradientOp.html">AbstractLengthsWithMainInputGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1AbstractReduceBackDef.html">AbstractReduceBackDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1AbstractReduceFrontDef.html">AbstractReduceFrontDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AbstractReduceFrontOrBackGradientOp.html">AbstractReduceFrontOrBackGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AbstractReduceFrontOrBackOp.html">AbstractReduceFrontOrBackOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple non-segmented reduction over the first few dimensions of the tensor.  <a href="classcaffe2_1_1AbstractReduceFrontOrBackOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1AbstractSortedSegmentDef.html">AbstractSortedSegmentDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AbstractSortedSegmentGradientOp.html">AbstractSortedSegmentGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AbstractSortedSegmentOp.html">AbstractSortedSegmentOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Segment reduction op with optional fused embedding lookup.  <a href="classcaffe2_1_1AbstractSortedSegmentOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1AbstractSortedSegmentRangeDef.html">AbstractSortedSegmentRangeDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AbstractSortedSegmentRangeGradientOp.html">AbstractSortedSegmentRangeGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AbstractSortedSegmentRangeOp.html">AbstractSortedSegmentRangeOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base implementation for segment reduction op that leverages continuity of the data.  <a href="classcaffe2_1_1AbstractSortedSegmentRangeOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1AbstractSparseLengthsDef.html">AbstractSparseLengthsDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1AbstractSparseSortedSegmentDef.html">AbstractSparseSortedSegmentDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1AbstractSparseUnsortedSegmentDef.html">AbstractSparseUnsortedSegmentDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1AbstractUnsortedSegmentDef.html">AbstractUnsortedSegmentDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AbstractUnsortedSegmentGradientOp.html">AbstractUnsortedSegmentGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AbstractUnsortedSegmentOp.html">AbstractUnsortedSegmentOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unsorted segment reduction op with optional fused embedding lookup.  <a href="classcaffe2_1_1AbstractUnsortedSegmentOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AccumulateHistogramOp.html">AccumulateHistogramOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AccumulateInputGradientOp.html">AccumulateInputGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AccumulateOp.html">AccumulateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AccuracyOp.html">AccuracyOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AdagradOp.html">AdagradOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AdamOp.html">AdamOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AddPaddingOp.html">AddPaddingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AlgorithmsCache.html">AlgorithmsCache</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AliasOp.html">AliasOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias op makes the output and the input share the same underlying storage.  <a href="classcaffe2_1_1AliasOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1AlignedDeleter.html">AlignedDeleter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1AllocAligned.html">AllocAligned</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AlternateLearningRate.html">AlternateLearningRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1Analysis.html">Analysis</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1APMeterOp.html">APMeterOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ArgumentHelper.html">ArgumentHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to index into arguments.  <a href="classcaffe2_1_1ArgumentHelper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AssertOp.html">AssertOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AsyncDAGNet.html">AsyncDAGNet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AsyncNetBase.html">AsyncNetBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AsyncPollingNet.html">AsyncPollingNet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AsyncSchedulingNet.html">AsyncSchedulingNet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AsyncSimpleNet.html">AsyncSimpleNet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AtomicIterOp.html">AtomicIterOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AveragedLoss.html">AveragedLoss</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AveragedLossGradient.html">AveragedLossGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AveragePool.html">AveragePool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1AvgExportedStat.html">AvgExportedStat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BaseInputAccessor.html">BaseInputAccessor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BaseReducer.html">BaseReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BaseReducerGradient.html">BaseReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BatchBoxCoxOp.html">BatchBoxCoxOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BatchBucketOneHotOp.html">BatchBucketOneHotOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BatchDenseToSparseOp.html">BatchDenseToSparseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BatchGatherGradientOp.html">BatchGatherGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BatchGatherOp.html">BatchGatherOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BatchMatMulOp.html">BatchMatMulOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BatchOneHotOp.html">BatchOneHotOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BatchSparseToDenseOp.html">BatchSparseToDenseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BatchToSpaceOp.html">BatchToSpaceOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BinaryElementwiseOp.html">BinaryElementwiseOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a binary operation (e.g.  <a href="classcaffe2_1_1BinaryElementwiseOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Blob.html">Blob</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1Blob.html" title="Blob is a general container that hosts a typed pointer. ">Blob</a> is a general container that hosts a typed pointer.  <a href="classcaffe2_1_1Blob.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BlobDeserializerBase.html">BlobDeserializerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1BlobDeserializerBase.html" title="BlobDeserializerBase is an abstract class that deserializes a blob from a BlobProto or a TensorProto...">BlobDeserializerBase</a> is an abstract class that deserializes a blob from a BlobProto or a TensorProto.  <a href="classcaffe2_1_1BlobDeserializerBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BlobSerializerBase.html">BlobSerializerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1BlobSerializerBase.html" title="BlobSerializerBase is an abstract class that serializes a blob to a string. ">BlobSerializerBase</a> is an abstract class that serializes a blob to a string.  <a href="classcaffe2_1_1BlobSerializerBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BlobsQueue.html">BlobsQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1BlobStatGetter.html">BlobStatGetter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1BlobStatRegistry.html">BlobStatRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BlockingCounter.html">BlockingCounter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BooleanMaskOp.html">BooleanMaskOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BooleanUnmaskOp.html">BooleanUnmaskOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BRGNCHWCToPackedInt8BGRAStylizerDeprocessOp.html">BRGNCHWCToPackedInt8BGRAStylizerDeprocessOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1BufferedTokenizer.html">BufferedTokenizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Caffe2FlagParser.html">Caffe2FlagParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Caffe2ModuleTestDynamicDummyOp.html">Caffe2ModuleTestDynamicDummyOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CastOp.html">CastOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ChannelShuffleGradientOp.html">ChannelShuffleGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ChannelShuffleOp.html">ChannelShuffleOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1CharRange.html">CharRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CheckCounterDoneOp.html">CheckCounterDoneOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CheckpointOp.html">CheckpointOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ClipGradientOp.html">ClipGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ClipOp.html">ClipOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CloseBlobsQueueOp.html">CloseBlobsQueueOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CloseRebatchingQueueOp.html">CloseRebatchingQueueOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Col2ImOp.html">Col2ImOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CommonSubexpressionEliminationTransform.html">CommonSubexpressionEliminationTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common Subexpression Elimination.  <a href="classcaffe2_1_1CommonSubexpressionEliminationTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ConcatOp.html">ConcatOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ConditionalOp.html">ConditionalOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ConstantFillOp.html">ConstantFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ConstantWarmupLearningRate.html">ConstantWarmupLearningRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1ConvArgs.html">ConvArgs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Converter.html">Converter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ConvGradientOp.html">ConvGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ConvOp.html">ConvOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ConvPoolOpBase.html">ConvPoolOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ConvToNNPackTransform.html">ConvToNNPackTransform</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ConvTransposeGradientOp.html">ConvTransposeGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ConvTransposeOp.html">ConvTransposeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ConvTransposeUnpoolBase.html">ConvTransposeUnpoolBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CopyFromOpenGLOp.html">CopyFromOpenGLOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CopyOnDeviceLikeOp.html">CopyOnDeviceLikeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CopyOnDeviceLikeOp_3_01CUDAContext_00_01CUDAContext_00_01CUDAContext_01_4.html">CopyOnDeviceLikeOp&lt; CUDAContext, CUDAContext, CUDAContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CopyOp.html">CopyOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CopyToOpenGLOp.html">CopyToOpenGLOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1CosCPUFunctor.html">CosCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1CosGradientCPUFunctor.html">CosGradientCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CosineEmbeddingCriterionGradientOp.html">CosineEmbeddingCriterionGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CosineEmbeddingCriterionOp.html">CosineEmbeddingCriterionOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CosineSimilarityGradientOp.html">CosineSimilarityGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CosineSimilarityOp.html">CosineSimilarityOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CountDownOp.html">CountDownOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Counter.html">Counter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CountUpOp.html">CountUpOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1CPUAllocator.html">CPUAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CPU Context, representing the bare minimum of what a Context class in Caffe2 should implement.  <a href="classcaffe2_1_1CPUContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1CPUEventWrapper.html">CPUEventWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CpuId.html">CpuId</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identification of an Intel CPU.  <a href="classcaffe2_1_1CpuId.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CPUSparseLengthsReductionOp.html">CPUSparseLengthsReductionOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1CpuUtilizationReportOp.html">CpuUtilizationReportOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CreateBlobsQueueOp.html">CreateBlobsQueueOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CreateCounterOp.html">CreateCounterOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CreateDBOp.html">CreateDBOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CreateMapOp.html">CreateMapOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CreateRebatchingQueueOp.html">CreateRebatchingQueueOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CreateScopeOp.html">CreateScopeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CreateTextFileReaderOp.html">CreateTextFileReaderOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CrossEntropyGradientOp.html">CrossEntropyGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CrossEntropyOp.html">CrossEntropyOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1CudaDevicePropWrapper.html">CudaDevicePropWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1CudaEventWrapper.html">CudaEventWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CUDARecurrentNetworkExecutor.html">CUDARecurrentNetworkExecutor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CudaRTCFunction.html">CudaRTCFunction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CudnnConvGradientOp.html">CudnnConvGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CudnnConvOp.html">CudnnConvOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CudnnConvOpBase.html">CudnnConvOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CudnnConvTransposeGradientOp.html">CudnnConvTransposeGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CudnnConvTransposeOp.html">CudnnConvTransposeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CudnnConvTransposeOpBase.html">CudnnConvTransposeOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1cudnnFilterDescWrapper.html">cudnnFilterDescWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CuDNNLRNGradientOp.html">CuDNNLRNGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CuDNNLRNOp.html">CuDNNLRNOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CuDNNReluGradientOp.html">CuDNNReluGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CuDNNReluOp.html">CuDNNReluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CuDNNSoftmaxGradientOp.html">CuDNNSoftmaxGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CuDNNSoftmaxOp.html">CuDNNSoftmaxOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CudnnSpatialBNGradientOp.html">CudnnSpatialBNGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CudnnSpatialBNOp.html">CudnnSpatialBNOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CuDNNState.html">CuDNNState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1cudnnTensorDescWrapper.html">cudnnTensorDescWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1cudnnTensorDescWrapper.html" title="cudnnTensorDescWrapper is the placeholder that wraps around a cudnnTensorDescriptor_t, allowing us to do descriptor change as-needed during runtime. ">cudnnTensorDescWrapper</a> is the placeholder that wraps around a cudnnTensorDescriptor_t, allowing us to do descriptor change as-needed during runtime.  <a href="classcaffe2_1_1cudnnTensorDescWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CuDNNTransposeOp.html">CuDNNTransposeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1cudnnTypeWrapper.html">cudnnTypeWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1cudnnTypeWrapper.html" title="cudnnTypeWrapper is a wrapper class that allows us to refer to the cudnn type in a template function...">cudnnTypeWrapper</a> is a wrapper class that allows us to refer to the cudnn type in a template function.  <a href="classcaffe2_1_1cudnnTypeWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1cudnnTypeWrapper_3_01double_01_4.html">cudnnTypeWrapper&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1cudnnTypeWrapper_3_01float_01_4.html">cudnnTypeWrapper&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1cudnnTypeWrapper_3_01float16_01_4.html">cudnnTypeWrapper&lt; float16 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1CuDNNWorkspace.html">CuDNNWorkspace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcaffe2_1_1CuDNNWorkspace.html" title="CuDNNWorkspace is a wrapper around a raw cuda pointer that holds the cudnn scratch space...">CuDNNWorkspace</a> is a wrapper around a raw cuda pointer that holds the cudnn scratch space.  <a href="structcaffe2_1_1CuDNNWorkspace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1CuDNNWrapper.html">CuDNNWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1CuDNNWrapper.html" title="CuDNNWrapper is a class that wraps the cudnn handles and cudnn workspaces. ">CuDNNWrapper</a> is a class that wraps the cudnn handles and cudnn workspaces.  <a href="classcaffe2_1_1CuDNNWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DAGNet.html">DAGNet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DAGNetBase.html">DAGNetBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DBExistsOp.html">DBExistsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DecodedFrame.html">DecodedFrame</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1DefaultCPUAllocator.html">DefaultCPUAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DefaultEngine.html">DefaultEngine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DeformConvGradientOp.html">DeformConvGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DeformConvOp.html">DeformConvOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DeformConvOpBase.html">DeformConvOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DequeueBlobsOp.html">DequeueBlobsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DequeueRebatchingQueueOp.html">DequeueRebatchingQueueOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DetailedExportedStat.html">DetailedExportedStat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DeviceGuard.html">DeviceGuard</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1DeviceTypeRegisterer.html">DeviceTypeRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DiagonalFillOp.html">DiagonalFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1DispatchHelper.html">DispatchHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1DispatchHelper_3_01FixedValues_3_01FirstVal_00_01Values_8_8_8_01_4_00_01ExtraArgs_8_8_8_01_4.html">DispatchHelper&lt; FixedValues&lt; FirstVal, Values... &gt;, ExtraArgs... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1DispatchHelper_3_01FixedValues_3_4_00_01ExtraArgs_8_8_8_01_4.html">DispatchHelper&lt; FixedValues&lt;&gt;, ExtraArgs... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DivGradientOp.html">DivGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DoOp.html">DoOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DotProductGradientOp.html">DotProductGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DotProductOp.html">DotProductOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DotProductWithPaddingGradientOp.html">DotProductWithPaddingGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DotProductWithPaddingOp.html">DotProductWithPaddingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DropoutGradientOp.html">DropoutGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1DropoutOp.html">DropoutOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1EigenConvOp.html">EigenConvOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ElementwiseLinearGradientOp.html">ElementwiseLinearGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ElementwiseLinearOp.html">ElementwiseLinearOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ElementwiseRTCOp.html">ElementwiseRTCOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A GPU operator that can generate limited elementwise operations.  <a href="classcaffe2_1_1ElementwiseRTCOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1EluGradientOp.html">EluGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1EluOp.html">EluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1EnforceNotMet.html">EnforceNotMet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1EnqueueBlobsOp.html">EnqueueBlobsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1EnqueueRebatchingQueueOp.html">EnqueueRebatchingQueueOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1EnsureDenseOp.html">EnsureDenseOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass inputs to outputs.  <a href="classcaffe2_1_1EnsureDenseOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Event.html">Event</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1EventCreateFunctionRegisterer.html">EventCreateFunctionRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1EventErrorMessageFunctionRegisterer.html">EventErrorMessageFunctionRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1EventFinishFunctionRegisterer.html">EventFinishFunctionRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1EventQueryFunctionRegisterer.html">EventQueryFunctionRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1EventRecordFunctionRegisterer.html">EventRecordFunctionRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1EventResetFunctionRegisterer.html">EventResetFunctionRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1EventSetFinishedFunctionRegisterer.html">EventSetFinishedFunctionRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1EventWaitFunctionRegisterer.html">EventWaitFunctionRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ExpandDimsOp.html">ExpandDimsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1ExpCPUFunctor.html">ExpCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ExpLearningRate.html">ExpLearningRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ExportedStat.html">ExportedStat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1ExportedStatValue.html">ExportedStatValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FeedBlobOp.html">FeedBlobOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FileReader.html">FileReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FileStoreHandler.html">FileStoreHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FileStoreHandlerCreateOp.html">FileStoreHandlerCreateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FillerOp.html">FillerOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FindDuplicateElementsOp.html">FindDuplicateElementsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FindOp.html">FindOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FixedDivisor.html">FixedDivisor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FixedDivisor_3_01int32__t_01_4.html">FixedDivisor&lt; int32_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FixedLearningRate.html">FixedLearningRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1FixedType.html">FixedType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1FixedValues.html">FixedValues</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FlattenOp.html">FlattenOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FlattenToVecOp.html">FlattenToVecOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FlexibleTopKGradientOp.html">FlexibleTopKGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FlexibleTopKOp.html">FlexibleTopKOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Float16ConstantFillOp.html">Float16ConstantFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FloatToHalfOp.html">FloatToHalfOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FloatToRowwiseQuantized8BitsOp.html">FloatToRowwiseQuantized8BitsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1ForEach.html">ForEach</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcaffe2_1_1ForEach.html" title="ForEach is a unary functor that forwards each element of the input array into the elementwise Functor...">ForEach</a> is a unary functor that forwards each element of the input array into the elementwise Functor provided, and gathers the results of each call into the resulting array.  <a href="structcaffe2_1_1ForEach.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FP16MomentumSGDUpdateOp.html">FP16MomentumSGDUpdateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FP32MomentumSGDUpdateOp.html">FP32MomentumSGDUpdateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FreeOp.html">FreeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FtrlOp.html">FtrlOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1FtrlParams.html">FtrlParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FullyConnectedDecompGradientOp.html">FullyConnectedDecompGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FullyConnectedGradientOp.html">FullyConnectedGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FullyConnectedOp.html">FullyConnectedOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FullyConnectedOp__SPARSE.html">FullyConnectedOp_SPARSE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FullyConnectedOpDecomp.html">FullyConnectedOpDecomp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FullyConnectedOpPrune.html">FullyConnectedOpPrune</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FullyConnectedPruneGradientOp.html">FullyConnectedPruneGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FunHashGradientOp.html">FunHashGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1FunHashOp.html">FunHashOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GatherByKeyOp.html">GatherByKeyOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GatherOp.html">GatherOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GatherPaddingOp.html">GatherPaddingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GatherRangesOp.html">GatherRangesOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GatherRangesToDenseOp.html">GatherRangesToDenseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GaussianFillOp.html">GaussianFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GenerateProposalsOp.html">GenerateProposalsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1GenericTensorImplementation.html">GenericTensorImplementation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetAbsGradient.html">GetAbsGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1GetAddPaddingGradient.html">GetAddPaddingGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetAveragedLossGradient.html">GetAveragedLossGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetBatchGatherGradient.html">GetBatchGatherGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetBatchToSpaceGradient.html">GetBatchToSpaceGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetCastGradient.html">GetCastGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetChannelShuffleGradient.html">GetChannelShuffleGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetCol2ImGradient.html">GetCol2ImGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetColwiseMaxGradient.html">GetColwiseMaxGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetConcatGradient.html">GetConcatGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetConvGradient.html">GetConvGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetConvTransposeGradient.html">GetConvTransposeGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetCosGradient.html">GetCosGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetCosineSimilarityGradient.html">GetCosineSimilarityGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetCrossEntropyGradient.html">GetCrossEntropyGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetDotProductGradient.html">GetDotProductGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetDotProductWithPaddingGradient.html">GetDotProductWithPaddingGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetDropoutGradient.html">GetDropoutGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1GetElementwiseLinearGradient.html">GetElementwiseLinearGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetEluGradient.html">GetEluGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetExpGradient.html">GetExpGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetFCDecompGradient.html">GetFCDecompGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetFlattenGradient.html">GetFlattenGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetFloatToHalfGradient.html">GetFloatToHalfGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetGRUUnitGradient.html">GetGRUUnitGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetHalfToFloatGradient.html">GetHalfToFloatGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetIm2ColGradient.html">GetIm2ColGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetInstanceNormGradient.html">GetInstanceNormGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetL1DistanceGradient.html">GetL1DistanceGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetLabelCrossEntropyGradient.html">GetLabelCrossEntropyGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetLeakyReluGradient.html">GetLeakyReluGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetLogGradient.html">GetLogGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetLRNGradient.html">GetLRNGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetLSTMUnitGradient.html">GetLSTMUnitGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1GetMakeTwoClassGradient.html">GetMakeTwoClassGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetMatMulGradient.html">GetMatMulGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetMaxGradient.html">GetMaxGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetMinGradient.html">GetMinGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1GetNanCheckGradient.html">GetNanCheckGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetNCHW2NHWCGradient.html">GetNCHW2NHWCGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1GetNegateGradientGradient.html">GetNegateGradientGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetNegativeGradient.html">GetNegativeGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetNHWC2NCHWGradient.html">GetNHWC2NCHWGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetNormalizeGradient.html">GetNormalizeGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetPackSegmentsGradient.html">GetPackSegmentsGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetPadImageGradient.html">GetPadImageGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetPoolGradient.html">GetPoolGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetPReluGradient.html">GetPReluGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetPrependDimGradient.html">GetPrependDimGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1GetRecurrentGradient.html">GetRecurrentGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1GetRecurrentNetworkGradient.html">GetRecurrentNetworkGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetReduceBackMaxGradient.html">GetReduceBackMaxGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetReduceBackMeanGradient.html">GetReduceBackMeanGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetReduceBackSumGradient.html">GetReduceBackSumGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetReduceFrontMaxGradient.html">GetReduceFrontMaxGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetReduceFrontMeanGradient.html">GetReduceFrontMeanGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetReduceFrontSumGradient.html">GetReduceFrontSumGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetReluGradient.html">GetReluGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1GetRemovePaddingGradient.html">GetRemovePaddingGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetReshapeGradient.html">GetReshapeGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetResizeNearestGradient.html">GetResizeNearestGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetReversePackedSegsGradient.html">GetReversePackedSegsGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetRowwiseMaxGradient.html">GetRowwiseMaxGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetScaleGradient.html">GetScaleGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetSeluGradient.html">GetSeluGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1GetSigmoidCrossEntropyWithLogitsGradient.html">GetSigmoidCrossEntropyWithLogitsGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetSigmoidGradient.html">GetSigmoidGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetSinGradient.html">GetSinGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetSoftmaxGradient.html">GetSoftmaxGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetSoftplusGradient.html">GetSoftplusGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetSoftsignGradient.html">GetSoftsignGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetSpaceToBatchGradient.html">GetSpaceToBatchGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetSpatialBNGradient.html">GetSpatialBNGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetSplitGradient.html">GetSplitGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetSqrGradient.html">GetSqrGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetSquaredL2DistanceGradient.html">GetSquaredL2DistanceGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetSquareRootDivideGradient.html">GetSquareRootDivideGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetSumElementsGradient.html">GetSumElementsGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetSwishGradient.html">GetSwishGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetTanhGradient.html">GetTanhGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetTileGradient.html">GetTileGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetTopKGradient.html">GetTopKGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetTransposeGradient.html">GetTransposeGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GetUnpackSegmentsGradient.html">GetUnpackSegmentsGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1GetWeightedSigmoidCrossEntropyWithLogitsGradient.html">GetWeightedSigmoidCrossEntropyWithLogitsGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1GetZeroGradientOpGradient.html">GetZeroGradientOpGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GivenTensorFillOp.html">GivenTensorFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GLNormPlanarYUVOp.html">GLNormPlanarYUVOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GLPoolOp.html">GLPoolOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GLPredictor.html">GLPredictor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GluOp.html">GluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GPUFallbackOp.html">GPUFallbackOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A templated class to allow one to wrap a CPU operator as a CUDA operator.  <a href="classcaffe2_1_1GPUFallbackOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GradientMakerBase.html">GradientMakerBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1GradientNotImplementedYet.html">GradientNotImplementedYet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to indicate that the gradient mechanism is not ready.  <a href="structcaffe2_1_1GradientNotImplementedYet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1GradientOpsMeta.html">GradientOpsMeta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct that holds the gradient operators and related gradient maps.  <a href="structcaffe2_1_1GradientOpsMeta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1GradientWrapper.html">GradientWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GRUUnitGradientOp.html">GRUUnitGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1GRUUnitOp.html">GRUUnitOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1HalfToFloatOp.html">HalfToFloatOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1HasElementsOp.html">HasElementsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1HasScopeOp.html">HasScopeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1HillLearningRate.html">HillLearningRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1HSoftmaxGradientOp.html">HSoftmaxGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1HSoftmaxOp.html">HSoftmaxOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1HSoftmaxOpBase.html">HSoftmaxOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1HSoftmaxSearchOp.html">HSoftmaxSearchOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1HuffmanTreeHierarchyOp.html">HuffmanTreeHierarchyOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1IfOp.html">IfOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Im2ColOp.html">Im2ColOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ImageAllocator.html">ImageAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ImageInputOp.html">ImageInputOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1Index.html">Index</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1IndexBase.html">IndexBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1IndexCreateOp.html">IndexCreateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1IndexDeserializer.html">IndexDeserializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1IndexFreezeOp.html">IndexFreezeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1IndexGetOp.html">IndexGetOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1IndexHashOp.html">IndexHashOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1IndexLoadOp.html">IndexLoadOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1IndexSerializer.html">IndexSerializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1IndexSizeOp.html">IndexSizeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1IndexStoreOp.html">IndexStoreOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1InitRegisterer.html">InitRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1InstanceNormGradientOp.html">InstanceNormGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1InstanceNormOp.html">InstanceNormOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1InvLearningRate.html">InvLearningRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1IsEmptyOp.html">IsEmptyOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1IsMemberOfOp.html">IsMemberOfOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1IsMemberOfValueHolder.html">IsMemberOfValueHolder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1IterOp.html">IterOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1KeyValueToMapOp.html">KeyValueToMapOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1L1DistanceGradientOp.html">L1DistanceGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1L1DistanceOp.html">L1DistanceOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LabelCrossEntropyGradientOp.html">LabelCrossEntropyGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LabelCrossEntropyOp.html">LabelCrossEntropyOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LambdaRankNdcgGradientOp.html">LambdaRankNdcgGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LambdaRankNdcgOp.html">LambdaRankNdcgOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LayerNormGradientOp.html">LayerNormGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LayerNormOp.html">LayerNormOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LeakyReluGradientOp.html">LeakyReluGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LeakyReluOp.html">LeakyReluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LearningRateFunctor.html">LearningRateFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LearningRateOp.html">LearningRateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LengthsGatherOp.html">LengthsGatherOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1LengthsOpGetGradient.html">LengthsOpGetGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LengthsPartitionOp.html">LengthsPartitionOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LengthsRangeFillOp.html">LengthsRangeFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LengthsTileOp.html">LengthsTileOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LengthsTopKGradientOp.html">LengthsTopKGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LengthsTopKOp.html">LengthsTopKOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LengthsToRangesOp.html">LengthsToRangesOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LengthsToSegmentIdsOp.html">LengthsToSegmentIdsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LengthsToShapeOp.html">LengthsToShapeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LengthsToWeightsOp.html">LengthsToWeightsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LinearWarmupLearningRate.html">LinearWarmupLearningRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LoadOp.html">LoadOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1LogCPUFunctor.html">LogCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LoggerVoidify.html">LoggerVoidify</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1LogitCPUFunctor.html">LogitCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LogitGradientOp.html">LogitGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LogMeanExpRangeReducer.html">LogMeanExpRangeReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LogMeanExpRangeReducer_3_01T_00_01CPUContext_01_4.html">LogMeanExpRangeReducer&lt; T, CPUContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1LogMeanExpRangeReducerDef.html">LogMeanExpRangeReducerDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LogMeanExpRangeReducerGradient.html">LogMeanExpRangeReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LogSumExpRangeReducer.html">LogSumExpRangeReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LogSumExpRangeReducer_3_01T_00_01CPUContext_01_4.html">LogSumExpRangeReducer&lt; T, CPUContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1LogSumExpRangeReducerDef.html">LogSumExpRangeReducerDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LogSumExpRangeReducerGradient.html">LogSumExpRangeReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LpNormGradientOp.html">LpNormGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LpNormOp.html">LpNormOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LpPool.html">LpPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LRNGradientOp.html">LRNGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LRNOp.html">LRNOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LRNOpBase.html">LRNOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LSTMUnitGradientOp.html">LSTMUnitGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1LSTMUnitOp.html">LSTMUnitOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1MakeAligned.html">MakeAligned</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MakeTwoClassGradientOp.html">MakeTwoClassGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MakeTwoClassOp.html">MakeTwoClassOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MapDeserializer.html">MapDeserializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MapSerializer.html">MapSerializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MapToKeyValueOp.html">MapToKeyValueOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1MapTypeTraits.html">MapTypeTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MarginRankingCriterionGradientOp.html">MarginRankingCriterionGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MarginRankingCriterionOp.html">MarginRankingCriterionOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MatMulOp.html">MatMulOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MaxGradientOp.html">MaxGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MaxMinOpBase.html">MaxMinOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MaxOp.html">MaxOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MaxPool.html">MaxPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MaxPoolGradientRTCOp.html">MaxPoolGradientRTCOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MaxPoolRTCOp.html">MaxPoolRTCOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MaxPoolWithIndexGradientOp.html">MaxPoolWithIndexGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MaxPoolWithIndexOp.html">MaxPoolWithIndexOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MaxRangeReducer.html">MaxRangeReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MaxRangeReducer_3_01T_00_01CPUContext_01_4.html">MaxRangeReducer&lt; T, CPUContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1MaxRangeReducerDef.html">MaxRangeReducerDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MaxRangeReducerGradient.html">MaxRangeReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MaxReduceDimsGradientOp.html">MaxReduceDimsGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MaxReduceDimsOp.html">MaxReduceDimsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MaxReducer.html">MaxReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MaxReducer_3_01T_00_01CPUContext_01_4.html">MaxReducer&lt; T, CPUContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1MaxReducerDef.html">MaxReducerDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MaxReducerGradient.html">MaxReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MaxReductionGradientOp.html">MaxReductionGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MaxReductionOp.html">MaxReductionOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MeanRangeReducer.html">MeanRangeReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MeanRangeReducer_3_01T_00_01CPUContext_01_4.html">MeanRangeReducer&lt; T, CPUContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1MeanRangeReducerDef.html">MeanRangeReducerDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MeanRangeReducerGradient.html">MeanRangeReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MeanReducer.html">MeanReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MeanReducer_3_01T_00_01CPUContext_01_4.html">MeanReducer&lt; T, CPUContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1MeanReducerDef.html">MeanReducerDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MeanReducerGradient.html">MeanReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MemoryAllocationReporter.html">MemoryAllocationReporter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MergeDimOp.html">MergeDimOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MergeIdListsOp.html">MergeIdListsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MessageLogger.html">MessageLogger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MinGradientOp.html">MinGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MinOp.html">MinOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MKLContext.html">MKLContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MKL Context, which is largely the same as the <a class="el" href="classcaffe2_1_1CPUContext.html" title="The CPU Context, representing the bare minimum of what a Context class in Caffe2 should implement...">CPUContext</a>.  <a href="classcaffe2_1_1MKLContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ModOp.html">ModOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ModuleSchema.html">ModuleSchema</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A module schema that can be used to store specific information about different modules.  <a href="classcaffe2_1_1ModuleSchema.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MomentumSGDOp.html">MomentumSGDOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MomentumSGDUpdateOp.html">MomentumSGDUpdateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MPICommonWorldWrapper.html">MPICommonWorldWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple wrapper over an MPI common world.  <a href="classcaffe2_1_1MPICommonWorldWrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MPIDataTypeWrapper.html">MPIDataTypeWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1MPSCNNContext.html">MPSCNNContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MSRAFillOp.html">MSRAFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MultiClassAccuracyOp.html">MultiClassAccuracyOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MutexDeserializer.html">MutexDeserializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1MutexSerializer.html">MutexSerializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1NanCheckOp.html">NanCheckOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1NCHW2NHWCOp.html">NCHW2NHWCOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1NegateGradientOp.html">NegateGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1NegativeCPUFunctor.html">NegativeCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1NetBase.html">NetBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1NetObserverReporter.html">NetObserverReporter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1NetObserverReporterPrint.html">NetObserverReporterPrint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1NHWC2NCHWOp.html">NHWC2NCHWOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1NNPACKConvOp.html">NNPACKConvOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to denote that an op does not have a default engine.  <a href="classcaffe2_1_1NoDefaultEngineOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1NoGradient.html">NoGradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to indicate that the operator does not need gradient computation.  <a href="classcaffe2_1_1NoGradient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1NormalizeGradientOp.html">NormalizeGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1NormalizeL1Op.html">NormalizeL1Op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1NormalizeOp.html">NormalizeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1NotFunctor.html">NotFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Observable.html">Observable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inherit to make your class observable.  <a href="classcaffe2_1_1Observable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ObserverBase.html">ObserverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use this to implement a Observer using the Observer Pattern template.  <a href="classcaffe2_1_1ObserverBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ObserverConfig.html">ObserverConfig</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OneHotOp.html">OneHotOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OpenGLAddOp.html">OpenGLAddOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OpenGLConcatOp.html">OpenGLConcatOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OpenGLConvOp.html">OpenGLConvOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OpenGLConvTransposeOp.html">OpenGLConvTransposeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OpenGLInstanceNormPReluOp.html">OpenGLInstanceNormPReluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OpenGLMulOp.html">OpenGLMulOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OpenGLPadImageOp.html">OpenGLPadImageOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OpenGLPReluOp.html">OpenGLPReluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OpenGLResizeNearestOp.html">OpenGLResizeNearestOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OpenGLSigmoidOp.html">OpenGLSigmoidOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OpenGLSubOp.html">OpenGLSubOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OpenGLTensorToTextureStylizerPreprocessOp.html">OpenGLTensorToTextureStylizerPreprocessOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OpenGLTextureToTensorStylizerDeprocessOp.html">OpenGLTextureToTensorStylizerDeprocessOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OpenGLTextureToTextureStylizerDeprocessOp.html">OpenGLTextureToTextureStylizerDeprocessOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OpenGLTextureToTextureStylizerPreprocessOp.html">OpenGLTextureToTextureStylizerPreprocessOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Operator.html">Operator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OperatorBase.html">OperatorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OpSchema.html">OpSchema</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to record the schema of an op.  <a href="classcaffe2_1_1OpSchema.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1OpSchemaRegistry.html">OpSchemaRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A registry to hold all the operator schemas.  <a href="classcaffe2_1_1OpSchemaRegistry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1OpTask.html">OpTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure for a scheduled task in the task queue.  <a href="structcaffe2_1_1OpTask.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PackedInt8BGRANHWCToNCHWCStylizerPreprocessOp.html">PackedInt8BGRANHWCToNCHWCStylizerPreprocessOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PackRNNSequenceOpBase.html">PackRNNSequenceOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PackSegmentsOp.html">PackSegmentsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PadEmptySamplesOp.html">PadEmptySamplesOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PadImageGradientOp.html">PadImageGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PadImageOp.html">PadImageOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PairWiseLossGradientOp.html">PairWiseLossGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PairWiseLossOp.html">PairWiseLossOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Params.html">Params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PartitionOp.html">PartitionOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PartitionOpBase.html">PartitionOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PatternNetTransform.html">PatternNetTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1PatternNetTransform.html" title="PatternNetTransform allows you to create transforms using a simple interface. ">PatternNetTransform</a> allows you to create transforms using a simple interface.  <a href="classcaffe2_1_1PatternNetTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PerfNetObserver.html">PerfNetObserver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PerfOperatorObserver.html">PerfOperatorObserver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PerplexityOp.html">PerplexityOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PiecewiseLinearTransformOp.html">PiecewiseLinearTransformOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1PinnedCPUAllocator.html">PinnedCPUAllocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An allocator that does the CPU memory allocation with pinned memory.  <a href="structcaffe2_1_1PinnedCPUAllocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1PlanExecutionTime.html">PlanExecutionTime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PolyLearningRate.html">PolyLearningRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PoolGradientOp.html">PoolGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PoolOp.html">PoolOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1PowFunctor.html">PowFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Predictor.html">Predictor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PrefetchOperator.html">PrefetchOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PReluGradientOp.html">PReluGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PReluOp.html">PReluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PrependDimOp.html">PrependDimOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1PrintOp.html">PrintOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1QConvOp.html">QConvOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1QConvState.html">QConvState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1QTensor.html">QTensor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1QTensorDeserializer.html">QTensorDeserializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1QTensorSerializer.html">QTensorSerializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1QuantDecodeGradientOp.html">QuantDecodeGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1QuantDecodeOp.html">QuantDecodeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1QuantDecompZstdOp.html">QuantDecompZstdOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RangeFillOp.html">RangeFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RangeOp.html">RangeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RebatchingQueue.html">RebatchingQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RecurrentBaseOp.html">RecurrentBaseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RecurrentGradientOp.html">RecurrentGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RecurrentNetworkBlobFetcherOp.html">RecurrentNetworkBlobFetcherOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RecurrentNetworkExecutorBase.html">RecurrentNetworkExecutorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RecurrentNetworkExecutor is a specialized runtime for recurrent neural networks (RNNs).  <a href="classcaffe2_1_1RecurrentNetworkExecutorBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RecurrentNetworkGradientOp.html">RecurrentNetworkGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RecurrentNetworkOp.html">RecurrentNetworkOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RecurrentOp.html">RecurrentOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RecurrentParamAccessOp.html">RecurrentParamAccessOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RedisStoreHandler.html">RedisStoreHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RedisStoreHandlerCreateOp.html">RedisStoreHandlerCreateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ReduceTailSumOp.html">ReduceTailSumOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Registerer.html">Registerer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Registry.html">Registry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class that allows one to register classes by keys.  <a href="classcaffe2_1_1Registry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ReluGradientOp.html">ReluGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ReluOp.html">ReluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RemoveDataBlocksOp.html">RemoveDataBlocksOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RemovePaddingOp.html">RemovePaddingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ReplaceNaNOp.html">ReplaceNaNOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ResetCounterOp.html">ResetCounterOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ReshapeOp.html">ReshapeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ResizeLikeOp.html">ResizeLikeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ResizeNearestGradientOp.html">ResizeNearestGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ResizeNearestOp.html">ResizeNearestOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RetrieveCountOp.html">RetrieveCountOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ReversePackedSegsOp.html">ReversePackedSegsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RMACRegionsOp.html">RMACRegionsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RmsPropOp.html">RmsPropOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RNNApplyLinkOp.html">RNNApplyLinkOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1RNNNetOperator.html">RNNNetOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for operator in a timestep and its dependenceis.  <a href="structcaffe2_1_1RNNNetOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RoIPoolGradientOp.html">RoIPoolGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RoIPoolOp.html">RoIPoolOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RowMulOp.html">RowMulOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Rowwise8BitQuantizedToFloatOp.html">Rowwise8BitQuantizedToFloatOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RowWiseSparseAdagradOp.html">RowWiseSparseAdagradOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RunCountNetObserver.html">RunCountNetObserver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1RunCountOperatorObserver.html">RunCountOperatorObserver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SafeDequeueBlobsOp.html">SafeDequeueBlobsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SafeEnqueueBlobsOp.html">SafeEnqueueBlobsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1SameTypeAsInput.html">SameTypeAsInput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1SampleInterval.html">SampleInterval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SaveOp.html">SaveOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ScaleOp.html">ScaleOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ScatterAssignOp.html">ScatterAssignOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update slices of the tensor in-place by overriding.  <a href="classcaffe2_1_1ScatterAssignOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ScatterWeightedSumOp.html">ScatterWeightedSumOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update slices of the tensor in-place with weighted sum.  <a href="classcaffe2_1_1ScatterWeightedSumOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SegmentIdsToLengthsOp.html">SegmentIdsToLengthsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SegmentIdsToRangesOp.html">SegmentIdsToRangesOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SegmentOneHotOp.html">SegmentOneHotOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1SegmentOpGetGradient.html">SegmentOpGetGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SelectGradientOpBase.html">SelectGradientOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SeluGradientOp.html">SeluGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SeluOp.html">SeluOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SequenceMaskOp.html">SequenceMaskOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ShapeOp.html">ShapeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1SigmoidCPUFunctor.html">SigmoidCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SigmoidCrossEntropyWithLogitsGradientOp.html">SigmoidCrossEntropyWithLogitsGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SigmoidCrossEntropyWithLogitsOp.html">SigmoidCrossEntropyWithLogitsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1SigmoidGradientCPUFunctor.html">SigmoidGradientCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SignalHandler.html">SignalHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1SignCPUFunctor.html">SignCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SimpleNet.html">SimpleNet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SimpleQueue.html">SimpleQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1SinCPUFunctor.html">SinCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SingleOpTransform.html">SingleOpTransform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Single Op <a class="el" href="classcaffe2_1_1Transform.html" title="The Transform Base Object. ">Transform</a> Base class.  <a href="classcaffe2_1_1SingleOpTransform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1SinGradientCPUFunctor.html">SinGradientCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SinusoidPositionEncodingOp.html">SinusoidPositionEncodingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SizeOp.html">SizeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SkipIndices.html">SkipIndices</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SkipIndices_3_4.html">SkipIndices&lt;&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SliceGradientOp.html">SliceGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SliceOp.html">SliceOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SmartTensorPrinter.html">SmartTensorPrinter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SNPEOp.html">SNPEOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SoftmaxGradientOp.html">SoftmaxGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SoftmaxOp.html">SoftmaxOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SoftmaxWithLossGradientOp.html">SoftmaxWithLossGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SoftmaxWithLossOp.html">SoftmaxWithLossOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SoftplusGradientOp.html">SoftplusGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SoftplusOp.html">SoftplusOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1SoftsignCPUFunctor.html">SoftsignCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1SoftsignGradientCPUFunctor.html">SoftsignGradientCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SpaceBatchOpBase.html">SpaceBatchOpBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SpaceToBatchOp.html">SpaceToBatchOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SparseAdagradOp.html">SparseAdagradOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SparseAdamOp.html">SparseAdamOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SparseFtrlOp.html">SparseFtrlOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SparseFunHashGradientOp.html">SparseFunHashGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SparseFunHashOp.html">SparseFunHashOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SparseLengths8BitsRowwiseOp.html">SparseLengths8BitsRowwiseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SparseMatrixReshapeOp.html">SparseMatrixReshapeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SparseMomentumSGDUpdateOp.html">SparseMomentumSGDUpdateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SparseToDenseMaskBase.html">SparseToDenseMaskBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SparseToDenseMaskGradientOp.html">SparseToDenseMaskGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SparseToDenseMaskOp.html">SparseToDenseMaskOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SparseToDenseOp.html">SparseToDenseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SpatialBNGradientOp.html">SpatialBNGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SpatialBNOp.html">SpatialBNOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SpatialSoftmaxWithLossGradientOp.html">SpatialSoftmaxWithLossGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SpatialSoftmaxWithLossOp.html">SpatialSoftmaxWithLossOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SplitOp.html">SplitOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1SqrCPUFunctor.html">SqrCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SquaredL2DistanceGradientOp.html">SquaredL2DistanceGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SquaredL2DistanceOp.html">SquaredL2DistanceOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SquareRootDivideOp.html">SquareRootDivideOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SqueezeOp.html">SqueezeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1Stat.html">Stat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1StaticLinkingProtector.html">StaticLinkingProtector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1StatRegistry.html">StatRegistry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds a map of atomic counters keyed by name.  <a href="classcaffe2_1_1StatRegistry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1StatRegistryCreateOp.html">StatRegistryCreateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1StatRegistryExportOp.html">StatRegistryExportOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1StatRegistryUpdateOp.html">StatRegistryUpdateOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1StatValue.html">StatValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1StdDevExportedStat.html">StdDevExportedStat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1StepLearningRate.html">StepLearningRate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1StopGradientOp.html">StopGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1StopOnSignal.html">StopOnSignal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1StoreAddOp.html">StoreAddOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1StoreGetOp.html">StoreGetOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1StoreHandler.html">StoreHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1StoreHandlerTimeoutException.html">StoreHandlerTimeoutException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1StoreSetOp.html">StoreSetOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1StoreWaitOp.html">StoreWaitOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1StringDeserializer.html">StringDeserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1StringDeserializer.html" title="StringDeserializer is the deserializer for Strings. ">StringDeserializer</a> is the deserializer for Strings.  <a href="classcaffe2_1_1StringDeserializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1StringJoinOp.html">StringJoinOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1StringProvider.html">StringProvider</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1StringSerializer.html">StringSerializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1StringSerializer.html" title="StringSerializer is the serializer for String. ">StringSerializer</a> is the serializer for String.  <a href="classcaffe2_1_1StringSerializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SumElementsGradientOp.html">SumElementsGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SumElementsOp.html">SumElementsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SummarizeOp.html">SummarizeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SumOp.html">SumOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SumRangeReducer.html">SumRangeReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SumRangeReducer_3_01T_00_01CPUContext_01_4.html">SumRangeReducer&lt; T, CPUContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1SumRangeReducerDef.html">SumRangeReducerDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SumRangeReducerGradient.html">SumRangeReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SumReduceDimsGradientOp.html">SumReduceDimsGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SumReduceDimsOp.html">SumReduceDimsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SumReduceLikeOp.html">SumReduceLikeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SumReducer.html">SumReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SumReducer_3_01T_00_01CPUContext_01_4.html">SumReducer&lt; T, CPUContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1SumReducerDef.html">SumReducerDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SumReducerGradient.html">SumReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SumSqrElementsOp.html">SumSqrElementsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1SwishCPUFunctor.html">SwishCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1SwishGradientOp.html">SwishGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1TanhCPUFunctor.html">TanhCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1TanhGradientCPUFunctor.html">TanhGradientCPUFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1Task.html">Task</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TaskThreadPool.html">TaskThreadPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1Tensor.html" title="Tensor is the basic class in Caffe2 that stores a contiguous memory with its shape information...">Tensor</a> is the basic class in Caffe2 that stores a contiguous memory with its shape information.  <a href="classcaffe2_1_1Tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TensorDeserializer.html">TensorDeserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1TensorDeserializer.html" title="TensorDeserializer is the deserializer for Tensors. ">TensorDeserializer</a> is the deserializer for Tensors.  <a href="classcaffe2_1_1TensorDeserializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TensorPrinter.html">TensorPrinter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TensorProtosDBInput.html">TensorProtosDBInput</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TensorSerializer.html">TensorSerializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1TensorSerializer.html" title="TensorSerializer is the serializer for Tensors. ">TensorSerializer</a> is the serializer for Tensors.  <a href="classcaffe2_1_1TensorSerializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1TensorTypes2.html">TensorTypes2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1TextFileReaderInstance.html">TextFileReaderInstance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TextFileReaderReadOp.html">TextFileReaderReadOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ThreadedRecurrentNetworkExecutor.html">ThreadedRecurrentNetworkExecutor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ThreadLocalCUDAObjects.html">ThreadLocalCUDAObjects</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A struct to host thread-local cuda objects.  <a href="classcaffe2_1_1ThreadLocalCUDAObjects.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ThreadPool.html">ThreadPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1ThrowInTheTowelIfGradientIsCalled.html">ThrowInTheTowelIfGradientIsCalled</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class to indicate that the operator should have no gradient.  <a href="structcaffe2_1_1ThrowInTheTowelIfGradientIsCalled.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TileGradientOp.html">TileGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TileOp.html">TileOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TimeObserver.html">TimeObserver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TimeObserver_3_01NetBase_01_4.html">TimeObserver&lt; NetBase &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TimeObserver_3_01OperatorBase_01_4.html">TimeObserver&lt; OperatorBase &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TimeObserverBase.html">TimeObserverBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Timer.html">Timer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple timer object for measuring time.  <a href="classcaffe2_1_1Timer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1TimerBeginOp.html">TimerBeginOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1TimerEndOp.html">TimerEndOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1TimerGetAndEndOp.html">TimerGetAndEndOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1TimerGetOp.html">TimerGetOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TimerInstance.html">TimerInstance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1Token.html">Token</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TokenizedString.html">TokenizedString</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Tokenizer.html">Tokenizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TopKGradientOp.html">TopKGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TopKOp.html">TopKOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Transform.html">Transform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classcaffe2_1_1Transform.html" title="The Transform Base Object. ">Transform</a> Base Object.  <a href="classcaffe2_1_1Transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TransposeOp.html">TransposeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TTContractionGradientOp.html">TTContractionGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TTContractionOp.html">TTContractionOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TTLinearGradientOp.html">TTLinearGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TTLinearOp.html">TTLinearOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TTPadGradientOp.html">TTPadGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TTPadOp.html">TTPadOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1TypeMeta.html">TypeMeta</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1TypeMeta.html" title="TypeMeta is a thin class that allows us to store the type of a container such as a blob...">TypeMeta</a> is a thin class that allows us to store the type of a container such as a blob, or the data type of a tensor, with a unique run-time id.  <a href="classcaffe2_1_1TypeMeta.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1TypeNameRegisterer.html">TypeNameRegisterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1TypeNameTraits.html">TypeNameTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1TypeNameTraits_3_01int32__t_01_4.html">TypeNameTraits&lt; int32_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1TypeNameTraits_3_01int64__t_01_4.html">TypeNameTraits&lt; int64_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1UnaryElementwiseWithArgsOp.html">UnaryElementwiseWithArgsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1UniformFillOp.html">UniformFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1UniqueOp.html">UniqueOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduplicates input indices vector and optionally produces reverse remapping.  <a href="classcaffe2_1_1UniqueOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1UniqueUniformFillOp.html">UniqueUniformFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1UnpackSegmentsOp.html">UnpackSegmentsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1UnsafeCoalesceOp.html">UnsafeCoalesceOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1UnsupportedOperatorFeature.html">UnsupportedOperatorFeature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1VideoDecoder.html">VideoDecoder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1VideoInputOp.html">VideoInputOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1VideoIOContext.html">VideoIOContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1VideoMeta.html">VideoMeta</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1WallClockTimeOp.html">WallClockTimeOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1WeightedSampleDequeueBlobsOp.html">WeightedSampleDequeueBlobsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1WeightedSampleOp.html">WeightedSampleOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1WeightedSigmoidCrossEntropyWithLogitsGradientOp.html">WeightedSigmoidCrossEntropyWithLogitsGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1WeightedSigmoidCrossEntropyWithLogitsOp.html">WeightedSigmoidCrossEntropyWithLogitsOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1WeightedSumGradientOp.html">WeightedSumGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1WeightedSumOp.html">WeightedSumOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1WeightedSumReducer.html">WeightedSumReducer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1WeightedSumReducer_3_01T_00_01CPUContext_01_4.html">WeightedSumReducer&lt; T, CPUContext &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1WeightedSumReducerDef.html">WeightedSumReducerDef</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1WeightedSumReducerGradient.html">WeightedSumReducerGradient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1WhereOp.html">WhereOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1WhileOp.html">WhileOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1WithDefaultConstructor.html">WithDefaultConstructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structcaffe2_1_1WithDefaultConstructor.html" title="WithDefaultConstructor is a functor that can be used as the functor of an UnaryElementwiseWithArgsOp...">WithDefaultConstructor</a> is a functor that can be used as the functor of an <a class="el" href="classcaffe2_1_1UnaryElementwiseWithArgsOp.html">UnaryElementwiseWithArgsOp</a>.  <a href="structcaffe2_1_1WithDefaultConstructor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcaffe2_1_1WithoutBroadcast.html">WithoutBroadcast</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Worker.html">Worker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1WorkersPool.html">WorkersPool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcaffe2_1_1Workspace.html" title="Workspace is a class that holds all the related objects created during runtime: (1) all blobs...">Workspace</a> is a class that holds all the related objects created during runtime: (1) all blobs, and (2) all instantiated networks.  <a href="classcaffe2_1_1Workspace.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1XavierFillOp.html">XavierFillOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1YellowFinOp.html">YellowFinOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ZeroGradientOp.html">ZeroGradientOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ZmqContext.html">ZmqContext</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ZmqMessage.html">ZmqMessage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcaffe2_1_1ZmqSocket.html">ZmqSocket</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aef39c024cb7f37c6cff2725d7a701189"><td class="memItemLeft" align="right" valign="top"><a id="aef39c024cb7f37c6cff2725d7a701189"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MemoryDeleter</b> = void(*)(void *)</td></tr>
<tr class="separator:aef39c024cb7f37c6cff2725d7a701189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6a9203ab54d205dc23184848d9581b"><td class="memItemLeft" align="right" valign="top"><a id="a8f6a9203ab54d205dc23184848d9581b"></a>
typedef int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>TIndex</b></td></tr>
<tr class="separator:a8f6a9203ab54d205dc23184848d9581b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fb8907c4895c3f71c924e41fa6c87e"><td class="memTemplParams" colspan="2"><a id="ac3fb8907c4895c3f71c924e41fa6c87e"></a>
template&lt;typename Key , typename Value &gt; </td></tr>
<tr class="memitem:ac3fb8907c4895c3f71c924e41fa6c87e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CaffeMap</b> = std::map&lt; Key, Value &gt;</td></tr>
<tr class="separator:ac3fb8907c4895c3f71c924e41fa6c87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f586aeb42d1018592e68c17f1e07f4"><td class="memItemLeft" align="right" valign="top"><a id="ac6f586aeb42d1018592e68c17f1e07f4"></a>
typedef <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TensorCUDA</b></td></tr>
<tr class="separator:ac6f586aeb42d1018592e68c17f1e07f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40511c6a34816a79b326a1145d2142b"><td class="memItemLeft" align="right" valign="top"><a id="ad40511c6a34816a79b326a1145d2142b"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>EventCreateFunction</b>) (const DeviceOption &amp;option, <a class="el" href="classcaffe2_1_1Event.html">Event</a> *)</td></tr>
<tr class="separator:ad40511c6a34816a79b326a1145d2142b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff8832a06132655c341ee77e8e23d9d"><td class="memItemLeft" align="right" valign="top"><a id="a9ff8832a06132655c341ee77e8e23d9d"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>EventRecordFunction</b>) (<a class="el" href="classcaffe2_1_1Event.html">Event</a> *, const void *, const char *)</td></tr>
<tr class="separator:a9ff8832a06132655c341ee77e8e23d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a3d0f77afbc3e3bd658ca02345a11c"><td class="memItemLeft" align="right" valign="top"><a id="a11a3d0f77afbc3e3bd658ca02345a11c"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>EventWaitFunction</b>) (const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *, void *)</td></tr>
<tr class="separator:a11a3d0f77afbc3e3bd658ca02345a11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8905aa87e0470ae1fbdfea83397c5f"><td class="memItemLeft" align="right" valign="top"><a id="a6c8905aa87e0470ae1fbdfea83397c5f"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>EventFinishFunction</b>) (const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *)</td></tr>
<tr class="separator:a6c8905aa87e0470ae1fbdfea83397c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207a754e7e771e2cb7f4a94db2975d14"><td class="memItemLeft" align="right" valign="top"><a id="a207a754e7e771e2cb7f4a94db2975d14"></a>
typedef EventStatus(*&#160;</td><td class="memItemRight" valign="bottom"><b>EventQueryFunction</b>) (const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *)</td></tr>
<tr class="separator:a207a754e7e771e2cb7f4a94db2975d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29abe9cc13481e767ef952a877feb7c7"><td class="memItemLeft" align="right" valign="top"><a id="a29abe9cc13481e767ef952a877feb7c7"></a>
typedef const std::string &amp;(*&#160;</td><td class="memItemRight" valign="bottom"><b>EventErrorMessageFunction</b>) (const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *)</td></tr>
<tr class="separator:a29abe9cc13481e767ef952a877feb7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8890d6156fb78e8999a89d62beb259f0"><td class="memItemLeft" align="right" valign="top"><a id="a8890d6156fb78e8999a89d62beb259f0"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>EventSetFinishedFunction</b>) (const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *, const char *)</td></tr>
<tr class="separator:a8890d6156fb78e8999a89d62beb259f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a783d65faf77c762f145c1dd4c7e4bd"><td class="memItemLeft" align="right" valign="top"><a id="a9a783d65faf77c762f145c1dd4c7e4bd"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>EventResetFunction</b>) (<a class="el" href="classcaffe2_1_1Event.html">Event</a> *)</td></tr>
<tr class="separator:a9a783d65faf77c762f145c1dd4c7e4bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67383b45c782e11815cbe59f1eac9a36"><td class="memItemLeft" align="right" valign="top"><a id="a67383b45c782e11815cbe59f1eac9a36"></a>
typedef <a class="el" href="classcaffe2_1_1ObserverBase.html">ObserverBase</a>&lt; <a class="el" href="classcaffe2_1_1NetBase.html">NetBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NetObserver</b></td></tr>
<tr class="separator:a67383b45c782e11815cbe59f1eac9a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45628c528e48494f9eda62134261812a"><td class="memItemLeft" align="right" valign="top"><a id="a45628c528e48494f9eda62134261812a"></a>
typedef std::function&lt; std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1ObserverBase.html">NetObserver</a> &gt;<a class="el" href="classcaffe2_1_1NetBase.html">NetBase</a> *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>NetObserverCreator</b></td></tr>
<tr class="separator:a45628c528e48494f9eda62134261812a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ef186a62d2ad09644bf50c3862e23b"><td class="memItemLeft" align="right" valign="top"><a id="a66ef186a62d2ad09644bf50c3862e23b"></a>
typedef <a class="el" href="classcaffe2_1_1ObserverBase.html">ObserverBase</a>&lt; <a class="el" href="classcaffe2_1_1OperatorBase.html">OperatorBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>OperatorObserver</b></td></tr>
<tr class="separator:a66ef186a62d2ad09644bf50c3862e23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cbef9a00ccdc1ee24311b5d26560d8b"><td class="memItemLeft" align="right" valign="top"><a id="a4cbef9a00ccdc1ee24311b5d26560d8b"></a>
typedef <a class="el" href="classcaffe2_1_1Registry.html">Registry</a>&lt; std::string, std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1OperatorBase.html">OperatorBase</a> &gt;, const OperatorDef &amp;, <a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> * &gt; *(*&#160;</td><td class="memItemRight" valign="bottom"><b>RegistryFunction</b>) ()</td></tr>
<tr class="separator:a4cbef9a00ccdc1ee24311b5d26560d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f8d16aa5d76f9f5363279130144d4e"><td class="memItemLeft" align="right" valign="top"><a id="a32f8d16aa5d76f9f5363279130144d4e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EnginePrefType</b> = std::vector&lt; std::string &gt;</td></tr>
<tr class="separator:a32f8d16aa5d76f9f5363279130144d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee292cce0955f4677e67b7f55bf8ee6"><td class="memItemLeft" align="right" valign="top"><a id="afee292cce0955f4677e67b7f55bf8ee6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>PerOpEnginePrefType</b> = CaffeMap&lt; int, CaffeMap&lt; std::string, EnginePrefType &gt; &gt;</td></tr>
<tr class="separator:afee292cce0955f4677e67b7f55bf8ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753fdc5b230c2f5b265e6ff694585353"><td class="memItemLeft" align="right" valign="top"><a id="a753fdc5b230c2f5b265e6ff694585353"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>GlobalEnginePrefType</b> = CaffeMap&lt; int, EnginePrefType &gt;</td></tr>
<tr class="separator:a753fdc5b230c2f5b265e6ff694585353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4d01f9e389d63213b288f4743b53c9"><td class="memItemLeft" align="right" valign="top"><a id="a2f4d01f9e389d63213b288f4743b53c9"></a>
typedef std::function&lt; bool(int)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ShouldContinue</b></td></tr>
<tr class="separator:a2f4d01f9e389d63213b288f4743b53c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb1578901c4027246db0d3e46305c7f"><td class="memItemLeft" align="right" valign="top"><a id="a8eb1578901c4027246db0d3e46305c7f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a8eb1578901c4027246db0d3e46305c7f">ExportedStatList</a> = std::vector&lt; <a class="el" href="structcaffe2_1_1ExportedStatValue.html">ExportedStatValue</a> &gt;</td></tr>
<tr class="memdesc:a8eb1578901c4027246db0d3e46305c7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds names and values of counters exported from a <a class="el" href="classcaffe2_1_1StatRegistry.html" title="Holds a map of atomic counters keyed by name. ">StatRegistry</a>. <br /></td></tr>
<tr class="separator:a8eb1578901c4027246db0d3e46305c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22bc270d52b7b38692a572f374d13a23"><td class="memItemLeft" align="right" valign="top"><a id="a22bc270d52b7b38692a572f374d13a23"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ExportedStatMap</b> = std::unordered_map&lt; std::string, int64_t &gt;</td></tr>
<tr class="separator:a22bc270d52b7b38692a572f374d13a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725818e3725cb338845b526d265a4b76"><td class="memItemLeft" align="right" valign="top"><a id="a725818e3725cb338845b526d265a4b76"></a>
typedef <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TensorCPU</b></td></tr>
<tr class="separator:a725818e3725cb338845b526d265a4b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019bdb3c7f9b31b06dbf91c93d245757"><td class="memItemLeft" align="right" valign="top"><a id="a019bdb3c7f9b31b06dbf91c93d245757"></a>
typedef <a class="el" href="classcaffe2_1_1TypeMeta.html">TypeMeta</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>TypeCall</b>) (const void *)</td></tr>
<tr class="separator:a019bdb3c7f9b31b06dbf91c93d245757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e88de5199d57a1f161561d6986bf53"><td class="memItemLeft" align="right" valign="top"><a id="af7e88de5199d57a1f161561d6986bf53"></a>
typedef vector&lt; TIndex &gt;(*&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInfoCall</b>) (const void *, bool *shares_data, size_t *capacity, DeviceOption *device)</td></tr>
<tr class="separator:af7e88de5199d57a1f161561d6986bf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f724c12ed347567a888cc1ef67d8b4b"><td class="memItemLeft" align="right" valign="top"><a id="a2f724c12ed347567a888cc1ef67d8b4b"></a>
typedef intptr_t&#160;</td><td class="memItemRight" valign="bottom"><b>CaffeTypeId</b></td></tr>
<tr class="separator:a2f724c12ed347567a888cc1ef67d8b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbe4e6df1aa7bbe56b971bbf3c7d8e7"><td class="memTemplParams" colspan="2"><a id="adfbe4e6df1aa7bbe56b971bbf3c7d8e7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:adfbe4e6df1aa7bbe56b971bbf3c7d8e7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>deleted_unique_ptr</b> = std::unique_ptr&lt; T, std::function&lt; void(T *)&gt; &gt;</td></tr>
<tr class="separator:adfbe4e6df1aa7bbe56b971bbf3c7d8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843b09ff1b7f933ccafee91a37166f1f"><td class="memItemLeft" align="right" valign="top"><a id="a843b09ff1b7f933ccafee91a37166f1f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ParallelFor</b> = std::function&lt; void(size_t, std::function&lt; void(size_t)&gt;)&gt;</td></tr>
<tr class="separator:a843b09ff1b7f933ccafee91a37166f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea6e82ca849db18c8787d3b6120234c"><td class="memItemLeft" align="right" valign="top"><a id="a2ea6e82ca849db18c8787d3b6120234c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>NumericTypes</b> = <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; int32_t, int64_t, float, double &gt;</td></tr>
<tr class="separator:a2ea6e82ca849db18c8787d3b6120234c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab045ba250e9944f3f7811fd99dedaae7"><td class="memItemLeft" align="right" valign="top"><a id="ab045ba250e9944f3f7811fd99dedaae7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>IntTypes</b> = <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; int32_t, int64_t &gt;</td></tr>
<tr class="separator:ab045ba250e9944f3f7811fd99dedaae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa97ad24133ca3efbf5f8994d62f25c"><td class="memItemLeft" align="right" valign="top"><a id="a0aa97ad24133ca3efbf5f8994d62f25c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>BoolTypes</b> = <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; bool &gt;</td></tr>
<tr class="separator:a0aa97ad24133ca3efbf5f8994d62f25c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c84075c5d69ce9499450fbbb3f72965"><td class="memTemplParams" colspan="2">template&lt;typename InputTypes , class Context , class Functor , class OutputType  = SameTypeAsInput&gt; </td></tr>
<tr class="memitem:a3c84075c5d69ce9499450fbbb3f72965"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a> = <a class="el" href="classcaffe2_1_1UnaryElementwiseWithArgsOp.html">UnaryElementwiseWithArgsOp</a>&lt; InputTypes, Context, <a class="el" href="structcaffe2_1_1WithDefaultConstructor.html">WithDefaultConstructor</a>&lt; Functor &gt;, OutputType &gt;</td></tr>
<tr class="memdesc:a3c84075c5d69ce9499450fbbb3f72965"><td class="mdescLeft">&#160;</td><td class="mdescRight">UnaryElementwiseOp is a wrapper around <a class="el" href="classcaffe2_1_1UnaryElementwiseWithArgsOp.html">UnaryElementwiseWithArgsOp</a>, with the difference that it takes a functor with default constructor, e.g.  <a href="#a3c84075c5d69ce9499450fbbb3f72965">More...</a><br /></td></tr>
<tr class="separator:a3c84075c5d69ce9499450fbbb3f72965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c51741b6fb1fcad46fd018a21f25cc"><td class="memItemLeft" align="right" valign="top"><a id="ad3c51741b6fb1fcad46fd018a21f25cc"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>n</b> = 2</td></tr>
<tr class="separator:ad3c51741b6fb1fcad46fd018a21f25cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af498b94e8bf308ff2f7a23dc58fb49e6"><td class="memItemLeft" align="right" valign="top"><a id="af498b94e8bf308ff2f7a23dc58fb49e6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MapType64To64</b> = <a class="el" href="structcaffe2_1_1MapTypeTraits.html">MapTypeTraits</a>&lt; int64_t, int64_t &gt;::MapType</td></tr>
<tr class="separator:af498b94e8bf308ff2f7a23dc58fb49e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d525a7195f5527ce4a3205004c76599"><td class="memItemLeft" align="right" valign="top"><a id="a8d525a7195f5527ce4a3205004c76599"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MapType64To32</b> = <a class="el" href="structcaffe2_1_1MapTypeTraits.html">MapTypeTraits</a>&lt; int64_t, int32_t &gt;::MapType</td></tr>
<tr class="separator:a8d525a7195f5527ce4a3205004c76599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63037963716071ea7e8f7b177542599"><td class="memItemLeft" align="right" valign="top"><a id="ab63037963716071ea7e8f7b177542599"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MapType32To32</b> = <a class="el" href="structcaffe2_1_1MapTypeTraits.html">MapTypeTraits</a>&lt; int32_t, int32_t &gt;::MapType</td></tr>
<tr class="separator:ab63037963716071ea7e8f7b177542599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37567932357954efed10a870ed2e6512"><td class="memItemLeft" align="right" valign="top"><a id="a37567932357954efed10a870ed2e6512"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MapType32To64</b> = <a class="el" href="structcaffe2_1_1MapTypeTraits.html">MapTypeTraits</a>&lt; int32_t, int64_t &gt;::MapType</td></tr>
<tr class="separator:a37567932357954efed10a870ed2e6512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41406072a99cf57e0f8700827ce061c"><td class="memTemplParams" colspan="2"><a id="af41406072a99cf57e0f8700827ce061c"></a>
template&lt;typename ScalarFunctor , typename TypeMap  = FixedType&lt;std::string&gt;&gt; </td></tr>
<tr class="memitem:af41406072a99cf57e0f8700827ce061c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StringElementwiseOp</b> = <a class="el" href="classcaffe2_1_1UnaryElementwiseWithArgsOp.html">UnaryElementwiseWithArgsOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; std::string &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1ForEach.html">ForEach</a>&lt; ScalarFunctor &gt;, TypeMap &gt;</td></tr>
<tr class="separator:af41406072a99cf57e0f8700827ce061c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55da53004c68821d605bc203b85329d7"><td class="memItemLeft" align="right" valign="top"><a id="a55da53004c68821d605bc203b85329d7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>RebatchingQueuePtr</b> = std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1RebatchingQueue.html">RebatchingQueue</a> &gt;</td></tr>
<tr class="separator:a55da53004c68821d605bc203b85329d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cf33f52b2ac8ede56c7b9eade8714e"><td class="memTemplParams" colspan="2"><a id="a30cf33f52b2ac8ede56c7b9eade8714e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a30cf33f52b2ac8ede56c7b9eade8714e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EArrXt</b> = Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:a30cf33f52b2ac8ede56c7b9eade8714e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ca06381eb83d01882f3ddcf1ea9f85"><td class="memItemLeft" align="right" valign="top"><a id="a05ca06381eb83d01882f3ddcf1ea9f85"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EArrXf</b> = Eigen::ArrayXf</td></tr>
<tr class="separator:a05ca06381eb83d01882f3ddcf1ea9f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9efee42e9d5416a76af6cbf52fef267"><td class="memItemLeft" align="right" valign="top"><a id="aa9efee42e9d5416a76af6cbf52fef267"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EArrXd</b> = Eigen::ArrayXd</td></tr>
<tr class="separator:aa9efee42e9d5416a76af6cbf52fef267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bfd31737ed431da40d4c2d531fcab4"><td class="memItemLeft" align="right" valign="top"><a id="a57bfd31737ed431da40d4c2d531fcab4"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EArrXi</b> = Eigen::ArrayXi</td></tr>
<tr class="separator:a57bfd31737ed431da40d4c2d531fcab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423d78fd9e1ec22dc24119a52ffda491"><td class="memItemLeft" align="right" valign="top"><a id="a423d78fd9e1ec22dc24119a52ffda491"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EArrXb</b> = EArrXt&lt; bool &gt;</td></tr>
<tr class="separator:a423d78fd9e1ec22dc24119a52ffda491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9545a4bb09336e69fb899e5b26268f6"><td class="memTemplParams" colspan="2"><a id="ac9545a4bb09336e69fb899e5b26268f6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9545a4bb09336e69fb899e5b26268f6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EArrXXt</b> = Eigen::Array&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:ac9545a4bb09336e69fb899e5b26268f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0489b43c6cb59022a125b7d2f7f3b60"><td class="memItemLeft" align="right" valign="top"><a id="ae0489b43c6cb59022a125b7d2f7f3b60"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EArrXXf</b> = Eigen::ArrayXXf</td></tr>
<tr class="separator:ae0489b43c6cb59022a125b7d2f7f3b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668da8c72dfbee70c634752ddfc2cca2"><td class="memTemplParams" colspan="2"><a id="a668da8c72dfbee70c634752ddfc2cca2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a668da8c72dfbee70c634752ddfc2cca2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ERArrXXt</b> = Eigen::Array&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a668da8c72dfbee70c634752ddfc2cca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858fbd0105e125f947d8e0c7cc6fa2f5"><td class="memItemLeft" align="right" valign="top"><a id="a858fbd0105e125f947d8e0c7cc6fa2f5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ERArrXXf</b> = ERArrXXt&lt; float &gt;</td></tr>
<tr class="separator:a858fbd0105e125f947d8e0c7cc6fa2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac860d4911dfc0d4a14d04ab836a115ce"><td class="memTemplParams" colspan="2"><a id="ac860d4911dfc0d4a14d04ab836a115ce"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac860d4911dfc0d4a14d04ab836a115ce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EVecXt</b> = Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:ac860d4911dfc0d4a14d04ab836a115ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28be7f7774b322d8713c8cab499bb0f"><td class="memItemLeft" align="right" valign="top"><a id="af28be7f7774b322d8713c8cab499bb0f"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EVecXd</b> = Eigen::VectorXd</td></tr>
<tr class="separator:af28be7f7774b322d8713c8cab499bb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91be26e88343892f4a0f864167a8cb0"><td class="memItemLeft" align="right" valign="top"><a id="ac91be26e88343892f4a0f864167a8cb0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EVecXf</b> = Eigen::VectorXf</td></tr>
<tr class="separator:ac91be26e88343892f4a0f864167a8cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb33befb475f7d9486815061285e6d2"><td class="memItemLeft" align="right" valign="top"><a id="a7fb33befb475f7d9486815061285e6d2"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ERVecXd</b> = Eigen::RowVectorXd</td></tr>
<tr class="separator:a7fb33befb475f7d9486815061285e6d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2e9747ffe824ff7d21b13fdbac6fd6"><td class="memItemLeft" align="right" valign="top"><a id="a5b2e9747ffe824ff7d21b13fdbac6fd6"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ERVecXf</b> = Eigen::RowVectorXf</td></tr>
<tr class="separator:a5b2e9747ffe824ff7d21b13fdbac6fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ddc117686768238b132b3cb9928d30"><td class="memTemplParams" colspan="2"><a id="a03ddc117686768238b132b3cb9928d30"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a03ddc117686768238b132b3cb9928d30"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EMatXt</b> = Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a03ddc117686768238b132b3cb9928d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2568e3d8fe1b68cb6e98b9f14c7c26"><td class="memItemLeft" align="right" valign="top"><a id="a4b2568e3d8fe1b68cb6e98b9f14c7c26"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EMatXd</b> = Eigen::MatrixXd</td></tr>
<tr class="separator:a4b2568e3d8fe1b68cb6e98b9f14c7c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675336bbaa8dedbc5a26b534f90b41e8"><td class="memItemLeft" align="right" valign="top"><a id="a675336bbaa8dedbc5a26b534f90b41e8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>EMatXf</b> = Eigen::MatrixXf</td></tr>
<tr class="separator:a675336bbaa8dedbc5a26b534f90b41e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b24c4c79d9860bef56bcdfe2a9ee6a"><td class="memTemplParams" colspan="2"><a id="a22b24c4c79d9860bef56bcdfe2a9ee6a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22b24c4c79d9860bef56bcdfe2a9ee6a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ERMatXt</b> = Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic, Eigen::RowMajor &gt;</td></tr>
<tr class="separator:a22b24c4c79d9860bef56bcdfe2a9ee6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c0c7b7a26e639dd9be7d459a1bd529"><td class="memItemLeft" align="right" valign="top"><a id="a77c0c7b7a26e639dd9be7d459a1bd529"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ERMatXd</b> = ERMatXt&lt; double &gt;</td></tr>
<tr class="separator:a77c0c7b7a26e639dd9be7d459a1bd529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5545c2cf90bb5aa1136ddfdf1b755038"><td class="memItemLeft" align="right" valign="top"><a id="a5545c2cf90bb5aa1136ddfdf1b755038"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>ERMatXf</b> = ERMatXt&lt; float &gt;</td></tr>
<tr class="separator:a5545c2cf90bb5aa1136ddfdf1b755038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01f0e599fb011f4cd55ea0a7e1169e4"><td class="memTemplParams" colspan="2"><a id="aa01f0e599fb011f4cd55ea0a7e1169e4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa01f0e599fb011f4cd55ea0a7e1169e4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenMatrixMap</b> = Eigen::Map&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;</td></tr>
<tr class="separator:aa01f0e599fb011f4cd55ea0a7e1169e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70478f546b3044ecfcc2a2ab379153b2"><td class="memTemplParams" colspan="2"><a id="a70478f546b3044ecfcc2a2ab379153b2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70478f546b3044ecfcc2a2ab379153b2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenArrayMap</b> = Eigen::Map&lt; Eigen::Array&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;</td></tr>
<tr class="separator:a70478f546b3044ecfcc2a2ab379153b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8bb2d742f2156267399d8fea975888"><td class="memTemplParams" colspan="2"><a id="a7d8bb2d742f2156267399d8fea975888"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7d8bb2d742f2156267399d8fea975888"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenVectorMap</b> = Eigen::Map&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &gt;</td></tr>
<tr class="separator:a7d8bb2d742f2156267399d8fea975888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781edb0b02a5558c8baa2075b048c13a"><td class="memTemplParams" colspan="2"><a id="a781edb0b02a5558c8baa2075b048c13a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a781edb0b02a5558c8baa2075b048c13a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>EigenVectorArrayMap</b> = Eigen::Map&lt; Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &gt;</td></tr>
<tr class="separator:a781edb0b02a5558c8baa2075b048c13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04585a2e7965b83d474a987672b6445"><td class="memTemplParams" colspan="2"><a id="ae04585a2e7965b83d474a987672b6445"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae04585a2e7965b83d474a987672b6445"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstEigenMatrixMap</b> = Eigen::Map&lt; const Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;</td></tr>
<tr class="separator:ae04585a2e7965b83d474a987672b6445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062b1f5212067cc87214b2049548314e"><td class="memTemplParams" colspan="2"><a id="a062b1f5212067cc87214b2049548314e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a062b1f5212067cc87214b2049548314e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstEigenArrayMap</b> = Eigen::Map&lt; const Eigen::Array&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;</td></tr>
<tr class="separator:a062b1f5212067cc87214b2049548314e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78a9803232f8e9983dcd413b34e9675"><td class="memTemplParams" colspan="2"><a id="ac78a9803232f8e9983dcd413b34e9675"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac78a9803232f8e9983dcd413b34e9675"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstEigenVectorMap</b> = Eigen::Map&lt; const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &gt;</td></tr>
<tr class="separator:ac78a9803232f8e9983dcd413b34e9675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9463d86090bda53ec0ff21a03596332e"><td class="memTemplParams" colspan="2"><a id="a9463d86090bda53ec0ff21a03596332e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9463d86090bda53ec0ff21a03596332e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ConstEigenVectorArrayMap</b> = Eigen::Map&lt; const Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt; &gt;</td></tr>
<tr class="separator:a9463d86090bda53ec0ff21a03596332e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac973c115b0c808cb638fe0262823ec48"><td class="memItemLeft" align="right" valign="top"><a id="ac973c115b0c808cb638fe0262823ec48"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>CudaMemoryPoolType</b> { <b>NONE</b> = 0, 
<b>CUB</b> = 1
 }</td></tr>
<tr class="separator:ac973c115b0c808cb638fe0262823ec48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636c061e50a818d89fa07008067420ff"><td class="memItemLeft" align="right" valign="top"><a id="a636c061e50a818d89fa07008067420ff"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>EventStatus</b> { <b>EVENT_INITIALIZED</b> = 0, 
<b>EVENT_SCHEDULED</b> = 1, 
<b>EVENT_SUCCESS</b> = 2, 
<b>EVENT_FAILED</b> = 3
 }</td></tr>
<tr class="separator:a636c061e50a818d89fa07008067420ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25e17b4d7a08766797f73811bf8fd21"><td class="memItemLeft" align="right" valign="top"><a id="aa25e17b4d7a08766797f73811bf8fd21"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>StorageOrder</b> { <b>UNKNOWN</b> = 0, 
<b>NHWC</b> = 1, 
<b>NCHW</b> = 2
 }</td></tr>
<tr class="separator:aa25e17b4d7a08766797f73811bf8fd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18517bbe9b4899f83107e74f7a8e7544"><td class="memItemLeft" align="right" valign="top"><a id="a18517bbe9b4899f83107e74f7a8e7544"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PadMode</b> { <b>CONSTANT</b> = 0, 
<b>REFLECT</b> = 1, 
<b>EDGE</b> = 2
 }</td></tr>
<tr class="separator:a18517bbe9b4899f83107e74f7a8e7544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d3588b4cedfae0bc093b8c14038db4"><td class="memItemLeft" align="right" valign="top"><a id="ae6d3588b4cedfae0bc093b8c14038db4"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>QuantDecodeRunTy</b> { <b>RUN_ALWAYS</b>, 
<b>RUN_ONCE</b>
 }</td></tr>
<tr class="separator:ae6d3588b4cedfae0bc093b8c14038db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bf872d0c5886a30aa362374395abd4"><td class="memItemLeft" align="right" valign="top"><a id="a68bf872d0c5886a30aa362374395abd4"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>RecurrentParamOpMode</b> { <b>SET_PARAM</b>, 
<b>GET_PARAM</b>
 }</td></tr>
<tr class="separator:a68bf872d0c5886a30aa362374395abd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af665e0722cfd3ab685a8c41d47dc9d77"><td class="memItemLeft" align="right" valign="top"><a id="af665e0722cfd3ab685a8c41d47dc9d77"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SpecialFps</b> { <b>SAMPLE_NO_FRAME</b> = 0, 
<b>SAMPLE_ALL_FRAMES</b> = -1, 
<b>SAMPLE_TIMESTAMP_ONLY</b> = -2
 }</td></tr>
<tr class="separator:af665e0722cfd3ab685a8c41d47dc9d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a58b6a67aa6f46d1518d6752955ab92fe"><td class="memItemLeft" align="right" valign="top"><a id="a58b6a67aa6f46d1518d6752955ab92fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ConvertToRawDataset</b> (const string &amp;input_db_name, const string &amp;output_db_name)</td></tr>
<tr class="separator:a58b6a67aa6f46d1518d6752955ab92fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d283b84e27caae9f7e8160fa9dd0d91"><td class="memItemLeft" align="right" valign="top"><a id="a7d283b84e27caae9f7e8160fa9dd0d91"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ReadImage</b> (std::ifstream *file, int *label, char *buffer)</td></tr>
<tr class="separator:a7d283b84e27caae9f7e8160fa9dd0d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718615c5cb01902ac0d530fa190f6a29"><td class="memItemLeft" align="right" valign="top"><a id="a718615c5cb01902ac0d530fa190f6a29"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>WriteToDB</b> (const string &amp;filename, const int num_items, const int &amp;offset, <a class="el" href="classcaffe2_1_1db_1_1DB.html">db::DB</a> *db)</td></tr>
<tr class="separator:a718615c5cb01902ac0d530fa190f6a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57ad87163474085d886931920e539c0"><td class="memItemLeft" align="right" valign="top"><a id="af57ad87163474085d886931920e539c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ConvertCIFAR</b> ()</td></tr>
<tr class="separator:af57ad87163474085d886931920e539c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8458f4e5bd1f3f8147feb42fcba53338"><td class="memItemLeft" align="right" valign="top"><a id="a8458f4e5bd1f3f8147feb42fcba53338"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ConvertImageDataset</b> (const string &amp;input_folder, const string &amp;list_filename, const string &amp;output_db_name, const bool)</td></tr>
<tr class="separator:a8458f4e5bd1f3f8147feb42fcba53338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1098b342cfbdc5ed5ff70419d50b38bb"><td class="memItemLeft" align="right" valign="top"><a id="a1098b342cfbdc5ed5ff70419d50b38bb"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>swap_endian</b> (uint32_t val)</td></tr>
<tr class="separator:a1098b342cfbdc5ed5ff70419d50b38bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed294171c927c0538aff40a864baded9"><td class="memItemLeft" align="right" valign="top"><a id="aed294171c927c0538aff40a864baded9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>convert_dataset</b> (const char *image_filename, const char *label_filename, const char *db_path, const int data_limit)</td></tr>
<tr class="separator:aed294171c927c0538aff40a864baded9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4da950463d9578262d08f0909123b89d"><td class="memItemLeft" align="right" valign="top"><a id="a4da950463d9578262d08f0909123b89d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>run</b> ()</td></tr>
<tr class="separator:a4da950463d9578262d08f0909123b89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4acc031c77a7a52474ecebb27d4c12"><td class="memItemLeft" align="right" valign="top"><a id="a5d4acc031c77a7a52474ecebb27d4c12"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>NoDelete</b> (void *)</td></tr>
<tr class="separator:a5d4acc031c77a7a52474ecebb27d4c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e1860b04c0c9d04bd656d81153b88f"><td class="memItemLeft" align="right" valign="top"><a id="aa2e1860b04c0c9d04bd656d81153b88f"></a>
<a class="el" href="structcaffe2_1_1CPUAllocator.html">CPUAllocator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetCPUAllocator</b> ()</td></tr>
<tr class="separator:aa2e1860b04c0c9d04bd656d81153b88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2ecddad3e5d38fc82a87f24dd5612d"><td class="memItemLeft" align="right" valign="top"><a id="a0c2ecddad3e5d38fc82a87f24dd5612d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetCPUAllocator</b> (<a class="el" href="structcaffe2_1_1CPUAllocator.html">CPUAllocator</a> *alloc)</td></tr>
<tr class="separator:a0c2ecddad3e5d38fc82a87f24dd5612d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ba5ddb3cab35a4fef6962b772a704d"><td class="memItemLeft" align="right" valign="top"><a id="af5ba5ddb3cab35a4fef6962b772a704d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classcaffe2_1_1Blob.html">Blob</a> &amp;lhs, <a class="el" href="classcaffe2_1_1Blob.html">Blob</a> &amp;rhs)</td></tr>
<tr class="separator:af5ba5ddb3cab35a4fef6962b772a704d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4cd40abba15199fddb90a70b9721aa"><td class="memItemLeft" align="right" valign="top"><a id="a8d4cd40abba15199fddb90a70b9721aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_TYPED_REGISTRY</b> (BlobSerializerRegistry, CaffeTypeId, <a class="el" href="classcaffe2_1_1BlobSerializerBase.html">BlobSerializerBase</a>, std::unique_ptr)</td></tr>
<tr class="separator:a8d4cd40abba15199fddb90a70b9721aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7339c9cdaff1557f10b6e6e60dfd69"><td class="memItemLeft" align="right" valign="top"><a id="ade7339c9cdaff1557f10b6e6e60dfd69"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_REGISTRY</b> (BlobDeserializerRegistry, <a class="el" href="classcaffe2_1_1BlobDeserializerBase.html">BlobDeserializerBase</a>)</td></tr>
<tr class="separator:ade7339c9cdaff1557f10b6e6e60dfd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c55429ea913c64ad677f1dadc17dfe"><td class="memItemLeft" align="right" valign="top"><a id="a98c55429ea913c64ad677f1dadc17dfe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_TYPED_REGISTRY</b> (BlobSerializerRegistry, CaffeTypeId, <a class="el" href="classcaffe2_1_1BlobSerializerBase.html">BlobSerializerBase</a>, std::unique_ptr)</td></tr>
<tr class="separator:a98c55429ea913c64ad677f1dadc17dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad66001d7ab648f9e6a07ebb9e914e93"><td class="memItemLeft" align="right" valign="top"><a id="aad66001d7ab648f9e6a07ebb9e914e93"></a>
unique_ptr&lt; <a class="el" href="classcaffe2_1_1BlobSerializerBase.html">BlobSerializerBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateSerializer</b> (CaffeTypeId id)</td></tr>
<tr class="separator:aad66001d7ab648f9e6a07ebb9e914e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746ef482c7ec2bd96d0569cb55e8f74a"><td class="memItemLeft" align="right" valign="top"><a id="a746ef482c7ec2bd96d0569cb55e8f74a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_REGISTRY</b> (BlobDeserializerRegistry, <a class="el" href="classcaffe2_1_1BlobDeserializerBase.html">BlobDeserializerBase</a>)</td></tr>
<tr class="separator:a746ef482c7ec2bd96d0569cb55e8f74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab22598778f6a6b1817b0081f79a8195"><td class="memItemLeft" align="right" valign="top"><a id="aab22598778f6a6b1817b0081f79a8195"></a>
unique_ptr&lt; <a class="el" href="classcaffe2_1_1BlobDeserializerBase.html">BlobDeserializerBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateDeserializer</b> (const string &amp;type)</td></tr>
<tr class="separator:aab22598778f6a6b1817b0081f79a8195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198d55b1f81063933bfff4f66ff819e4"><td class="memItemLeft" align="right" valign="top"><a id="a198d55b1f81063933bfff4f66ff819e4"></a>
const std::map&lt; string, string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetBuildOptions</b> ()</td></tr>
<tr class="separator:a198d55b1f81063933bfff4f66ff819e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c698cef2cd00fa650e3fb4f7364b8e4"><td class="memTemplParams" colspan="2"><a id="a4c698cef2cd00fa650e3fb4f7364b8e4"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a4c698cef2cd00fa650e3fb4f7364b8e4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_array&lt; T &gt;::value, std::unique_ptr&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unique</b> (Args &amp;&amp;... args)</td></tr>
<tr class="separator:a4c698cef2cd00fa650e3fb4f7364b8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b77c9dbea4e60718a4f2cf2c7a6b06"><td class="memTemplParams" colspan="2"><a id="a34b77c9dbea4e60718a4f2cf2c7a6b06"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34b77c9dbea4e60718a4f2cf2c7a6b06"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_array&lt; T &gt;::value, std::unique_ptr&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unique</b> (const size_t n)</td></tr>
<tr class="separator:a34b77c9dbea4e60718a4f2cf2c7a6b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af206045e6c725a1a3819e9647fae85bc"><td class="memTemplParams" colspan="2"><a id="af206045e6c725a1a3819e9647fae85bc"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:af206045e6c725a1a3819e9647fae85bc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::extent&lt; T &gt;::value !=0, std::unique_ptr&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_unique</b> (Args &amp;&amp;...)=delete</td></tr>
<tr class="separator:af206045e6c725a1a3819e9647fae85bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc93877ba8e3cb6ad6f874582a22da80"><td class="memTemplParams" colspan="2"><a id="acc93877ba8e3cb6ad6f874582a22da80"></a>
template&lt;typename Dst , typename Src &gt; </td></tr>
<tr class="memitem:acc93877ba8e3cb6ad6f874582a22da80"><td class="memTemplItemLeft" align="right" valign="top">Dst&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dynamic_cast_if_rtti</b> (Src ptr)</td></tr>
<tr class="separator:acc93877ba8e3cb6ad6f874582a22da80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7615da9e915dc78d5bec46fd6be778e8"><td class="memItemLeft" align="right" valign="top"><a id="a7615da9e915dc78d5bec46fd6be778e8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasCudaRuntime</b> ()</td></tr>
<tr class="separator:a7615da9e915dc78d5bec46fd6be778e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4413739415b39b948f054531e05544e0"><td class="memItemLeft" align="right" valign="top"><a id="a4413739415b39b948f054531e05544e0"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>cudnnCompiledVersion</b> ()</td></tr>
<tr class="separator:a4413739415b39b948f054531e05544e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eea2b165a0f944edbd54cf85fe841b4"><td class="memItemLeft" align="right" valign="top"><a id="a0eea2b165a0f944edbd54cf85fe841b4"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>cudnnRuntimeVersion</b> ()</td></tr>
<tr class="separator:a0eea2b165a0f944edbd54cf85fe841b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd772f611b05663e9ea099d31e6bb53"><td class="memItemLeft" align="right" valign="top"><a id="adbd772f611b05663e9ea099d31e6bb53"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CheckCuDNNVersions</b> ()</td></tr>
<tr class="separator:adbd772f611b05663e9ea099d31e6bb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a6f5f6d9bed583a8e4db51d96c854b"><td class="memItemLeft" align="right" valign="top"><a id="a87a6f5f6d9bed583a8e4db51d96c854b"></a>
cudnnTensorFormat_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a87a6f5f6d9bed583a8e4db51d96c854b">GetCudnnTensorFormat</a> (const StorageOrder &amp;order)</td></tr>
<tr class="memdesc:a87a6f5f6d9bed583a8e4db51d96c854b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper function to convert the Caffe storage order to cudnn storage order enum values. <br /></td></tr>
<tr class="separator:a87a6f5f6d9bed583a8e4db51d96c854b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0dba0f4c170fc7d3c588d1e57b8329"><td class="memItemLeft" align="right" valign="top"><a id="a6d0dba0f4c170fc7d3c588d1e57b8329"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a6d0dba0f4c170fc7d3c588d1e57b8329">NumCudaDevices</a> ()</td></tr>
<tr class="memdesc:a6d0dba0f4c170fc7d3c588d1e57b8329"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of devices. <br /></td></tr>
<tr class="separator:a6d0dba0f4c170fc7d3c588d1e57b8329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad461eced97a6ba2c1959ba262f1a3a3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ad461eced97a6ba2c1959ba262f1a3a3c">SetDefaultGPUID</a> (const int deviceid)</td></tr>
<tr class="memdesc:ad461eced97a6ba2c1959ba262f1a3a3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default GPU id for Caffe2.  <a href="#ad461eced97a6ba2c1959ba262f1a3a3c">More...</a><br /></td></tr>
<tr class="separator:ad461eced97a6ba2c1959ba262f1a3a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7cd1e125dba2165f692bc0b681cf0a5"><td class="memItemLeft" align="right" valign="top"><a id="af7cd1e125dba2165f692bc0b681cf0a5"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#af7cd1e125dba2165f692bc0b681cf0a5">GetDefaultGPUID</a> ()</td></tr>
<tr class="memdesc:af7cd1e125dba2165f692bc0b681cf0a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the default GPU id for Caffe2. <br /></td></tr>
<tr class="separator:af7cd1e125dba2165f692bc0b681cf0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6850a4a5f4298a5c825238cfb0de688"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#af6850a4a5f4298a5c825238cfb0de688">CaffeCudaGetDevice</a> ()</td></tr>
<tr class="memdesc:af6850a4a5f4298a5c825238cfb0de688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current GPU id.  <a href="#af6850a4a5f4298a5c825238cfb0de688">More...</a><br /></td></tr>
<tr class="separator:af6850a4a5f4298a5c825238cfb0de688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff145698c872153a4e117f0e2101f09a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#aff145698c872153a4e117f0e2101f09a">CaffeCudaSetDevice</a> (const int id)</td></tr>
<tr class="memdesc:aff145698c872153a4e117f0e2101f09a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current GPU id.  <a href="#aff145698c872153a4e117f0e2101f09a">More...</a><br /></td></tr>
<tr class="separator:aff145698c872153a4e117f0e2101f09a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fded6ff24bcf074e5c78701ebe70f2"><td class="memItemLeft" align="right" valign="top"><a id="a47fded6ff24bcf074e5c78701ebe70f2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a47fded6ff24bcf074e5c78701ebe70f2">GetGPUIDForPointer</a> (const void *ptr)</td></tr>
<tr class="memdesc:a47fded6ff24bcf074e5c78701ebe70f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the GPU id that the current pointer is located at. <br /></td></tr>
<tr class="separator:a47fded6ff24bcf074e5c78701ebe70f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad461b286b4d2322c82a6f43fa00c8034"><td class="memItemLeft" align="right" valign="top">const cudaDeviceProp &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ad461b286b4d2322c82a6f43fa00c8034">GetDeviceProperty</a> (const int device)</td></tr>
<tr class="memdesc:ad461b286b4d2322c82a6f43fa00c8034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the device property for the given device.  <a href="#ad461b286b4d2322c82a6f43fa00c8034">More...</a><br /></td></tr>
<tr class="separator:ad461b286b4d2322c82a6f43fa00c8034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3575c7b3b60d12fd9323082093708d"><td class="memItemLeft" align="right" valign="top"><a id="adc3575c7b3b60d12fd9323082093708d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#adc3575c7b3b60d12fd9323082093708d">DeviceQuery</a> (const int deviceid)</td></tr>
<tr class="memdesc:adc3575c7b3b60d12fd9323082093708d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a device query function and prints out the results to LOG(INFO). <br /></td></tr>
<tr class="separator:adc3575c7b3b60d12fd9323082093708d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446da244aca2a8c6808963912cd5cdfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a446da244aca2a8c6808963912cd5cdfc">GetCudaPeerAccessPattern</a> (vector&lt; vector&lt; bool &gt; &gt; *pattern)</td></tr>
<tr class="memdesc:a446da244aca2a8c6808963912cd5cdfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a peer access pattern by returning a matrix (in the format of a nested vector) of boolean values specifying whether peer access is possible.  <a href="#a446da244aca2a8c6808963912cd5cdfc">More...</a><br /></td></tr>
<tr class="separator:a446da244aca2a8c6808963912cd5cdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9185fa7304a1a5553a05fee40830c43"><td class="memItemLeft" align="right" valign="top"><a id="ac9185fa7304a1a5553a05fee40830c43"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ac9185fa7304a1a5553a05fee40830c43">TensorCoreAvailable</a> ()</td></tr>
<tr class="memdesc:ac9185fa7304a1a5553a05fee40830c43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the availability of TensorCores for math. <br /></td></tr>
<tr class="separator:ac9185fa7304a1a5553a05fee40830c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab643532704982b9c6cd53fefb8c9015d"><td class="memItemLeft" align="right" valign="top"><a id="ab643532704982b9c6cd53fefb8c9015d"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ab643532704982b9c6cd53fefb8c9015d">cublasGetErrorString</a> (cublasStatus_t error)</td></tr>
<tr class="memdesc:ab643532704982b9c6cd53fefb8c9015d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a human readable cublas error string. <br /></td></tr>
<tr class="separator:ab643532704982b9c6cd53fefb8c9015d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd40a0417e6ec30c62f7fb8b49aa031"><td class="memItemLeft" align="right" valign="top"><a id="a8cd40a0417e6ec30c62f7fb8b49aa031"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a8cd40a0417e6ec30c62f7fb8b49aa031">curandGetErrorString</a> (curandStatus_t error)</td></tr>
<tr class="memdesc:a8cd40a0417e6ec30c62f7fb8b49aa031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a human readable curand error string. <br /></td></tr>
<tr class="separator:a8cd40a0417e6ec30c62f7fb8b49aa031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad503e334918c94362ff2758be80b0f56"><td class="memItemLeft" align="right" valign="top"><a id="ad503e334918c94362ff2758be80b0f56"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ad503e334918c94362ff2758be80b0f56">CudaVersion</a> ()</td></tr>
<tr class="memdesc:ad503e334918c94362ff2758be80b0f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">A runtime function to report the cuda version that Caffe2 is built with. <br /></td></tr>
<tr class="separator:ad503e334918c94362ff2758be80b0f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48638afbef9a25309bf7ef40a6e97919"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a48638afbef9a25309bf7ef40a6e97919">HasCudaGPU</a> ()</td></tr>
<tr class="memdesc:a48638afbef9a25309bf7ef40a6e97919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the current running session has a cuda gpu present.  <a href="#a48638afbef9a25309bf7ef40a6e97919">More...</a><br /></td></tr>
<tr class="separator:a48638afbef9a25309bf7ef40a6e97919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7bf47b9067ef9d15605a5d8746fddd"><td class="memItemLeft" align="right" valign="top"><a id="afa7bf47b9067ef9d15605a5d8746fddd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#afa7bf47b9067ef9d15605a5d8746fddd">CAFFE_GET_BLOCKS</a> (const int N)</td></tr>
<tr class="memdesc:afa7bf47b9067ef9d15605a5d8746fddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the number of blocks needed to run N threads. <br /></td></tr>
<tr class="separator:afa7bf47b9067ef9d15605a5d8746fddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c78e5303c2458a8799e4e9293b8d9ff"><td class="memItemLeft" align="right" valign="top"><a id="a6c78e5303c2458a8799e4e9293b8d9ff"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a6c78e5303c2458a8799e4e9293b8d9ff">RandomNumberSeed</a> ()</td></tr>
<tr class="memdesc:a6c78e5303c2458a8799e4e9293b8d9ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function to generate a random number seed that is unique in a best-effort basis, using an ever-incrementing seed and the current time. <br /></td></tr>
<tr class="separator:a6c78e5303c2458a8799e4e9293b8d9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37066071313fa865f8b2d22b900b3a3"><td class="memItemLeft" align="right" valign="top">CudaMemoryPoolType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ad37066071313fa865f8b2d22b900b3a3">GetCudaMemoryPoolType</a> ()</td></tr>
<tr class="memdesc:ad37066071313fa865f8b2d22b900b3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the current memory pool type used by Caffe2.  <a href="#ad37066071313fa865f8b2d22b900b3a3">More...</a><br /></td></tr>
<tr class="separator:ad37066071313fa865f8b2d22b900b3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bf17d6878d8180468f6127da0470a2"><td class="memItemLeft" align="right" valign="top"><a id="a19bf17d6878d8180468f6127da0470a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classcaffe2_1_1db_1_1DBReader.html">db::DBReader</a>)</td></tr>
<tr class="separator:a19bf17d6878d8180468f6127da0470a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9fe276cadd651f79cbaee58b726b6f"><td class="memItemLeft" align="right" valign="top"><a id="ade9fe276cadd651f79cbaee58b726b6f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classcaffe2_1_1db_1_1Cursor.html">db::Cursor</a>)</td></tr>
<tr class="separator:ade9fe276cadd651f79cbaee58b726b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4b1ea830ff2a0a9974aa19e3e03278"><td class="memItemLeft" align="right" valign="top"><a id="a9d4b1ea830ff2a0a9974aa19e3e03278"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventCreateCPU</b> (const DeviceOption &amp;option, <a class="el" href="classcaffe2_1_1Event.html">Event</a> *event)</td></tr>
<tr class="separator:a9d4b1ea830ff2a0a9974aa19e3e03278"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f7d1b36073478d998eb6cdcfc4fe4a"><td class="memItemLeft" align="right" valign="top"><a id="a75f7d1b36073478d998eb6cdcfc4fe4a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventRecordCPU</b> (<a class="el" href="classcaffe2_1_1Event.html">Event</a> *event, const void *, const char *err_msg)</td></tr>
<tr class="separator:a75f7d1b36073478d998eb6cdcfc4fe4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd03a6ca080d94dabbe360bd9758bb7"><td class="memItemLeft" align="right" valign="top"><a id="affd03a6ca080d94dabbe360bd9758bb7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventFinishCPU</b> (const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *event)</td></tr>
<tr class="separator:affd03a6ca080d94dabbe360bd9758bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c99f40be4b3bad6406d09e22e8186c5"><td class="memItemLeft" align="right" valign="top"><a id="a5c99f40be4b3bad6406d09e22e8186c5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventWaitCPUCPU</b> (const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *event, void *)</td></tr>
<tr class="separator:a5c99f40be4b3bad6406d09e22e8186c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eae3b94f5eb50129a2bae2d0062652d"><td class="memItemLeft" align="right" valign="top"><a id="a3eae3b94f5eb50129a2bae2d0062652d"></a>
EventStatus&#160;</td><td class="memItemRight" valign="bottom"><b>EventQueryCPU</b> (const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *event)</td></tr>
<tr class="separator:a3eae3b94f5eb50129a2bae2d0062652d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf052f727ddbc93e195ea78ed514fca2"><td class="memItemLeft" align="right" valign="top"><a id="acf052f727ddbc93e195ea78ed514fca2"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>EventErrorMessageCPU</b> (const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *event)</td></tr>
<tr class="separator:acf052f727ddbc93e195ea78ed514fca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0984479c946c8930de5f673a0f08b688"><td class="memItemLeft" align="right" valign="top"><a id="a0984479c946c8930de5f673a0f08b688"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventSetFinishedCPU</b> (const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *event, const char *err_msg)</td></tr>
<tr class="separator:a0984479c946c8930de5f673a0f08b688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b96d1579b04ccabf7b36290922ff49"><td class="memItemLeft" align="right" valign="top"><a id="a92b96d1579b04ccabf7b36290922ff49"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventResetCPU</b> (<a class="el" href="classcaffe2_1_1Event.html">Event</a> *event)</td></tr>
<tr class="separator:a92b96d1579b04ccabf7b36290922ff49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a5e31dbda40b6d4b59e79fa1f4a690"><td class="memItemLeft" align="right" valign="top"><a id="a00a5e31dbda40b6d4b59e79fa1f4a690"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_CREATE_FUNCTION</b> (CPU, EventCreateCPU)</td></tr>
<tr class="separator:a00a5e31dbda40b6d4b59e79fa1f4a690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dc4485f5e8424c1b31a81e3bd72942e"><td class="memItemLeft" align="right" valign="top"><a id="a6dc4485f5e8424c1b31a81e3bd72942e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_RECORD_FUNCTION</b> (CPU, EventRecordCPU)</td></tr>
<tr class="separator:a6dc4485f5e8424c1b31a81e3bd72942e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4981591aaa121f0fff77ec2053c7db1"><td class="memItemLeft" align="right" valign="top"><a id="ab4981591aaa121f0fff77ec2053c7db1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (CPU, CPU, EventWaitCPUCPU)</td></tr>
<tr class="separator:ab4981591aaa121f0fff77ec2053c7db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6346ec5ed3c38916277dc2924697cd97"><td class="memItemLeft" align="right" valign="top"><a id="a6346ec5ed3c38916277dc2924697cd97"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_FINISH_FUNCTION</b> (CPU, EventFinishCPU)</td></tr>
<tr class="separator:a6346ec5ed3c38916277dc2924697cd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2260c24ce5245586014356a3ef7fd7e4"><td class="memItemLeft" align="right" valign="top"><a id="a2260c24ce5245586014356a3ef7fd7e4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_QUERY_FUNCTION</b> (CPU, EventQueryCPU)</td></tr>
<tr class="separator:a2260c24ce5245586014356a3ef7fd7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac139290fdee69ebbe8e58a01bb13335c"><td class="memItemLeft" align="right" valign="top"><a id="ac139290fdee69ebbe8e58a01bb13335c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_ERROR_MESSAGE_FUNCTION</b> (CPU, EventErrorMessageCPU)</td></tr>
<tr class="separator:ac139290fdee69ebbe8e58a01bb13335c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae09e628a4b0f62bc690c400226f4e7ed"><td class="memItemLeft" align="right" valign="top"><a id="ae09e628a4b0f62bc690c400226f4e7ed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_SET_FINISHED_FUNCTION</b> (CPU, EventSetFinishedCPU)</td></tr>
<tr class="separator:ae09e628a4b0f62bc690c400226f4e7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3414fc5a843cacb019fddc19c8187f25"><td class="memItemLeft" align="right" valign="top"><a id="a3414fc5a843cacb019fddc19c8187f25"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_RESET_FUNCTION</b> (CPU, EventResetCPU)</td></tr>
<tr class="separator:a3414fc5a843cacb019fddc19c8187f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e593e92c534d0f613b2af800cf9884"><td class="memItemLeft" align="right" valign="top"><a id="af2e593e92c534d0f613b2af800cf9884"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>EventCanScheduleCPU</b> (const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *, const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *)</td></tr>
<tr class="separator:af2e593e92c534d0f613b2af800cf9884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de9b96755ed2723ceb0ff02f00fbc23"><td class="memItemLeft" align="right" valign="top"><a id="a3de9b96755ed2723ceb0ff02f00fbc23"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventCreateCUDA</b> (const DeviceOption &amp;option, <a class="el" href="classcaffe2_1_1Event.html">Event</a> *event)</td></tr>
<tr class="separator:a3de9b96755ed2723ceb0ff02f00fbc23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794d72658b8f476fba85fb48907a7adb"><td class="memItemLeft" align="right" valign="top"><a id="a794d72658b8f476fba85fb48907a7adb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventRecordCUDA</b> (<a class="el" href="classcaffe2_1_1Event.html">Event</a> *event, const void *context, const char *err_msg)</td></tr>
<tr class="separator:a794d72658b8f476fba85fb48907a7adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fd1eefd56e92d17a96827f412c8b97"><td class="memItemLeft" align="right" valign="top"><a id="a69fd1eefd56e92d17a96827f412c8b97"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventFinishCUDA</b> (const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *event)</td></tr>
<tr class="separator:a69fd1eefd56e92d17a96827f412c8b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7285207a6b79ac4af4472864e576eca8"><td class="memItemLeft" align="right" valign="top"><a id="a7285207a6b79ac4af4472864e576eca8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventWaitCUDACUDA</b> (const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *event, void *context)</td></tr>
<tr class="separator:a7285207a6b79ac4af4472864e576eca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3dca82a96fb8e14eb7583b939d8833"><td class="memItemLeft" align="right" valign="top"><a id="a5b3dca82a96fb8e14eb7583b939d8833"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventWaitCPUCUDA</b> (const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *event, void *context)</td></tr>
<tr class="separator:a5b3dca82a96fb8e14eb7583b939d8833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d45b996821cb7a03ab14362677c4901"><td class="memItemLeft" align="right" valign="top"><a id="a5d45b996821cb7a03ab14362677c4901"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventWaitCUDACPU</b> (const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *event, void *context)</td></tr>
<tr class="separator:a5d45b996821cb7a03ab14362677c4901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8672bcd27a7661125fb9431a1ddf5e44"><td class="memItemLeft" align="right" valign="top"><a id="a8672bcd27a7661125fb9431a1ddf5e44"></a>
EventStatus&#160;</td><td class="memItemRight" valign="bottom"><b>EventQueryCUDA</b> (const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *event)</td></tr>
<tr class="separator:a8672bcd27a7661125fb9431a1ddf5e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72aee3b598a5be153cd54ff7b0a6c2e"><td class="memItemLeft" align="right" valign="top"><a id="ae72aee3b598a5be153cd54ff7b0a6c2e"></a>
const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>EventErrorMessageCUDA</b> (const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *event)</td></tr>
<tr class="separator:ae72aee3b598a5be153cd54ff7b0a6c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f0efdbd1ae450464c4ab064a5a96a0"><td class="memItemLeft" align="right" valign="top"><a id="ad6f0efdbd1ae450464c4ab064a5a96a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventSetFinishedCUDA</b> (const <a class="el" href="classcaffe2_1_1Event.html">Event</a> *event, const char *err_msg)</td></tr>
<tr class="separator:ad6f0efdbd1ae450464c4ab064a5a96a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f0679eb8b591c7cdaa9dca7fd22623"><td class="memItemLeft" align="right" valign="top"><a id="a24f0679eb8b591c7cdaa9dca7fd22623"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EventResetCUDA</b> (<a class="el" href="classcaffe2_1_1Event.html">Event</a> *event)</td></tr>
<tr class="separator:a24f0679eb8b591c7cdaa9dca7fd22623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29709ed5cbb863dcef6dc6f0f9a431c"><td class="memItemLeft" align="right" valign="top"><a id="ab29709ed5cbb863dcef6dc6f0f9a431c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_CREATE_FUNCTION</b> (CUDA, EventCreateCUDA)</td></tr>
<tr class="separator:ab29709ed5cbb863dcef6dc6f0f9a431c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff021463f822f8104037da552a9da48c"><td class="memItemLeft" align="right" valign="top"><a id="aff021463f822f8104037da552a9da48c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_RECORD_FUNCTION</b> (CUDA, EventRecordCUDA)</td></tr>
<tr class="separator:aff021463f822f8104037da552a9da48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9838e883f710f448e898c734b08ce625"><td class="memItemLeft" align="right" valign="top"><a id="a9838e883f710f448e898c734b08ce625"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (CUDA, CUDA, EventWaitCUDACUDA)</td></tr>
<tr class="separator:a9838e883f710f448e898c734b08ce625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31748deb693ec49b1cd132be1805154b"><td class="memItemLeft" align="right" valign="top"><a id="a31748deb693ec49b1cd132be1805154b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (CPU, CUDA, EventWaitCPUCUDA)</td></tr>
<tr class="separator:a31748deb693ec49b1cd132be1805154b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfeeb42807c3d26a7acbf45b9b3bd429"><td class="memItemLeft" align="right" valign="top"><a id="abfeeb42807c3d26a7acbf45b9b3bd429"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (CUDA, CPU, EventWaitCUDACPU)</td></tr>
<tr class="separator:abfeeb42807c3d26a7acbf45b9b3bd429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eac45930baf700f459675b6168bc06f"><td class="memItemLeft" align="right" valign="top"><a id="a1eac45930baf700f459675b6168bc06f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_FINISH_FUNCTION</b> (CUDA, EventFinishCUDA)</td></tr>
<tr class="separator:a1eac45930baf700f459675b6168bc06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb5d1cbe96083f03045fd24c70315fe8"><td class="memItemLeft" align="right" valign="top"><a id="acb5d1cbe96083f03045fd24c70315fe8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_QUERY_FUNCTION</b> (CUDA, EventQueryCUDA)</td></tr>
<tr class="separator:acb5d1cbe96083f03045fd24c70315fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601ead593addd6ab87afa33b4f4f07da"><td class="memItemLeft" align="right" valign="top"><a id="a601ead593addd6ab87afa33b4f4f07da"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_ERROR_MESSAGE_FUNCTION</b> (CUDA, EventErrorMessageCUDA)</td></tr>
<tr class="separator:a601ead593addd6ab87afa33b4f4f07da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af740e501891c7ea922b6749a34ee3786"><td class="memItemLeft" align="right" valign="top"><a id="af740e501891c7ea922b6749a34ee3786"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_SET_FINISHED_FUNCTION</b> (CUDA, EventSetFinishedCUDA)</td></tr>
<tr class="separator:af740e501891c7ea922b6749a34ee3786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ffea44cea509815a7d0f847fc19249"><td class="memItemLeft" align="right" valign="top"><a id="a17ffea44cea509815a7d0f847fc19249"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_RESET_FUNCTION</b> (CUDA, EventResetCUDA)</td></tr>
<tr class="separator:a17ffea44cea509815a7d0f847fc19249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb30314b2436a9057a0e3f2d879e7a0"><td class="memItemLeft" align="right" valign="top"><a id="a7eb30314b2436a9057a0e3f2d879e7a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (MKLDNN, CUDA, EventWaitCPUCUDA)</td></tr>
<tr class="separator:a7eb30314b2436a9057a0e3f2d879e7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bf69c6112545964ab825636acdea35"><td class="memItemLeft" align="right" valign="top"><a id="a07bf69c6112545964ab825636acdea35"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (CUDA, MKLDNN, EventWaitCUDACPU)</td></tr>
<tr class="separator:a07bf69c6112545964ab825636acdea35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c918914ad19dfdc4de9104e1d857ce3"><td class="memItemLeft" align="right" valign="top"><a id="a8c918914ad19dfdc4de9104e1d857ce3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_REGISTRY</b> (Caffe2FlagsRegistry, <a class="el" href="classcaffe2_1_1Caffe2FlagParser.html">Caffe2FlagParser</a>, const string &amp;)</td></tr>
<tr class="separator:a8c918914ad19dfdc4de9104e1d857ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7137b079a7505ca39c44d7441c3296"><td class="memItemLeft" align="right" valign="top"><a id="ace7137b079a7505ca39c44d7441c3296"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ace7137b079a7505ca39c44d7441c3296">SetUsageMessage</a> (const string &amp;str)</td></tr>
<tr class="memdesc:ace7137b079a7505ca39c44d7441c3296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the usage message when a commandline tool is called with "--help". <br /></td></tr>
<tr class="separator:ace7137b079a7505ca39c44d7441c3296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df9421b2b851cffabdd3fa2bd728c9f"><td class="memItemLeft" align="right" valign="top"><a id="a5df9421b2b851cffabdd3fa2bd728c9f"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a5df9421b2b851cffabdd3fa2bd728c9f">UsageMessage</a> ()</td></tr>
<tr class="memdesc:a5df9421b2b851cffabdd3fa2bd728c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the usage message for the commandline tool set by SetUsageMessage. <br /></td></tr>
<tr class="separator:a5df9421b2b851cffabdd3fa2bd728c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658a8d4d5b33a86502f0fbc5d2b82541"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a658a8d4d5b33a86502f0fbc5d2b82541">ParseCaffeCommandLineFlags</a> (int *pargc, char ***pargv)</td></tr>
<tr class="memdesc:a658a8d4d5b33a86502f0fbc5d2b82541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the commandline flags.  <a href="#a658a8d4d5b33a86502f0fbc5d2b82541">More...</a><br /></td></tr>
<tr class="separator:a658a8d4d5b33a86502f0fbc5d2b82541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b58d2c0360268ab3b52443589b80e9c"><td class="memItemLeft" align="right" valign="top"><a id="a3b58d2c0360268ab3b52443589b80e9c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a3b58d2c0360268ab3b52443589b80e9c">CommandLineFlagsHasBeenParsed</a> ()</td></tr>
<tr class="memdesc:a3b58d2c0360268ab3b52443589b80e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the commandline flags has already been passed. <br /></td></tr>
<tr class="separator:a3b58d2c0360268ab3b52443589b80e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4d573fad756ed21b40fe73fd2eadbd"><td class="memItemLeft" align="right" valign="top"><a id="a5b4d573fad756ed21b40fe73fd2eadbd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_REGISTRY</b> (Caffe2FlagsRegistry, <a class="el" href="classcaffe2_1_1Caffe2FlagParser.html">Caffe2FlagParser</a>, const string &amp;)</td></tr>
<tr class="separator:a5b4d573fad756ed21b40fe73fd2eadbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3161731ce245f3b733e2e1fd555a5326"><td class="memItemLeft" align="right" valign="top"><a id="a3161731ce245f3b733e2e1fd555a5326"></a>
OperatorDef *&#160;</td><td class="memItemRight" valign="bottom"><b>AddOp</b> (NetDef *netdef_ptr, string op_type, std::vector&lt; string &gt; inputs, std::vector&lt; string &gt; outputs)</td></tr>
<tr class="separator:a3161731ce245f3b733e2e1fd555a5326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b7e581ccd292b6b16296966cfbd7ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ae0b7e581ccd292b6b16296966cfbd7ff">MatchStrings</a> (string p, string s)</td></tr>
<tr class="memdesc:ae0b7e581ccd292b6b16296966cfbd7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">This allows for the use of * and | to match operator types, engines, or any other property that is represented by strings.  <a href="#ae0b7e581ccd292b6b16296966cfbd7ff">More...</a><br /></td></tr>
<tr class="separator:ae0b7e581ccd292b6b16296966cfbd7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b9693edd3666311a6d33e4418d7303"><td class="memItemLeft" align="right" valign="top"><a id="a31b9693edd3666311a6d33e4418d7303"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a31b9693edd3666311a6d33e4418d7303">MatchArguments</a> (const OperatorDef &amp;p_op, const OperatorDef &amp;g_op)</td></tr>
<tr class="memdesc:a31b9693edd3666311a6d33e4418d7303"><td class="mdescLeft">&#160;</td><td class="mdescRight">This ensures that each named arg that exists in the pattern exists in g_op, is equal in value. <br /></td></tr>
<tr class="separator:a31b9693edd3666311a6d33e4418d7303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70b04a01a1779ddd61f9ef1e0a141b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#af70b04a01a1779ddd61f9ef1e0a141b7">GlobalInit</a> (int *pargc, char ***argv)</td></tr>
<tr class="memdesc:af70b04a01a1779ddd61f9ef1e0a141b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the global environment of <a class="el" href="namespacecaffe2.html" title="Copyright (c) 2016-present, Facebook, Inc. ">caffe2</a>.  <a href="#af70b04a01a1779ddd61f9ef1e0a141b7">More...</a><br /></td></tr>
<tr class="separator:af70b04a01a1779ddd61f9ef1e0a141b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30ff68cebc0cbd475fc10144dcc3d56"><td class="memItemLeft" align="right" valign="top"><a id="ab30ff68cebc0cbd475fc10144dcc3d56"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>StripBasename</b> (const std::string &amp;full_path)</td></tr>
<tr class="separator:ab30ff68cebc0cbd475fc10144dcc3d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0125f70cf6a3e4b808a2dc917d117d18"><td class="memItemLeft" align="right" valign="top"><a id="a0125f70cf6a3e4b808a2dc917d117d18"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>ReplaceAll</b> (string &amp;s, const char *from, const char *to)</td></tr>
<tr class="separator:a0125f70cf6a3e4b808a2dc917d117d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51eae6c817ddb0658764ae96a87abcb"><td class="memItemLeft" align="right" valign="top"><a id="aa51eae6c817ddb0658764ae96a87abcb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetStackTraceFetcher</b> (std::function&lt; string(void)&gt; fetcher)</td></tr>
<tr class="separator:aa51eae6c817ddb0658764ae96a87abcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f5cade048cd641b438e217c5ffd53c"><td class="memItemLeft" align="right" valign="top"><a id="a55f5cade048cd641b438e217c5ffd53c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetOperatorLogger</b> (std::function&lt; void(const OperatorDef &amp;)&gt; tracer)</td></tr>
<tr class="separator:a55f5cade048cd641b438e217c5ffd53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0689f1461c549e57d526c5ee85345262"><td class="memItemLeft" align="right" valign="top"><a id="a0689f1461c549e57d526c5ee85345262"></a>
std::function&lt; void(const OperatorDef &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetOperatorLogger</b> ()</td></tr>
<tr class="separator:a0689f1461c549e57d526c5ee85345262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad579e08bebd7b6f0460c6f21b17b23cb"><td class="memItemLeft" align="right" valign="top"><a id="ad579e08bebd7b6f0460c6f21b17b23cb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>InitCaffeLogging</b> (int *argc, char **argv)</td></tr>
<tr class="separator:ad579e08bebd7b6f0460c6f21b17b23cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3123faf5c57e6b67b0d01cd2daa05bf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a3123faf5c57e6b67b0d01cd2daa05bf1">ShowLogInfoToStderr</a> ()</td></tr>
<tr class="memdesc:a3123faf5c57e6b67b0d01cd2daa05bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility to allow one to show log info to stderr after the program starts.  <a href="#a3123faf5c57e6b67b0d01cd2daa05bf1">More...</a><br /></td></tr>
<tr class="separator:a3123faf5c57e6b67b0d01cd2daa05bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6532f6f77ac87359a65bcba171dc2850"><td class="memItemLeft" align="right" valign="top"><a id="a6532f6f77ac87359a65bcba171dc2850"></a>
constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsUsingGoogleLogging</b> ()</td></tr>
<tr class="separator:a6532f6f77ac87359a65bcba171dc2850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3ace8110cf57450540aee9097f037b"><td class="memItemLeft" align="right" valign="top"><a id="aaf3ace8110cf57450540aee9097f037b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MakeStringInternal</b> (std::stringstream &amp;)</td></tr>
<tr class="separator:aaf3ace8110cf57450540aee9097f037b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc0a52fb0742a9008866bb4530534c2"><td class="memTemplParams" colspan="2"><a id="acfc0a52fb0742a9008866bb4530534c2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acfc0a52fb0742a9008866bb4530534c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeStringInternal</b> (std::stringstream &amp;ss, const T &amp;t)</td></tr>
<tr class="separator:acfc0a52fb0742a9008866bb4530534c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb1778d460798c51d384b9550b64096"><td class="memTemplParams" colspan="2"><a id="acbb1778d460798c51d384b9550b64096"></a>
template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:acbb1778d460798c51d384b9550b64096"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeStringInternal</b> (std::stringstream &amp;ss, const T &amp;t, const Args &amp;... args)</td></tr>
<tr class="separator:acbb1778d460798c51d384b9550b64096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2e0aadd0a1c32faa944665a4a23e0c"><td class="memTemplParams" colspan="2"><a id="a8a2e0aadd0a1c32faa944665a4a23e0c"></a>
template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a8a2e0aadd0a1c32faa944665a4a23e0c"><td class="memTemplItemLeft" align="right" valign="top">string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeString</b> (const Args &amp;... args)</td></tr>
<tr class="separator:a8a2e0aadd0a1c32faa944665a4a23e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b98316c6bc179f2e613d013687ad8b"><td class="memTemplParams" colspan="2"><a id="a19b98316c6bc179f2e613d013687ad8b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a19b98316c6bc179f2e613d013687ad8b"><td class="memTemplItemLeft" align="right" valign="top">string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeString</b> (const string &amp;str)</td></tr>
<tr class="separator:a19b98316c6bc179f2e613d013687ad8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d804ca3a4903efe2d9dd279db8fb5cb"><td class="memItemLeft" align="right" valign="top"><a id="a6d804ca3a4903efe2d9dd279db8fb5cb"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>MakeString</b> (const char *c_str)</td></tr>
<tr class="separator:a6d804ca3a4903efe2d9dd279db8fb5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bc19c4fdfa9421b6ddc53e69c2ed31"><td class="memTemplParams" colspan="2"><a id="a96bc19c4fdfa9421b6ddc53e69c2ed31"></a>
template&lt;class Container &gt; </td></tr>
<tr class="memitem:a96bc19c4fdfa9421b6ddc53e69c2ed31"><td class="memTemplItemLeft" align="right" valign="top">string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Join</b> (const string &amp;delimiter, const Container &amp;v)</td></tr>
<tr class="separator:a96bc19c4fdfa9421b6ddc53e69c2ed31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e169f501e34306201fc481d47e1f904"><td class="memTemplParams" colspan="2"><a id="a6e169f501e34306201fc481d47e1f904"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a6e169f501e34306201fc481d47e1f904"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>LogMessageFatal</b> (const char *file, int line, const T &amp;message)</td></tr>
<tr class="separator:a6e169f501e34306201fc481d47e1f904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fbbe4713ad513f94b1389d4382e6b2"><td class="memTemplParams" colspan="2"><a id="ac2fbbe4713ad513f94b1389d4382e6b2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2fbbe4713ad513f94b1389d4382e6b2"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CheckNotNullCommon</b> (const char *file, int line, const char *names, T &amp;t)</td></tr>
<tr class="separator:ac2fbbe4713ad513f94b1389d4382e6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae139da428aa4dd23516a0529815b9df8"><td class="memTemplParams" colspan="2"><a id="ae139da428aa4dd23516a0529815b9df8"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae139da428aa4dd23516a0529815b9df8"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CheckNotNull</b> (const char *file, int line, const char *names, T *t)</td></tr>
<tr class="separator:ae139da428aa4dd23516a0529815b9df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b78bd9f94be2e50aae5c959e7277a20"><td class="memTemplParams" colspan="2"><a id="a4b78bd9f94be2e50aae5c959e7277a20"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b78bd9f94be2e50aae5c959e7277a20"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CheckNotNull</b> (const char *file, int line, const char *names, T &amp;t)</td></tr>
<tr class="separator:a4b78bd9f94be2e50aae5c959e7277a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc23f310480e7d6e08c93e09e138708"><td class="memTemplParams" colspan="2"><a id="a7dc23f310480e7d6e08c93e09e138708"></a>
template&lt;class First , class Second &gt; </td></tr>
<tr class="memitem:a7dc23f310480e7d6e08c93e09e138708"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const std::pair&lt; First, Second &gt; &amp;p)</td></tr>
<tr class="separator:a7dc23f310480e7d6e08c93e09e138708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e41e92838629e3ec5f859ccfcd3f13"><td class="memTemplParams" colspan="2"><a id="a05e41e92838629e3ec5f859ccfcd3f13"></a>
template&lt;class Iter &gt; </td></tr>
<tr class="memitem:a05e41e92838629e3ec5f859ccfcd3f13"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PrintSequence</b> (std::ostream &amp;ss, Iter begin, Iter end)</td></tr>
<tr class="separator:a05e41e92838629e3ec5f859ccfcd3f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2015a66b1fe9fccf95985a1b9de6d31c"><td class="memItemLeft" align="right" valign="top">const CaffeMap&lt; string, const <a class="el" href="classcaffe2_1_1ModuleSchema.html">ModuleSchema</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a2015a66b1fe9fccf95985a1b9de6d31c">CurrentModules</a> ()</td></tr>
<tr class="memdesc:a2015a66b1fe9fccf95985a1b9de6d31c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current Modules present in the Caffe2 runtime.  <a href="#a2015a66b1fe9fccf95985a1b9de6d31c">More...</a><br /></td></tr>
<tr class="separator:a2015a66b1fe9fccf95985a1b9de6d31c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af176563dd119f7e7ee812ec70f4bf3"><td class="memItemLeft" align="right" valign="top"><a id="a8af176563dd119f7e7ee812ec70f4bf3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a8af176563dd119f7e7ee812ec70f4bf3">HasModule</a> (const string &amp;name)</td></tr>
<tr class="memdesc:a8af176563dd119f7e7ee812ec70f4bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a module is already present in the current binary. <br /></td></tr>
<tr class="separator:a8af176563dd119f7e7ee812ec70f4bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f3bdc17d263b9070079af7c9248b97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ad9f3bdc17d263b9070079af7c9248b97">LoadModule</a> (const string &amp;name, const string &amp;filename=&quot;&quot;)</td></tr>
<tr class="memdesc:ad9f3bdc17d263b9070079af7c9248b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a module.  <a href="#ad9f3bdc17d263b9070079af7c9248b97">More...</a><br /></td></tr>
<tr class="separator:ad9f3bdc17d263b9070079af7c9248b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751c59304364bbaa259c9b30b3294da8"><td class="memItemLeft" align="right" valign="top"><a id="a751c59304364bbaa259c9b30b3294da8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_REGISTRY</b> (NetRegistry, <a class="el" href="classcaffe2_1_1NetBase.html">NetBase</a>, const std::shared_ptr&lt; const NetDef &gt; &amp;, <a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *)</td></tr>
<tr class="separator:a751c59304364bbaa259c9b30b3294da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697f38e38b51fbbda15ef83ab230e4c3"><td class="memItemLeft" align="right" valign="top"><a id="a697f38e38b51fbbda15ef83ab230e4c3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetGlobalNetObserverCreator</b> (NetObserverCreator creator)</td></tr>
<tr class="separator:a697f38e38b51fbbda15ef83ab230e4c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9463003c6ef9000d089ffeaf9296c05"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; <a class="el" href="classcaffe2_1_1NetBase.html">NetBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#aa9463003c6ef9000d089ffeaf9296c05">CreateNet</a> (const NetDef &amp;net_def, <a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *ws)</td></tr>
<tr class="memdesc:aa9463003c6ef9000d089ffeaf9296c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a network, accessing / creating blobs in the given workspace.  <a href="#aa9463003c6ef9000d089ffeaf9296c05">More...</a><br /></td></tr>
<tr class="separator:aa9463003c6ef9000d089ffeaf9296c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bfc9582bb7aa109644e735171daae2"><td class="memItemLeft" align="right" valign="top"><a id="a59bfc9582bb7aa109644e735171daae2"></a>
unique_ptr&lt; <a class="el" href="classcaffe2_1_1NetBase.html">NetBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateNet</b> (const std::shared_ptr&lt; const NetDef &gt; &amp;net_def, <a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *ws)</td></tr>
<tr class="separator:a59bfc9582bb7aa109644e735171daae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d89a2290430e2cb676ad99b0e80b44a"><td class="memItemLeft" align="right" valign="top"><a id="a9d89a2290430e2cb676ad99b0e80b44a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_REGISTRY</b> (NetRegistry, <a class="el" href="classcaffe2_1_1NetBase.html">NetBase</a>, const std::shared_ptr&lt; const NetDef &gt; &amp;, <a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *)</td></tr>
<tr class="separator:a9d89a2290430e2cb676ad99b0e80b44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc4bc640e2b7153cc1df6deb8a67271"><td class="memItemLeft" align="right" valign="top"><a id="afcc4bc640e2b7153cc1df6deb8a67271"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_SHARED_REGISTRY</b> (ThreadPoolRegistry, <a class="el" href="classcaffe2_1_1TaskThreadPool.html">TaskThreadPool</a>, const DeviceOption &amp;)</td></tr>
<tr class="separator:afcc4bc640e2b7153cc1df6deb8a67271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525018a21de8af6d36e5ca1f9a50b71e"><td class="memItemLeft" align="right" valign="top"><a id="a525018a21de8af6d36e5ca1f9a50b71e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_REGISTER_CREATOR</b> (ThreadPoolRegistry, CPU, AsyncNetCPUThreadPoolCreator)</td></tr>
<tr class="separator:a525018a21de8af6d36e5ca1f9a50b71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0492aa3379333362248027ee03e6b3f"><td class="memItemLeft" align="right" valign="top"><a id="af0492aa3379333362248027ee03e6b3f"></a>
std::shared_ptr&lt; <a class="el" href="classcaffe2_1_1TaskThreadPool.html">TaskThreadPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetAsyncNetCPUThreadPool</b> ()</td></tr>
<tr class="separator:af0492aa3379333362248027ee03e6b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1768f50803e433c71e4f974d176fcb75"><td class="memItemLeft" align="right" valign="top"><a id="a1768f50803e433c71e4f974d176fcb75"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_SHARED_REGISTRY</b> (ThreadPoolRegistry, <a class="el" href="classcaffe2_1_1TaskThreadPool.html">TaskThreadPool</a>, const DeviceOption &amp;)</td></tr>
<tr class="separator:a1768f50803e433c71e4f974d176fcb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6f954d1c88be22fb0fab68dfe8441cc"><td class="memItemLeft" align="right" valign="top"><a id="ab6f954d1c88be22fb0fab68dfe8441cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_NET</b> (async_dag, <a class="el" href="classcaffe2_1_1AsyncDAGNet.html">AsyncDAGNet</a>)</td></tr>
<tr class="separator:ab6f954d1c88be22fb0fab68dfe8441cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e014e91c62ad94bd3cacaac10c63c69"><td class="memItemLeft" align="right" valign="top"><a id="a6e014e91c62ad94bd3cacaac10c63c69"></a>
std::shared_ptr&lt; <a class="el" href="classcaffe2_1_1TaskThreadPool.html">TaskThreadPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetAsyncNetGPUThreadPool</b> (int gpu_id)</td></tr>
<tr class="separator:a6e014e91c62ad94bd3cacaac10c63c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5cbd1540ea3d2c44e31470fe25551f"><td class="memItemLeft" align="right" valign="top"><a id="aac5cbd1540ea3d2c44e31470fe25551f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_REGISTER_CREATOR</b> (ThreadPoolRegistry, CUDA, AsyncNetGPUThreadPoolCreator)</td></tr>
<tr class="separator:aac5cbd1540ea3d2c44e31470fe25551f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3c236f566e2186c6096a009c72400b"><td class="memItemLeft" align="right" valign="top"><a id="adc3c236f566e2186c6096a009c72400b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_NET</b> (async_polling, <a class="el" href="classcaffe2_1_1AsyncPollingNet.html">AsyncPollingNet</a>)</td></tr>
<tr class="separator:adc3c236f566e2186c6096a009c72400b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6bd426853583761f4055254769f34f"><td class="memItemLeft" align="right" valign="top"><a id="a9f6bd426853583761f4055254769f34f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_NET</b> (async_scheduling, <a class="el" href="classcaffe2_1_1AsyncSchedulingNet.html">AsyncSchedulingNet</a>)</td></tr>
<tr class="separator:a9f6bd426853583761f4055254769f34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd90465ba94ce04ce171dd6d74e610e"><td class="memItemLeft" align="right" valign="top"><a id="afdd90465ba94ce04ce171dd6d74e610e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_NET</b> (dag, <a class="el" href="classcaffe2_1_1DAGNet.html">DAGNet</a>)</td></tr>
<tr class="separator:afdd90465ba94ce04ce171dd6d74e610e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fb93ef2d3c7b8c671bb07f042d6be9"><td class="memItemLeft" align="right" valign="top"><a id="ad3fb93ef2d3c7b8c671bb07f042d6be9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_NET</b> (simple, <a class="el" href="classcaffe2_1_1SimpleNet.html">SimpleNet</a>)</td></tr>
<tr class="separator:ad3fb93ef2d3c7b8c671bb07f042d6be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5898a33286d03553bcc1b2076a35998"><td class="memItemLeft" align="right" valign="top"><a id="ab5898a33286d03553bcc1b2076a35998"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_NET</b> (async_simple, <a class="el" href="classcaffe2_1_1AsyncSimpleNet.html">AsyncSimpleNet</a>)</td></tr>
<tr class="separator:ab5898a33286d03553bcc1b2076a35998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58edd0227c0c3e3d7dbe86941a1ef5a2"><td class="memItemLeft" align="right" valign="top"><a id="a58edd0227c0c3e3d7dbe86941a1ef5a2"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>OpRegistryKey</b> (const std::string &amp;op_type, const std::string &amp;engine)</td></tr>
<tr class="separator:a58edd0227c0c3e3d7dbe86941a1ef5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addddd73e617c2d8838a9bb0e962d36d7"><td class="memItemLeft" align="right" valign="top"><a id="addddd73e617c2d8838a9bb0e962d36d7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetPerOpEnginePref</b> (const PerOpEnginePrefType &amp;per_op_engine_pref)</td></tr>
<tr class="separator:addddd73e617c2d8838a9bb0e962d36d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c401de140947a3313cf157382ad53b7"><td class="memItemLeft" align="right" valign="top"><a id="a6c401de140947a3313cf157382ad53b7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetGlobalEnginePref</b> (const GlobalEnginePrefType &amp;global_engine_pref)</td></tr>
<tr class="separator:a6c401de140947a3313cf157382ad53b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb970ff1429fa32f114459ffbd5a20dd"><td class="memItemLeft" align="right" valign="top"><a id="aeb970ff1429fa32f114459ffbd5a20dd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetEnginePref</b> (const PerOpEnginePrefType &amp;per_op_engine_pref, const GlobalEnginePrefType &amp;global_engine_pref)</td></tr>
<tr class="separator:aeb970ff1429fa32f114459ffbd5a20dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94ee55b0cdd0af9c161f467f1bd8888"><td class="memItemLeft" align="right" valign="top"><a id="ab94ee55b0cdd0af9c161f467f1bd8888"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetOpEnginePref</b> (const std::string &amp;op_type, const CaffeMap&lt; int, EnginePrefType &gt; &amp;op_pref)</td></tr>
<tr class="separator:ab94ee55b0cdd0af9c161f467f1bd8888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fe5fbabd4ed39bcb3d1cf3dda65120"><td class="memItemLeft" align="right" valign="top"><a id="af1fe5fbabd4ed39bcb3d1cf3dda65120"></a>
unique_ptr&lt; <a class="el" href="classcaffe2_1_1OperatorBase.html">OperatorBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateOperator</b> (const OperatorDef &amp;operator_def, <a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *ws, int net_position)</td></tr>
<tr class="separator:af1fe5fbabd4ed39bcb3d1cf3dda65120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae95e80dc70afcb193bf36f1b797073b"><td class="memItemLeft" align="right" valign="top"><a id="aae95e80dc70afcb193bf36f1b797073b"></a>
std::map&lt; int32_t, OperatorRegistry * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>gDeviceTypeRegistry</b> ()</td></tr>
<tr class="separator:aae95e80dc70afcb193bf36f1b797073b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ccce96415b7bc739e592db48b1a799"><td class="memItemLeft" align="right" valign="top"><a id="a18ccce96415b7bc739e592db48b1a799"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_REGISTRY</b> (CPUOperatorRegistry, <a class="el" href="classcaffe2_1_1OperatorBase.html">OperatorBase</a>, const OperatorDef &amp;, <a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *)</td></tr>
<tr class="separator:a18ccce96415b7bc739e592db48b1a799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0183c10eb1de0e508a17ac16db32d324"><td class="memItemLeft" align="right" valign="top"><a id="a0183c10eb1de0e508a17ac16db32d324"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_REGISTER_DEVICE_TYPE</b> (DeviceType::CPU, CPUOperatorRegistry)</td></tr>
<tr class="separator:a0183c10eb1de0e508a17ac16db32d324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e181d42b6611b65f471704b8c954a81"><td class="memItemLeft" align="right" valign="top"><a id="a9e181d42b6611b65f471704b8c954a81"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_REGISTRY</b> (CUDAOperatorRegistry, <a class="el" href="classcaffe2_1_1OperatorBase.html">OperatorBase</a>, const OperatorDef &amp;, <a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *)</td></tr>
<tr class="separator:a9e181d42b6611b65f471704b8c954a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaea084dc8c55e43149d0becb508dcdc"><td class="memItemLeft" align="right" valign="top"><a id="adaea084dc8c55e43149d0becb508dcdc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_REGISTER_DEVICE_TYPE</b> (DeviceType::CUDA, CUDAOperatorRegistry)</td></tr>
<tr class="separator:adaea084dc8c55e43149d0becb508dcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c198acf57d3e0880cc9bd8d8af0b5e"><td class="memItemLeft" align="right" valign="top"><a id="ae5c198acf57d3e0880cc9bd8d8af0b5e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_REGISTRY</b> (GradientRegistry, <a class="el" href="classcaffe2_1_1GradientMakerBase.html">GradientMakerBase</a>, const OperatorDef &amp;, const vector&lt; <a class="el" href="structcaffe2_1_1GradientWrapper.html">GradientWrapper</a> &gt; &amp;)</td></tr>
<tr class="separator:ae5c198acf57d3e0880cc9bd8d8af0b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7346efe7dfdcad2d65571bde97b3fc04"><td class="memItemLeft" align="right" valign="top"><a id="a7346efe7dfdcad2d65571bde97b3fc04"></a>
<a class="el" href="structcaffe2_1_1GradientOpsMeta.html">GradientOpsMeta</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a7346efe7dfdcad2d65571bde97b3fc04">GetGradientForOp</a> (const OperatorDef &amp;def, const vector&lt; <a class="el" href="structcaffe2_1_1GradientWrapper.html">GradientWrapper</a> &gt; &amp;g_output)</td></tr>
<tr class="memdesc:a7346efe7dfdcad2d65571bde97b3fc04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="structcaffe2_1_1GradientOpsMeta.html" title="A struct that holds the gradient operators and related gradient maps. ">GradientOpsMeta</a> for the given operator def. <br /></td></tr>
<tr class="separator:a7346efe7dfdcad2d65571bde97b3fc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6666b1d285ffa56a211c30a9cfa52e10"><td class="memItemLeft" align="right" valign="top"><a id="a6666b1d285ffa56a211c30a9cfa52e10"></a>
TensorShape&#160;</td><td class="memItemRight" valign="bottom"><b>GetTensorShapeOfBlob</b> (const <a class="el" href="classcaffe2_1_1Blob.html">Blob</a> *b)</td></tr>
<tr class="separator:a6666b1d285ffa56a211c30a9cfa52e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898074bc24cb7ebae42f3f6d34b636f6"><td class="memItemLeft" align="right" valign="top"><a id="a898074bc24cb7ebae42f3f6d34b636f6"></a>
TensorShapes&#160;</td><td class="memItemRight" valign="bottom"><b>InferBlobShapesAndTypesFromWorkspace</b> (<a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *ws, const vector&lt; std::unique_ptr&lt; NetDef &gt;&gt; &amp;nets)</td></tr>
<tr class="separator:a898074bc24cb7ebae42f3f6d34b636f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b62b3f41036c69569f008cde937ee7"><td class="memItemLeft" align="right" valign="top"><a id="a36b62b3f41036c69569f008cde937ee7"></a>
TensorShapes&#160;</td><td class="memItemRight" valign="bottom"><b>InferBlobShapesAndTypesFromMap</b> (const CaffeMap&lt; std::string, std::vector&lt; TIndex &gt;&gt; &amp;blob_dimensions, const vector&lt; std::unique_ptr&lt; NetDef &gt;&gt; &amp;nets)</td></tr>
<tr class="separator:a36b62b3f41036c69569f008cde937ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3f3de4444365b0671e00491c0a37f2"><td class="memItemLeft" align="right" valign="top"><a id="a1d3f3de4444365b0671e00491c0a37f2"></a>
std::map&lt; string, std::pair&lt; DeviceOption, DeviceOption &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ValidateTensorDevices</b> (<a class="el" href="classcaffe2_1_1OperatorBase.html">OperatorBase</a> &amp;op, const OperatorDef &amp;op_def)</td></tr>
<tr class="separator:a1d3f3de4444365b0671e00491c0a37f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25724da2473cdc552f28a790fdc71d57"><td class="memItemLeft" align="right" valign="top"><a id="a25724da2473cdc552f28a790fdc71d57"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE2_DEFINE_TENSOR_TYPES_DISPATCHER</b> (<a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>, DoRunWithType, DoRunWithOtherType) CAFFE2_DEFINE_TENSOR_TYPES_DISPATCHER(<a class="el" href="structcaffe2_1_1TensorTypes2.html">TensorTypes2</a></td></tr>
<tr class="separator:a25724da2473cdc552f28a790fdc71d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4eec8f63b0fcc386aa60145bedbca91"><td class="memItemLeft" align="right" valign="top"><a id="ac4eec8f63b0fcc386aa60145bedbca91"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_REGISTRY</b> (CPUOperatorRegistry, <a class="el" href="classcaffe2_1_1OperatorBase.html">OperatorBase</a>, const OperatorDef &amp;, <a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *)</td></tr>
<tr class="separator:ac4eec8f63b0fcc386aa60145bedbca91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71d5fd929969e3cc4d0b8b3621e4d1d"><td class="memItemLeft" align="right" valign="top"><a id="ab71d5fd929969e3cc4d0b8b3621e4d1d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_REGISTRY</b> (CUDAOperatorRegistry, <a class="el" href="classcaffe2_1_1OperatorBase.html">OperatorBase</a>, const OperatorDef &amp;, <a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *)</td></tr>
<tr class="separator:ab71d5fd929969e3cc4d0b8b3621e4d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b084aeace402eedb94e1f3d390a437"><td class="memItemLeft" align="right" valign="top"><a id="a10b084aeace402eedb94e1f3d390a437"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_REGISTRY</b> (GradientRegistry, <a class="el" href="classcaffe2_1_1GradientMakerBase.html">GradientMakerBase</a>, const OperatorDef &amp;, const vector&lt; <a class="el" href="structcaffe2_1_1GradientWrapper.html">GradientWrapper</a> &gt; &amp;)</td></tr>
<tr class="separator:a10b084aeace402eedb94e1f3d390a437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38723124ff21e43fde4bca605606d0a3"><td class="memItemLeft" align="right" valign="top"><a id="a38723124ff21e43fde4bca605606d0a3"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;out, const <a class="el" href="classcaffe2_1_1OpSchema.html">OpSchema</a> &amp;schema)</td></tr>
<tr class="separator:a38723124ff21e43fde4bca605606d0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a19947850594eb5d2a960f6e2259d49"><td class="memTemplParams" colspan="2"><a id="a7a19947850594eb5d2a960f6e2259d49"></a>
template&lt;typename T_I  = int&gt; </td></tr>
<tr class="memitem:a7a19947850594eb5d2a960f6e2259d49"><td class="memTemplItemLeft" align="right" valign="top">TensorShape&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateTensorShape</b> (vector&lt; T_I &gt; dims, ::caffe2::TensorProto_DataType dt)</td></tr>
<tr class="separator:a7a19947850594eb5d2a960f6e2259d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547e1b3df7861a894d5a1371b2980044"><td class="memItemLeft" align="right" valign="top"><a id="a547e1b3df7861a894d5a1371b2980044"></a>
vector&lt; TIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetDimsVector</b> (const TensorShape &amp;shape)</td></tr>
<tr class="separator:a547e1b3df7861a894d5a1371b2980044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e0910770fec5599962a43c497111c0"><td class="memItemLeft" align="right" valign="top"><a id="aa6e0910770fec5599962a43c497111c0"></a>
std::pair&lt; std::vector&lt; DeviceOption &gt;, std::vector&lt; DeviceOption &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>InferOpInputOutputDevice</b> (const OperatorDef &amp;op)</td></tr>
<tr class="separator:aa6e0910770fec5599962a43c497111c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411bcb87b2fa7b8e4f543076adf911cf"><td class="memTemplParams" colspan="2"><a id="a411bcb87b2fa7b8e4f543076adf911cf"></a>
template&lt;uint64_t OpsPerPoint&gt; </td></tr>
<tr class="memitem:a411bcb87b2fa7b8e4f543076adf911cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structcaffe2_1_1OpSchema_1_1Cost.html">OpSchema::Cost</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PointwiseCostInference</b> (const OperatorDef &amp;, const vector&lt; TensorShape &gt; &amp;inputs)</td></tr>
<tr class="separator:a411bcb87b2fa7b8e4f543076adf911cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a8b5bc38099521c1af0be567ce1b1e"><td class="memItemLeft" align="right" valign="top"><a id="ae5a8b5bc38099521c1af0be567ce1b1e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>RunPlanOnWorkspace</b> (<a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *ws, const PlanDef &amp;plan, ShouldContinue shouldContinue)</td></tr>
<tr class="separator:ae5a8b5bc38099521c1af0be567ce1b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688ad3249e176dfbae42646227a62e80"><td class="memItemLeft" align="right" valign="top"><a id="a688ad3249e176dfbae42646227a62e80"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classcaffe2_1_1QTensor.html">QTensor</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a688ad3249e176dfbae42646227a62e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a97f1ca3d23760951c4556f99aaec4"><td class="memTemplParams" colspan="2"><a id="ac8a97f1ca3d23760951c4556f99aaec4"></a>
template&lt;typename KeyType &gt; </td></tr>
<tr class="memitem:ac8a97f1ca3d23760951c4556f99aaec4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PrintOffendingKey</b> (const KeyType &amp;key)</td></tr>
<tr class="separator:ac8a97f1ca3d23760951c4556f99aaec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30032d5ee3b8af7dc1c7ddc05b770e6"><td class="memTemplParams" colspan="2"><a id="ac30032d5ee3b8af7dc1c7ddc05b770e6"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac30032d5ee3b8af7dc1c7ddc05b770e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PrintOffendingKey</b> (const string &amp;key)</td></tr>
<tr class="separator:ac30032d5ee3b8af7dc1c7ddc05b770e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ebf399716fbf0ba249317657150790"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a12ebf399716fbf0ba249317657150790"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaffe2_1_1detail_1_1ScopeGuardImpl.html">detail::ScopeGuardImplDecay</a>&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a12ebf399716fbf0ba249317657150790">MakeGuard</a> (F &amp;&amp;f) noexcept(noexcept(<a class="el" href="classcaffe2_1_1detail_1_1ScopeGuardImpl.html">detail::ScopeGuardImplDecay</a>&lt; F &gt;(static_cast&lt; F &amp;&amp;&gt;(f))))</td></tr>
<tr class="memdesc:a12ebf399716fbf0ba249317657150790"><td class="mdescLeft">&#160;</td><td class="mdescRight">ScopeGuard is a general implementation of the "Initialization is
Resource Acquisition" idiom.  <a href="#a12ebf399716fbf0ba249317657150790">More...</a><br /></td></tr>
<tr class="separator:a12ebf399716fbf0ba249317657150790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae540f11fb3a2140dda5a6fae356774d7"><td class="memItemLeft" align="right" valign="top"><a id="ae540f11fb3a2140dda5a6fae356774d7"></a>
ExportedStatMap&#160;</td><td class="memItemRight" valign="bottom"><b>toMap</b> (const <a class="el" href="namespacecaffe2.html#a8eb1578901c4027246db0d3e46305c7f">ExportedStatList</a> &amp;stats)</td></tr>
<tr class="separator:ae540f11fb3a2140dda5a6fae356774d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d23c3fec40e8669e8ce130a588bd7e"><td class="memItemLeft" align="right" valign="top"><a id="a38d23c3fec40e8669e8ce130a588bd7e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a38d23c3fec40e8669e8ce130a588bd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31eec530d92a9d3ad68c2e6ddf9b887d"><td class="memItemLeft" align="right" valign="top"><a id="a31eec530d92a9d3ad68c2e6ddf9b887d"></a>
TypeCall&#160;</td><td class="memItemRight" valign="bottom"><b>GetTypeCallFunction</b> (CaffeTypeId id)</td></tr>
<tr class="separator:a31eec530d92a9d3ad68c2e6ddf9b887d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edcdb3b2b8630f92646c7189387a7d6"><td class="memItemLeft" align="right" valign="top"><a id="a8edcdb3b2b8630f92646c7189387a7d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RegisterTypeCallFunction</b> (CaffeTypeId id, TypeCall c)</td></tr>
<tr class="separator:a8edcdb3b2b8630f92646c7189387a7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303032ee4249c4513e4e30d23c0e94ea"><td class="memItemLeft" align="right" valign="top"><a id="a303032ee4249c4513e4e30d23c0e94ea"></a>
TensorInfoCall&#160;</td><td class="memItemRight" valign="bottom"><b>GetTensorInfoFunction</b> (CaffeTypeId id)</td></tr>
<tr class="separator:a303032ee4249c4513e4e30d23c0e94ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ebcac892ada72e7c21ffcd79a5d80c"><td class="memItemLeft" align="right" valign="top"><a id="a46ebcac892ada72e7c21ffcd79a5d80c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RegisterTensorInfoFunction</b> (CaffeTypeId id, TensorInfoCall c)</td></tr>
<tr class="separator:a46ebcac892ada72e7c21ffcd79a5d80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591122a8091d7c58df32810129874cb2"><td class="memItemLeft" align="right" valign="top"><a id="a591122a8091d7c58df32810129874cb2"></a>
vector&lt; TIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a591122a8091d7c58df32810129874cb2">ToVectorTIndex</a> (const std::vector&lt; int &gt; &amp;src)</td></tr>
<tr class="memdesc:a591122a8091d7c58df32810129874cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to convert vector&lt;int&gt; to vector&lt;TIndex&gt;. <br /></td></tr>
<tr class="separator:a591122a8091d7c58df32810129874cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57dab6c8becb4bb52f6e74e5c1063487"><td class="memItemLeft" align="right" valign="top"><a id="a57dab6c8becb4bb52f6e74e5c1063487"></a>
TIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a57dab6c8becb4bb52f6e74e5c1063487">size_from_dim_</a> (int k, vector&lt; TIndex &gt; dims)</td></tr>
<tr class="memdesc:a57dab6c8becb4bb52f6e74e5c1063487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return product of all dimensions starting from K. <br /></td></tr>
<tr class="separator:a57dab6c8becb4bb52f6e74e5c1063487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c6b41b31c43fa77ab0789b98170249"><td class="memItemLeft" align="right" valign="top"><a id="a71c6b41b31c43fa77ab0789b98170249"></a>
TIndex&#160;</td><td class="memItemRight" valign="bottom"><b>size_to_dim_</b> (int k, vector&lt; TIndex &gt; dims)</td></tr>
<tr class="separator:a71c6b41b31c43fa77ab0789b98170249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9762eaebb9597fdc834d073eeefee6"><td class="memItemLeft" align="right" valign="top"><a id="a8e9762eaebb9597fdc834d073eeefee6"></a>
TIndex&#160;</td><td class="memItemRight" valign="bottom"><b>size_between_dim_</b> (int k, int l, vector&lt; TIndex &gt; dims)</td></tr>
<tr class="separator:a8e9762eaebb9597fdc834d073eeefee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355be215dea0c5371219749fa6f79801"><td class="memItemLeft" align="right" valign="top"><a id="a355be215dea0c5371219749fa6f79801"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>canonical_axis_index_</b> (int axis_index, int ndims)</td></tr>
<tr class="separator:a355be215dea0c5371219749fa6f79801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819f43601a5f85d722aa863ba2f8c5c9"><td class="memTemplParams" colspan="2"><a id="a819f43601a5f85d722aa863ba2f8c5c9"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:a819f43601a5f85d722aa863ba2f8c5c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcaffe2_1_1TypeMeta.html">TypeMeta</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetTensorType</b> (const void *c)</td></tr>
<tr class="separator:a819f43601a5f85d722aa863ba2f8c5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2018f4cb3ab9f5347fba64c846285c0"><td class="memTemplParams" colspan="2"><a id="ac2018f4cb3ab9f5347fba64c846285c0"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:ac2018f4cb3ab9f5347fba64c846285c0"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; TIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GetTensorInfo</b> (const void *c, bool *shares_data, size_t *capacity, DeviceOption *device)</td></tr>
<tr class="separator:ac2018f4cb3ab9f5347fba64c846285c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8008ca85768ac0b118e11d26c9421582"><td class="memItemLeft" align="right" valign="top"><a id="a8008ca85768ac0b118e11d26c9421582"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DEFINE_REGISTRY</b> (TransformRegistry, <a class="el" href="classcaffe2_1_1Transform.html">Transform</a>)</td></tr>
<tr class="separator:a8008ca85768ac0b118e11d26c9421582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d4878f94b93ac50c461c3a50f44a06"><td class="memItemLeft" align="right" valign="top"><a id="ac2d4878f94b93ac50c461c3a50f44a06"></a>
unique_ptr&lt; <a class="el" href="classcaffe2_1_1Transform.html">Transform</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>CreateTransform</b> (string key)</td></tr>
<tr class="separator:ac2d4878f94b93ac50c461c3a50f44a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9114a03c171856d17fb868af046ac8af"><td class="memItemLeft" align="right" valign="top"><a id="a9114a03c171856d17fb868af046ac8af"></a>
NetDef&#160;</td><td class="memItemRight" valign="bottom"><b>ApplyTransform</b> (const string &amp;key, const NetDef &amp;netdef)</td></tr>
<tr class="separator:a9114a03c171856d17fb868af046ac8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f7e2a2d404e67e6fdc0ce986dd0d48"><td class="memItemLeft" align="right" valign="top"><a id="a20f7e2a2d404e67e6fdc0ce986dd0d48"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>average_net_run_duration</b> (const NetDef &amp;netdef, const NetDef &amp;init_netdef, const int warmup_runs, const int main_runs)</td></tr>
<tr class="separator:a20f7e2a2d404e67e6fdc0ce986dd0d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa047c11708af221b50899fb3c7d04b"><td class="memItemLeft" align="right" valign="top"><a id="acaa047c11708af221b50899fb3c7d04b"></a>
NetDef&#160;</td><td class="memItemRight" valign="bottom"><b>ApplyTransformIfFaster</b> (const string &amp;key, const NetDef &amp;netdef, const NetDef &amp;init_netdef, const int warmup_runs, const int main_runs, const double improvement_threshold)</td></tr>
<tr class="separator:acaa047c11708af221b50899fb3c7d04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b0e232312c328538bc6968378481583"><td class="memItemLeft" align="right" valign="top"><a id="a1b0e232312c328538bc6968378481583"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_REGISTRY</b> (TransformRegistry, <a class="el" href="classcaffe2_1_1Transform.html">Transform</a>)</td></tr>
<tr class="separator:a1b0e232312c328538bc6968378481583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad0cd0fc9f0b5a43bdbc428623415003"><td class="memItemLeft" align="right" valign="top"><a id="aad0cd0fc9f0b5a43bdbc428623415003"></a>
std::map&lt; CaffeTypeId, string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>gTypeNames</b> ()</td></tr>
<tr class="separator:aad0cd0fc9f0b5a43bdbc428623415003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db08844cb4e1da8e377929d1f8ce42c"><td class="memItemLeft" align="right" valign="top"><a id="a6db08844cb4e1da8e377929d1f8ce42c"></a>
std::set&lt; string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>gRegisteredTypeNames</b> ()</td></tr>
<tr class="separator:a6db08844cb4e1da8e377929d1f8ce42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7e122b63ebfcd08897660f43e6f302"><td class="memItemLeft" align="right" valign="top"><a id="aad7e122b63ebfcd08897660f43e6f302"></a>
std::mutex &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>gCaffe2TypeRegistrationMutex</b> ()</td></tr>
<tr class="separator:aad7e122b63ebfcd08897660f43e6f302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392e317fd2c720edc0239431d6db3763"><td class="memItemLeft" align="right" valign="top"><a id="a392e317fd2c720edc0239431d6db3763"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>Demangle</b> (const char *name)</td></tr>
<tr class="separator:a392e317fd2c720edc0239431d6db3763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae840bee8278a15d265af6d1a61e50af3"><td class="memItemLeft" align="right" valign="top"><a id="ae840bee8278a15d265af6d1a61e50af3"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>GetExceptionString</b> (const std::exception &amp;e)</td></tr>
<tr class="separator:ae840bee8278a15d265af6d1a61e50af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c983e857641138000f973df762bbb1"><td class="memItemLeft" align="right" valign="top"><a id="a51c983e857641138000f973df762bbb1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (float)</td></tr>
<tr class="separator:a51c983e857641138000f973df762bbb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8995c84c4bb43b29031202d257f4d447"><td class="memItemLeft" align="right" valign="top"><a id="a8995c84c4bb43b29031202d257f4d447"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (int)</td></tr>
<tr class="separator:a8995c84c4bb43b29031202d257f4d447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7925ba5e84f7102ed481f2ac488f7acb"><td class="memItemLeft" align="right" valign="top"><a id="a7925ba5e84f7102ed481f2ac488f7acb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::string)</td></tr>
<tr class="separator:a7925ba5e84f7102ed481f2ac488f7acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2ebb3c0a4e3810919e373eb775ef37"><td class="memItemLeft" align="right" valign="top"><a id="aba2ebb3c0a4e3810919e373eb775ef37"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (bool)</td></tr>
<tr class="separator:aba2ebb3c0a4e3810919e373eb775ef37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9730c3506017b0184c2b661bbb75a7a1"><td class="memItemLeft" align="right" valign="top"><a id="a9730c3506017b0184c2b661bbb75a7a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (uint8_t)</td></tr>
<tr class="separator:a9730c3506017b0184c2b661bbb75a7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5772e6c8dd480e999ed64dcd03158397"><td class="memItemLeft" align="right" valign="top"><a id="a5772e6c8dd480e999ed64dcd03158397"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (int8_t)</td></tr>
<tr class="separator:a5772e6c8dd480e999ed64dcd03158397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d367fb77a2fd456b892867555c79d8"><td class="memItemLeft" align="right" valign="top"><a id="a66d367fb77a2fd456b892867555c79d8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (uint16_t)</td></tr>
<tr class="separator:a66d367fb77a2fd456b892867555c79d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7198280bd7f56a495098d54e497c52"><td class="memItemLeft" align="right" valign="top"><a id="afa7198280bd7f56a495098d54e497c52"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (int16_t)</td></tr>
<tr class="separator:afa7198280bd7f56a495098d54e497c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3ca7fc046c557c2d2def8887f241e5"><td class="memItemLeft" align="right" valign="top"><a id="a4a3ca7fc046c557c2d2def8887f241e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (int64_t)</td></tr>
<tr class="separator:a4a3ca7fc046c557c2d2def8887f241e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4463c309242c58740964e0b78b76e831"><td class="memItemLeft" align="right" valign="top"><a id="a4463c309242c58740964e0b78b76e831"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (float16)</td></tr>
<tr class="separator:a4463c309242c58740964e0b78b76e831"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b979cd9e22d61ab7222f2d4384f344"><td class="memItemLeft" align="right" valign="top"><a id="ad8b979cd9e22d61ab7222f2d4384f344"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (double)</td></tr>
<tr class="separator:ad8b979cd9e22d61ab7222f2d4384f344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a221cc9f7e8adebd6cfa16b9055260a"><td class="memItemLeft" align="right" valign="top"><a id="a0a221cc9f7e8adebd6cfa16b9055260a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (char)</td></tr>
<tr class="separator:a0a221cc9f7e8adebd6cfa16b9055260a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7cc4446a72ffc28ef0111ff16b2276"><td class="memItemLeft" align="right" valign="top"><a id="abc7cc4446a72ffc28ef0111ff16b2276"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::unique_ptr&lt; std::mutex &gt;)</td></tr>
<tr class="separator:abc7cc4446a72ffc28ef0111ff16b2276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7825294fc2cbf1971625491a0900b9e5"><td class="memItemLeft" align="right" valign="top"><a id="a7825294fc2cbf1971625491a0900b9e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::unique_ptr&lt; std::atomic&lt; bool &gt;&gt;)</td></tr>
<tr class="separator:a7825294fc2cbf1971625491a0900b9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad65b6b7297f9731bc45e0854eab78be8"><td class="memItemLeft" align="right" valign="top"><a id="ad65b6b7297f9731bc45e0854eab78be8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::vector&lt; int64_t &gt;)</td></tr>
<tr class="separator:ad65b6b7297f9731bc45e0854eab78be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770016f922f09c039b1a5fb544437ef6"><td class="memItemLeft" align="right" valign="top"><a id="a770016f922f09c039b1a5fb544437ef6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::vector&lt; unsigned long &gt;)</td></tr>
<tr class="separator:a770016f922f09c039b1a5fb544437ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69da1013fe9462e68be1bc242791ae0"><td class="memItemLeft" align="right" valign="top"><a id="ae69da1013fe9462e68be1bc242791ae0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (bool *)</td></tr>
<tr class="separator:ae69da1013fe9462e68be1bc242791ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5897a3cd04ba8bb49851ce026adbb7c3"><td class="memItemLeft" align="right" valign="top"><a id="a5897a3cd04ba8bb49851ce026adbb7c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (char *)</td></tr>
<tr class="separator:a5897a3cd04ba8bb49851ce026adbb7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5efbc72153701c1e5283610874d15e06"><td class="memItemLeft" align="right" valign="top"><a id="a5efbc72153701c1e5283610874d15e06"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (int *)</td></tr>
<tr class="separator:a5efbc72153701c1e5283610874d15e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52cd66de2686592e3e83f6fdb7a0ec2a"><td class="memItemLeft" align="right" valign="top"><a id="a52cd66de2686592e3e83f6fdb7a0ec2a"></a>
TensorProto::DataType&#160;</td><td class="memItemRight" valign="bottom"><b>TypeMetaToDataType</b> (const <a class="el" href="classcaffe2_1_1TypeMeta.html">TypeMeta</a> &amp;meta)</td></tr>
<tr class="separator:a52cd66de2686592e3e83f6fdb7a0ec2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847a88c5009fa01818909600b736cc30"><td class="memItemLeft" align="right" valign="top"><a id="a847a88c5009fa01818909600b736cc30"></a>
const <a class="el" href="classcaffe2_1_1TypeMeta.html">TypeMeta</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>DataTypeToTypeMeta</b> (const TensorProto::DataType &amp;dt)</td></tr>
<tr class="separator:a847a88c5009fa01818909600b736cc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176793571dce6525db610f6d826494f9"><td class="memTemplParams" colspan="2"><a id="a176793571dce6525db610f6d826494f9"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a176793571dce6525db610f6d826494f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fp16_type&lt; float16 &gt;</b> ()</td></tr>
<tr class="separator:a176793571dce6525db610f6d826494f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bbd44760a61e661c53c6cdaa7baf6d"><td class="memItemLeft" align="right" valign="top"><a id="a86bbd44760a61e661c53c6cdaa7baf6d"></a>
StorageOrder&#160;</td><td class="memItemRight" valign="bottom"><b>StringToStorageOrder</b> (const string &amp;str)</td></tr>
<tr class="separator:a86bbd44760a61e661c53c6cdaa7baf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae297cfca76b377a990a2a4bff4795150"><td class="memItemLeft" align="right" valign="top"><a id="ae297cfca76b377a990a2a4bff4795150"></a>
constexpr char&#160;</td><td class="memItemRight" valign="bottom"><b>NameScopeSeparator</b> ()</td></tr>
<tr class="separator:ae297cfca76b377a990a2a4bff4795150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591260a9560d754c1a17a0603b4d5c53"><td class="memItemLeft" align="right" valign="top"><a id="a591260a9560d754c1a17a0603b4d5c53"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE2_ALIGNED</b> (2) __f16</td></tr>
<tr class="separator:a591260a9560d754c1a17a0603b4d5c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1492d6608aa1f2b649828d333a6910"><td class="memTemplParams" colspan="2"><a id="afb1492d6608aa1f2b649828d333a6910"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb1492d6608aa1f2b649828d333a6910"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fp16_type</b> ()</td></tr>
<tr class="separator:afb1492d6608aa1f2b649828d333a6910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0306aadcb419780516c195f5b435897c"><td class="memItemLeft" align="right" valign="top"><a id="a0306aadcb419780516c195f5b435897c"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>GetUniqueName</b> ()</td></tr>
<tr class="separator:a0306aadcb419780516c195f5b435897c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b557447becfb20d0d39ff544fe9bf0"><td class="memItemLeft" align="right" valign="top"><a id="a28b557447becfb20d0d39ff544fe9bf0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CreateDB, <a class="el" href="classcaffe2_1_1CreateDBOp.html">CreateDBOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a28b557447becfb20d0d39ff544fe9bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdcc1dfc6eddc86232b2f37132a028d0"><td class="memItemLeft" align="right" valign="top"><a id="acdcc1dfc6eddc86232b2f37132a028d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (CreateDB).NumInputs(0).NumOutputs(1)</td></tr>
<tr class="separator:acdcc1dfc6eddc86232b2f37132a028d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc2a9a202be73d0b77dfddc91f9d677"><td class="memItemLeft" align="right" valign="top"><a id="a5bc2a9a202be73d0b77dfddc91f9d677"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (CreateDB)</td></tr>
<tr class="separator:a5bc2a9a202be73d0b77dfddc91f9d677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16173d7eb43a9222a6fddb7f4da601cd"><td class="memItemLeft" align="right" valign="top"><a id="a16173d7eb43a9222a6fddb7f4da601cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CreateDB, <a class="el" href="classcaffe2_1_1CreateDBOp.html">CreateDBOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a16173d7eb43a9222a6fddb7f4da601cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76be045297e05130e27811a26458603"><td class="memItemLeft" align="right" valign="top"><a id="af76be045297e05130e27811a26458603"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FileStoreHandlerCreate, <a class="el" href="classcaffe2_1_1FileStoreHandlerCreateOp.html">FileStoreHandlerCreateOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af76be045297e05130e27811a26458603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0570d01c65a78d06268cef79f7e79878"><td class="memItemLeft" align="right" valign="top"><a id="a0570d01c65a78d06268cef79f7e79878"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (0) .NumOutputs(1) .SetDoc(R&quot;DOC( Creates a unique_ptr&lt;<a class="el" href="classcaffe2_1_1StoreHandler.html">StoreHandler</a>&gt; that uses the filesystem as backing store (typically a filesystem shared between many nodes</td></tr>
<tr class="separator:a0570d01c65a78d06268cef79f7e79878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0629088cc0af24fa4e37611a7f098f6e"><td class="memItemLeft" align="right" valign="top"><a id="a0629088cc0af24fa4e37611a7f098f6e"></a>
such as NFS This store handler is not built to be fast Its recommended use is for integration tests and prototypes where extra dependencies are cumbersome Use an ephemeral path to ensure multiple processes or runs don t interfere DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;path&quot;, &quot;base path used by the <a class="el" href="classcaffe2_1_1FileStoreHandler.html">FileStoreHandler</a>&quot;) .Arg(&quot;prefix&quot;</td></tr>
<tr class="separator:a0629088cc0af24fa4e37611a7f098f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3127c15f65ee70830a5dbeabdd7f763b"><td class="memItemLeft" align="right" valign="top"><a id="a3127c15f65ee70830a5dbeabdd7f763b"></a>
such as NFS This store handler is not built to be fast Its recommended use is for integration tests and prototypes where extra dependencies are cumbersome Use an ephemeral path to ensure multiple processes or runs don t interfere DOC prefix for all keys used by this store&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;handler&quot;, &quot;unique_ptr&lt;<a class="el" href="classcaffe2_1_1StoreHandler.html">StoreHandler</a>&gt;&quot;)</td></tr>
<tr class="separator:a3127c15f65ee70830a5dbeabdd7f763b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24607d1dba5a15796277e7fe9f50490f"><td class="memItemLeft" align="right" valign="top"><a id="a24607d1dba5a15796277e7fe9f50490f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (<a class="el" href="classcaffe2_1_1FileStoreHandlerCreateOp.html">FileStoreHandlerCreateOp</a>)</td></tr>
<tr class="separator:a24607d1dba5a15796277e7fe9f50490f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea7d9f58907b76a7f6572dd83d7791f"><td class="memItemLeft" align="right" valign="top"><a id="a9ea7d9f58907b76a7f6572dd83d7791f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (FileStoreHandlerCreate, <a class="el" href="classcaffe2_1_1FileStoreHandlerCreateOp.html">FileStoreHandlerCreateOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a9ea7d9f58907b76a7f6572dd83d7791f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb7f7164de654982fdb560ec12e4520"><td class="memItemLeft" align="right" valign="top"><a id="abdb7f7164de654982fdb560ec12e4520"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RedisStoreHandlerCreate, <a class="el" href="classcaffe2_1_1RedisStoreHandlerCreateOp.html">RedisStoreHandlerCreateOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:abdb7f7164de654982fdb560ec12e4520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5e5a353bda1732b8eb49541a31f4ee1"><td class="memItemLeft" align="right" valign="top"><a id="ab5e5a353bda1732b8eb49541a31f4ee1"></a>
host name of Redis server&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;port&quot;, &quot;port number of Redis server&quot;) .Arg(&quot;prefix&quot;</td></tr>
<tr class="separator:ab5e5a353bda1732b8eb49541a31f4ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a8dd644c361881494e3250228459e8"><td class="memItemLeft" align="right" valign="top"><a id="a51a8dd644c361881494e3250228459e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (<a class="el" href="classcaffe2_1_1RedisStoreHandlerCreateOp.html">RedisStoreHandlerCreateOp</a>)</td></tr>
<tr class="separator:a51a8dd644c361881494e3250228459e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc556e15840343912103bdcd7554f921"><td class="memItemLeft" align="right" valign="top"><a id="abc556e15840343912103bdcd7554f921"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (RedisStoreHandlerCreate, <a class="el" href="classcaffe2_1_1RedisStoreHandlerCreateOp.html">RedisStoreHandlerCreateOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:abc556e15840343912103bdcd7554f921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01323d7c66e4cd79858fe8baf05b95a8"><td class="memItemLeft" align="right" valign="top"><a id="a01323d7c66e4cd79858fe8baf05b95a8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1StoreHandler.html">StoreHandler</a> &gt;)</td></tr>
<tr class="separator:a01323d7c66e4cd79858fe8baf05b95a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b16134e5567469a265c9b9502ecc6c"><td class="memItemLeft" align="right" valign="top"><a id="a16b16134e5567469a265c9b9502ecc6c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (StoreSet, <a class="el" href="classcaffe2_1_1StoreSetOp.html">StoreSetOp</a>)</td></tr>
<tr class="separator:a16b16134e5567469a265c9b9502ecc6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b3c12c88e5d502a53e800a1ff4d2162"><td class="memItemLeft" align="right" valign="top"><a id="a4b3c12c88e5d502a53e800a1ff4d2162"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (2) .NumOutputs(0) .SetDoc(R&quot;DOC( Set a blob in a store. The key is the input blob's name and the value is the data in that blob. The key can be overridden by specifying the 'blob_name' argument. )DOC&quot;) .Arg(&quot;blob_name&quot; = Ai * Bi</td></tr>
<tr class="separator:a4b3c12c88e5d502a53e800a1ff4d2162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cd5402bcae1f749878299a2f151ca4"><td class="memItemLeft" align="right" valign="top"><a id="ac6cd5402bcae1f749878299a2f151ca4"></a>
alternative key for the&#160;</td><td class="memItemRight" valign="bottom"><b>blob</b> (optional)&quot;) .Input(0</td></tr>
<tr class="separator:ac6cd5402bcae1f749878299a2f151ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbe79005faa52f9eb454a83bb435c1d"><td class="memItemLeft" align="right" valign="top"><a id="a1fbe79005faa52f9eb454a83bb435c1d"></a>
alternative key for the unique_ptr&lt; <a class="el" href="classcaffe2_1_1StoreHandler.html">StoreHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;data&quot;, &quot;data blob&quot;)</td></tr>
<tr class="separator:a1fbe79005faa52f9eb454a83bb435c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6b861e79f3fcd9f7d74f15fd6e9a01"><td class="memItemLeft" align="right" valign="top"><a id="aba6b861e79f3fcd9f7d74f15fd6e9a01"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (StoreGet, <a class="el" href="classcaffe2_1_1StoreGetOp.html">StoreGetOp</a>)</td></tr>
<tr class="separator:aba6b861e79f3fcd9f7d74f15fd6e9a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7489c9da04822fcb41e3fee9c95b0505"><td class="memItemLeft" align="right" valign="top"><a id="a7489c9da04822fcb41e3fee9c95b0505"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (1) .NumOutputs(1) .SetDoc(R&quot;DOC( Get a blob from a store. The key is the output blob's name. The key can be overridden by specifying the 'blob_name' argument. )DOC&quot;) .Arg(&quot;blob_name&quot;</td></tr>
<tr class="separator:a7489c9da04822fcb41e3fee9c95b0505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f429aaf4d554a5a21ff2907ce997058"><td class="memItemLeft" align="right" valign="top"><a id="a6f429aaf4d554a5a21ff2907ce997058"></a>
alternative key for the unique_ptr&lt; <a class="el" href="classcaffe2_1_1StoreHandler.html">StoreHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;data&quot;, &quot;data blob&quot;)</td></tr>
<tr class="separator:a6f429aaf4d554a5a21ff2907ce997058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8b8e7e21d84dd25c023dec167d81dd"><td class="memItemLeft" align="right" valign="top"><a id="a7c8b8e7e21d84dd25c023dec167d81dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (StoreAdd, <a class="el" href="classcaffe2_1_1StoreAddOp.html">StoreAddOp</a>)</td></tr>
<tr class="separator:a7c8b8e7e21d84dd25c023dec167d81dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02309716bb13766ebff8e2f3e3ec03e8"><td class="memItemLeft" align="right" valign="top"><a id="a02309716bb13766ebff8e2f3e3ec03e8"></a>
the store initializes it to and then performs the add operation The operation returns the resulting counter value DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;blob_name&quot;, &quot;key of the counter (required)&quot;) .Arg(&quot;add_value&quot;</td></tr>
<tr class="separator:a02309716bb13766ebff8e2f3e3ec03e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68207b990da32191700d23970ce4f3f6"><td class="memItemLeft" align="right" valign="top"><a id="a68207b990da32191700d23970ce4f3f6"></a>
the store initializes it to and then performs the add operation The operation returns the resulting counter value DOC value that is&#160;</td><td class="memItemRight" valign="bottom"><b>added</b> (optional, default:1)&quot;) .Input(0</td></tr>
<tr class="separator:a68207b990da32191700d23970ce4f3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfc076157f300dcf7ff803a8cdceb17"><td class="memItemLeft" align="right" valign="top"><a id="acdfc076157f300dcf7ff803a8cdceb17"></a>
the store initializes it to and then performs the add operation The operation returns the resulting counter value DOC value that is unique_ptr&lt; <a class="el" href="classcaffe2_1_1StoreHandler.html">StoreHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;value&quot;, &quot;the current value of the counter&quot;)</td></tr>
<tr class="separator:acdfc076157f300dcf7ff803a8cdceb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeab0bd265fa66d0e05d7655cb8906ca"><td class="memItemLeft" align="right" valign="top"><a id="abeab0bd265fa66d0e05d7655cb8906ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (StoreWait, <a class="el" href="classcaffe2_1_1StoreWaitOp.html">StoreWaitOp</a>)</td></tr>
<tr class="separator:abeab0bd265fa66d0e05d7655cb8906ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1534fabd293858a842b4adb379fd67"><td class="memItemLeft" align="right" valign="top"><a id="a7c1534fabd293858a842b4adb379fd67"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (1, 2) .NumOutputs(0) .SetDoc(R&quot;DOC( Wait for the specified blob names to be set. The blob names can be passed either as an input blob with blob names or as an argument. )DOC&quot;) .Arg(&quot;blob_names&quot;</td></tr>
<tr class="separator:a7c1534fabd293858a842b4adb379fd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24287b57b151acb2377d03fe2e3fa277"><td class="memItemLeft" align="right" valign="top"><a id="a24287b57b151acb2377d03fe2e3fa277"></a>
names of the blobs to wait&#160;</td><td class="memItemRight" valign="bottom"><b>for</b> (optional)&quot;) .Input(0</td></tr>
<tr class="separator:a24287b57b151acb2377d03fe2e3fa277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb16e894fa9e4977622f2dd74a12246"><td class="memItemLeft" align="right" valign="top"><a id="aadb16e894fa9e4977622f2dd74a12246"></a>
names of the blobs to wait unique_ptr&lt; <a class="el" href="classcaffe2_1_1StoreHandler.html">StoreHandler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;names&quot;, &quot;names of the blobs to wait for (optional)&quot;)</td></tr>
<tr class="separator:aadb16e894fa9e4977622f2dd74a12246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5fff4d0d6ba530c8ea01d6fde5fc25"><td class="memItemLeft" align="right" valign="top"><a id="a0a5fff4d0d6ba530c8ea01d6fde5fc25"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FC_Decomp, <a class="el" href="classcaffe2_1_1FullyConnectedOpDecomp.html">FullyConnectedOpDecomp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a0a5fff4d0d6ba530c8ea01d6fde5fc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911bf3beaf2f596dcc1ca5967f7475e1"><td class="memItemLeft" align="right" valign="top"><a id="a911bf3beaf2f596dcc1ca5967f7475e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FCGradient_Decomp, <a class="el" href="classcaffe2_1_1FullyConnectedDecompGradientOp.html">FullyConnectedDecompGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a911bf3beaf2f596dcc1ca5967f7475e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df82fe1d8375465476614a523cfea82"><td class="memItemLeft" align="right" valign="top"><a id="a6df82fe1d8375465476614a523cfea82"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (FC_Decomp).NumInputs(4).NumOutputs(1)</td></tr>
<tr class="separator:a6df82fe1d8375465476614a523cfea82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f43040b9fb5df046e5f903083cfc03"><td class="memItemLeft" align="right" valign="top"><a id="a65f43040b9fb5df046e5f903083cfc03"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (FCGradient_Decomp).NumInputs(4).NumOutputs(3</td></tr>
<tr class="separator:a65f43040b9fb5df046e5f903083cfc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906e13e62402b32f21970ef8eb411544"><td class="memItemLeft" align="right" valign="top"><a id="a906e13e62402b32f21970ef8eb411544"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (FC_Decomp, <a class="el" href="classcaffe2_1_1GetFCDecompGradient.html">GetFCDecompGradient</a>)</td></tr>
<tr class="separator:a906e13e62402b32f21970ef8eb411544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d7a26f4a4525a258e2d4f64242d694"><td class="memItemLeft" align="right" valign="top"><a id="a75d7a26f4a4525a258e2d4f64242d694"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (FC_Decomp, <a class="el" href="classcaffe2_1_1FullyConnectedOpDecomp.html">FullyConnectedOpDecomp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a75d7a26f4a4525a258e2d4f64242d694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf49694959b5633212aa434c41b5649"><td class="memItemLeft" align="right" valign="top"><a id="aedf49694959b5633212aa434c41b5649"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (FCGradient_Decomp, <a class="el" href="classcaffe2_1_1FullyConnectedDecompGradientOp.html">FullyConnectedDecompGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aedf49694959b5633212aa434c41b5649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2a8f898a7f3db2661f2488368a171b"><td class="memItemLeft" align="right" valign="top"><a id="a1d2a8f898a7f3db2661f2488368a171b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TTContraction, <a class="el" href="classcaffe2_1_1TTContractionOp.html">TTContractionOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1d2a8f898a7f3db2661f2488368a171b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f61fa72acba74a260f314be17b09a5"><td class="memItemLeft" align="right" valign="top"><a id="a19f61fa72acba74a260f314be17b09a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (TTContraction, <a class="el" href="classcaffe2_1_1TTContractionOp.html">TTContractionOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a19f61fa72acba74a260f314be17b09a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9af3ee2be947562ddcd01e0b3441548"><td class="memItemLeft" align="right" valign="top"><a id="ae9af3ee2be947562ddcd01e0b3441548"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (TTContractionGradient, <a class="el" href="classcaffe2_1_1TTContractionGradientOp.html">TTContractionGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ae9af3ee2be947562ddcd01e0b3441548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46881f29cd0505bf48b9dc10758d6e2a"><td class="memItemLeft" align="right" valign="top"><a id="a46881f29cd0505bf48b9dc10758d6e2a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ImageInput, <a class="el" href="classcaffe2_1_1ImageInputOp.html">ImageInputOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a46881f29cd0505bf48b9dc10758d6e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e40dabb89bb082774d07c056f1ea6f"><td class="memItemLeft" align="right" valign="top"><a id="a62e40dabb89bb082774d07c056f1ea6f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (0, 1) .NumOutputs(2</td></tr>
<tr class="separator:a62e40dabb89bb082774d07c056f1ea6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0e8a5bd7d0d842b20c046160bcc099"><td class="memItemLeft" align="right" valign="top"><a id="a5c0e8a5bd7d0d842b20c046160bcc099"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> ([](const OperatorDef &amp;def, const vector&lt; TensorShape &gt; &amp;) { vector&lt; TensorShape &gt; out(2);<a class="el" href="classcaffe2_1_1ArgumentHelper.html">ArgumentHelper</a> helper(def);int batch_size=helper.GetSingleArgument&lt; int &gt;(&quot;batch_size&quot;, 0);int crop=helper.GetSingleArgument&lt; int &gt;(&quot;crop&quot;, -1);int color=helper.GetSingleArgument&lt; int &gt;(&quot;color&quot;, 1);CHECK_GT(crop, 0);out[0]=CreateTensorShape(vector&lt; int &gt;{batch_size, crop, crop, color ? 3 :1}, TensorProto::FLOAT);out[1]=CreateTensorShape(vector&lt; int &gt;{1, batch_size}, TensorProto::INT32);return out;}) .SetDoc(R&quot;DOC( Imports and processes images from a database. For each run of the operator</td></tr>
<tr class="separator:a5c0e8a5bd7d0d842b20c046160bcc099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5678012dc440a476d1f8a58be516eceb"><td class="memItemLeft" align="right" valign="top"><a id="a5678012dc440a476d1f8a58be516eceb"></a>
INT_MAX batch_size images will be processed GPUs can optionally be used for part of the processing The following transformations are applied to the image A bounding box is applied to the initial&#160;</td><td class="memItemRight" valign="bottom"><b>image</b> (optional) - The image is rescaled either up or down(with the scale argument) or just up(with the minsize argument) - The image is randomly cropped(crop size is passed as an argument but the location of the crop is random except if is_test is passed in which case the image in cropped at the center) - The image is normalized. Each of its color channels can have separate normalization values The dimension of the output image will always be cropxcrop) DOC&quot;) .Arg(&quot;batch_size&quot;</td></tr>
<tr class="separator:a5678012dc440a476d1f8a58be516eceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17373c51d13dcf41fc79ee29b660f8c"><td class="memItemLeft" align="right" valign="top"><a id="ab17373c51d13dcf41fc79ee29b660f8c"></a>
INT_MAX batch_size images will be processed GPUs can optionally be used for part of the processing The following transformations are applied to the image A bounding box is applied to the initial Number of images to output for each run of the&#160;</td><td class="memItemRight" valign="bottom"><b>operator&quot; &quot;. Must be 1 or greater&quot;) .Arg</b> (&quot;color&quot;, &quot;Number of color channels (1 or 3). Defaults to 1&quot;) .Arg(&quot;color_jitter&quot;</td></tr>
<tr class="separator:ab17373c51d13dcf41fc79ee29b660f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9541edc5a6988b53e954a265b40cd88"><td class="memItemLeft" align="right" valign="top"><a id="af9541edc5a6988b53e954a265b40cd88"></a>
INT_MAX batch_size images will be processed GPUs can optionally be used for part of the processing The following transformations are applied to the image A bounding box is applied to the initial Number of images to output for each run of the Whether or not to do color jitter Defaults to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;img_saturation&quot;, &quot;Image saturation scale used in color jittering. &quot; &quot;Defaults to 0.4&quot;) .Arg(&quot;img_brightness&quot;</td></tr>
<tr class="separator:af9541edc5a6988b53e954a265b40cd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3834ab87c8060cd608c826c758e3da34"><td class="memItemLeft" align="right" valign="top"><a id="a3834ab87c8060cd608c826c758e3da34"></a>
INT_MAX batch_size images will be processed GPUs can optionally be used for part of the processing The following transformations are applied to the image A bounding box is applied to the initial Number of images to output for each run of the Whether or not to do color jitter Defaults to Image brightness scale used in color jittering Defaults to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;img_contrast&quot;, &quot;Image contrast scale used in color jittering. &quot; &quot;Defaults to 0.4&quot;) .Arg(&quot;color_lighting&quot;</td></tr>
<tr class="separator:a3834ab87c8060cd608c826c758e3da34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7092f074f120878c8fbfbe9397e82e"><td class="memItemLeft" align="right" valign="top"><a id="ace7092f074f120878c8fbfbe9397e82e"></a>
INT_MAX batch_size images will be processed GPUs can optionally be used for part of the processing The following transformations are applied to the image A bounding box is applied to the initial Number of images to output for each run of the Whether or not to do color jitter Defaults to Image brightness scale used in color jittering Defaults to Whether or not to do color lighting Defaults to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;color_lighting_std&quot;, &quot;Std of normal distribution where color lighting&quot; &quot; scaling factor is sampled. Defaults to 0.1&quot;) .Arg(&quot;scale_jitter_type&quot;</td></tr>
<tr class="separator:ace7092f074f120878c8fbfbe9397e82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cccad90f7d8ba01e5838e65c96acfa6"><td class="memItemLeft" align="right" valign="top"><a id="a0cccad90f7d8ba01e5838e65c96acfa6"></a>
INT_MAX batch_size images will be processed GPUs can optionally be used for part of the processing The following transformations are applied to the image A bounding box is applied to the initial Number of images to output for each run of the Whether or not to do color jitter Defaults to Image brightness scale used in color jittering Defaults to Whether or not to do color lighting Defaults to Scale the size of the smallest dimension of the image to this Scale and minsize are mutually exclusive Must be larger than crop&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;minsize&quot;, &quot;Scale the size of the smallest dimension of the image to&quot; &quot; this only if the size is initially smaller. Scale and minsize are&quot; &quot; mutually exclusive. Must be larger than crop.&quot;) .Arg(&quot;warp&quot;</td></tr>
<tr class="separator:a0cccad90f7d8ba01e5838e65c96acfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c34b7b7f85df9bb9f4648cf0c69a539"><td class="memItemLeft" align="right" valign="top"><a id="a2c34b7b7f85df9bb9f4648cf0c69a539"></a>
the other dimension is proportionally scaled Defaults to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;crop&quot;, &quot;Size to crop the image to. Must be provided&quot;) .Arg(&quot;mirror&quot;</td></tr>
<tr class="separator:a2c34b7b7f85df9bb9f4648cf0c69a539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bba7ef0a423315404c8cde2a543b2b"><td class="memItemLeft" align="right" valign="top"><a id="a03bba7ef0a423315404c8cde2a543b2b"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;mean&quot;, &quot;Mean by which to normalize color channels.&quot; &quot; Defaults to 0.&quot;) .Arg(&quot;mean_per_channel&quot;</td></tr>
<tr class="separator:a03bba7ef0a423315404c8cde2a543b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3ce9ee2aeabb33d6e0c08a31055fa8"><td class="memItemLeft" align="right" valign="top"><a id="a1c3ce9ee2aeabb33d6e0c08a31055fa8"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color&#160;</td><td class="memItemRight" valign="bottom"><b>channel</b> (1 or 3 elements). Defaults to mean argument. Channel order BGR&quot;) .Arg(&quot;std&quot;</td></tr>
<tr class="separator:a1c3ce9ee2aeabb33d6e0c08a31055fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c3c05817f9126463f6adfd883d9cbd"><td class="memItemLeft" align="right" valign="top"><a id="ab6c3c05817f9126463f6adfd883d9cbd"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;std_per_channel&quot;, &quot;Vector of standard dev. per color channel &quot; &quot; (1 or 3 elements). Defaults to std argument. Channel order is BGR&quot;) .Arg(&quot;bounding_ymin&quot;</td></tr>
<tr class="separator:ab6c3c05817f9126463f6adfd883d9cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2431ce06d86fcbe00461cc50c8481b72"><td class="memItemLeft" align="right" valign="top"><a id="a2431ce06d86fcbe00461cc50c8481b72"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults&#160;</td><td class="memItemRight" valign="bottom"><b>to</b> (none)&quot;) .Arg(&quot;bounding_xmin&quot;</td></tr>
<tr class="separator:a2431ce06d86fcbe00461cc50c8481b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214ed372123f5b28caaad94a698f86f7"><td class="memItemLeft" align="right" valign="top"><a id="a214ed372123f5b28caaad94a698f86f7"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults if the input is in Caffe format Defaults to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;use_gpu_transform&quot;, &quot;1 if GPU acceleration should be used.&quot; &quot; Defaults to 0. Can only be 1 in a <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a>&quot;) .Arg(&quot;decode_threads&quot;</td></tr>
<tr class="separator:a214ed372123f5b28caaad94a698f86f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa193c36c42c0ae16af3e1a887e06a4"><td class="memItemLeft" align="right" valign="top"><a id="a0aa193c36c42c0ae16af3e1a887e06a4"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults if the input is in Caffe format Defaults to Number of CPU decode transform threads Defaults to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;output_type&quot;, &quot;If gpu_transform, can set to FLOAT or FLOAT16.&quot;) .Arg(&quot;db&quot;</td></tr>
<tr class="separator:a0aa193c36c42c0ae16af3e1a887e06a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81eb64afecbbe1ab0bc24bc583fb36bb"><td class="memItemLeft" align="right" valign="top"><a id="a81eb64afecbbe1ab0bc24bc583fb36bb"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults if the input is in Caffe format Defaults to Number of CPU decode transform threads Defaults to Name of the&#160;</td><td class="memItemRight" valign="bottom"><b>database</b> (if not passed as input)&quot;) .Arg(&quot;db_type&quot;</td></tr>
<tr class="separator:a81eb64afecbbe1ab0bc24bc583fb36bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dc28016a0e7d14628c02fdc8909200"><td class="memItemLeft" align="right" valign="top"><a id="aa6dc28016a0e7d14628c02fdc8909200"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults if the input is in Caffe format Defaults to Number of CPU decode transform threads Defaults to Name of the Type of The sizes of any outputs besides the data and&#160;</td><td class="memItemRight" valign="bottom"><b>label</b> (should have a number of elements equal to the number of additional &quot;
         &quot;outputs)&quot;) .Arg(&quot;random_scale&quot;</td></tr>
<tr class="separator:aa6dc28016a0e7d14628c02fdc8909200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fce05e331ad61c9aa349cc55a006a4"><td class="memItemLeft" align="right" valign="top"><a id="af4fce05e331ad61c9aa349cc55a006a4"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults if the input is in Caffe format Defaults to Number of CPU decode transform threads Defaults to Name of the Type of The sizes of any outputs besides the data and shortest side desired for image resize Defaults to [-1, -1] or no random resize desired&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;reader&quot;, &quot;The input reader (a <a class="el" href="classcaffe2_1_1db_1_1DBReader.html">db::DBReader</a>)&quot;) .Output(0</td></tr>
<tr class="separator:af4fce05e331ad61c9aa349cc55a006a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc0780a652cbee5d39a219fbd540765"><td class="memItemLeft" align="right" valign="top"><a id="a6bc0780a652cbee5d39a219fbd540765"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults if the input is in Caffe format Defaults to Number of CPU decode transform threads Defaults to Name of the Type of The sizes of any outputs besides the data and shortest side desired for image resize Defaults to [-1, -1] or no random resize desired <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> containing the images&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1, &quot;label&quot;, &quot;<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> containing the labels&quot;) .Output(2</td></tr>
<tr class="separator:a6bc0780a652cbee5d39a219fbd540765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42eeee1953b1fa22979df2625afd8f7d"><td class="memItemLeft" align="right" valign="top"><a id="a42eeee1953b1fa22979df2625afd8f7d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (ImageInput)</td></tr>
<tr class="separator:a42eeee1953b1fa22979df2625afd8f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ed831fcf3c45cda4c13ca8baf29456"><td class="memTemplParams" colspan="2"><a id="a89ed831fcf3c45cda4c13ca8baf29456"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:a89ed831fcf3c45cda4c13ca8baf29456"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RandomSizedCropping</b> (cv::Mat *img, const int crop, std::mt19937 *randgen)</td></tr>
<tr class="separator:a89ed831fcf3c45cda4c13ca8baf29456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3dfb9938be59968250a613bb0df5dfd"><td class="memTemplParams" colspan="2"><a id="af3dfb9938be59968250a613bb0df5dfd"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:af3dfb9938be59968250a613bb0df5dfd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Saturation</b> (float *img, const int img_size, const float alpha_rand, std::mt19937 *randgen)</td></tr>
<tr class="separator:af3dfb9938be59968250a613bb0df5dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48eca9236fea93a23767520aa5c92d6e"><td class="memTemplParams" colspan="2"><a id="a48eca9236fea93a23767520aa5c92d6e"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:a48eca9236fea93a23767520aa5c92d6e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Brightness</b> (float *img, const int img_size, const float alpha_rand, std::mt19937 *randgen)</td></tr>
<tr class="separator:a48eca9236fea93a23767520aa5c92d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f235bf145f6e8fc9b93d9856001e1d"><td class="memTemplParams" colspan="2"><a id="ae8f235bf145f6e8fc9b93d9856001e1d"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:ae8f235bf145f6e8fc9b93d9856001e1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Contrast</b> (float *img, const int img_size, const float alpha_rand, std::mt19937 *randgen)</td></tr>
<tr class="separator:ae8f235bf145f6e8fc9b93d9856001e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbd0925c4621b7decc472ecf1416797"><td class="memTemplParams" colspan="2"><a id="aacbd0925c4621b7decc472ecf1416797"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:aacbd0925c4621b7decc472ecf1416797"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ColorJitter</b> (float *img, const int img_size, const float saturation, const float brightness, const float contrast, std::mt19937 *randgen)</td></tr>
<tr class="separator:aacbd0925c4621b7decc472ecf1416797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a4c3e3844f779fc095a5b90bfebe33"><td class="memTemplParams" colspan="2"><a id="ab1a4c3e3844f779fc095a5b90bfebe33"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:ab1a4c3e3844f779fc095a5b90bfebe33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ColorLighting</b> (float *img, const int img_size, const float alpha_std, const std::vector&lt; std::vector&lt; float &gt;&gt; &amp;eigvecs, const std::vector&lt; float &gt; &amp;eigvals, std::mt19937 *randgen)</td></tr>
<tr class="separator:ab1a4c3e3844f779fc095a5b90bfebe33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4838fab94fdeefe86e8c1d4db05557"><td class="memTemplParams" colspan="2"><a id="aef4838fab94fdeefe86e8c1d4db05557"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:aef4838fab94fdeefe86e8c1d4db05557"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ColorNormalization</b> (float *img, const int img_size, const int channels, const std::vector&lt; float &gt; &amp;mean, const std::vector&lt; float &gt; &amp;std)</td></tr>
<tr class="separator:aef4838fab94fdeefe86e8c1d4db05557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c8852b2d4c964022bc7b3ff2c71edd"><td class="memTemplParams" colspan="2"><a id="ac0c8852b2d4c964022bc7b3ff2c71edd"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:ac0c8852b2d4c964022bc7b3ff2c71edd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TransformImage</b> (const cv::Mat &amp;scaled_img, const int channels, float *image_data, const bool color_jitter, const float saturation, const float brightness, const float contrast, const bool color_lighting, const float color_lighting_std, const std::vector&lt; std::vector&lt; float &gt;&gt; &amp;color_lighting_eigvecs, const std::vector&lt; float &gt; &amp;color_lighting_eigvals, const int crop, const bool mirror, const std::vector&lt; float &gt; &amp;mean, const std::vector&lt; float &gt; &amp;std, std::mt19937 *randgen, std::bernoulli_distribution *mirror_this_image, bool is_test=false)</td></tr>
<tr class="separator:ac0c8852b2d4c964022bc7b3ff2c71edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c152792102363f875e27d079a3fdfd"><td class="memTemplParams" colspan="2"><a id="a54c152792102363f875e27d079a3fdfd"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:a54c152792102363f875e27d079a3fdfd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CropTransposeImage</b> (const cv::Mat &amp;scaled_img, const int channels, uint8_t *cropped_data, const int crop, const bool mirror, std::mt19937 *randgen, std::bernoulli_distribution *mirror_this_image, bool is_test=false)</td></tr>
<tr class="separator:a54c152792102363f875e27d079a3fdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bf18ece7cf2c9bb50c5cb238f692a8"><td class="memItemLeft" align="right" valign="top"><a id="af5bf18ece7cf2c9bb50c5cb238f692a8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (ImageInput, <a class="el" href="classcaffe2_1_1ImageInputOp.html">ImageInputOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:af5bf18ece7cf2c9bb50c5cb238f692a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7eded0041845df14bb24e2e9edd82cc"><td class="memTemplParams" colspan="2"><a id="ae7eded0041845df14bb24e2e9edd82cc"></a>
template&lt;typename T_IN , typename T_OUT , class Context &gt; </td></tr>
<tr class="memitem:ae7eded0041845df14bb24e2e9edd82cc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TransformOnGPU</b> (<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; Context &gt; &amp;X, <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; Context &gt; *Y, <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; Context &gt; &amp;mean, <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; Context &gt; &amp;std, Context *context)</td></tr>
<tr class="separator:ae7eded0041845df14bb24e2e9edd82cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5f57840ab96c4ec38c8831b662ba57"><td class="memItemLeft" align="right" valign="top"><a id="aad5f57840ab96c4ec38c8831b662ba57"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_CREATE_FUNCTION</b> (MKLDNN, EventCreateCPU)</td></tr>
<tr class="separator:aad5f57840ab96c4ec38c8831b662ba57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5aa0030e5fcb0b6c0f20ccb7ec49275"><td class="memItemLeft" align="right" valign="top"><a id="ab5aa0030e5fcb0b6c0f20ccb7ec49275"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_RECORD_FUNCTION</b> (MKLDNN, EventRecordCPU)</td></tr>
<tr class="separator:ab5aa0030e5fcb0b6c0f20ccb7ec49275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ac5594bb0068f68bda8863861d1144"><td class="memItemLeft" align="right" valign="top"><a id="a63ac5594bb0068f68bda8863861d1144"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (MKLDNN, MKLDNN, EventWaitCPUCPU)</td></tr>
<tr class="separator:a63ac5594bb0068f68bda8863861d1144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6addeaedf8705a1d9281ad40b743639a"><td class="memItemLeft" align="right" valign="top"><a id="a6addeaedf8705a1d9281ad40b743639a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (MKLDNN, CPU, EventWaitCPUCPU)</td></tr>
<tr class="separator:a6addeaedf8705a1d9281ad40b743639a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75caa31f34f4d11f311d9ca6401abd60"><td class="memItemLeft" align="right" valign="top"><a id="a75caa31f34f4d11f311d9ca6401abd60"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_WAIT_FUNCTION</b> (CPU, MKLDNN, EventWaitCPUCPU)</td></tr>
<tr class="separator:a75caa31f34f4d11f311d9ca6401abd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50411ff1422d82b4863deb6f4c616080"><td class="memItemLeft" align="right" valign="top"><a id="a50411ff1422d82b4863deb6f4c616080"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_FINISH_FUNCTION</b> (MKLDNN, EventFinishCPU)</td></tr>
<tr class="separator:a50411ff1422d82b4863deb6f4c616080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25685d648d88f77d9375c5a6a5b8a761"><td class="memItemLeft" align="right" valign="top"><a id="a25685d648d88f77d9375c5a6a5b8a761"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_QUERY_FUNCTION</b> (MKLDNN, EventQueryCPU)</td></tr>
<tr class="separator:a25685d648d88f77d9375c5a6a5b8a761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c813b5b1da377c7fbd761b5b75a690c"><td class="memItemLeft" align="right" valign="top"><a id="a8c813b5b1da377c7fbd761b5b75a690c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_ERROR_MESSAGE_FUNCTION</b> (MKLDNN, EventErrorMessageCPU)</td></tr>
<tr class="separator:a8c813b5b1da377c7fbd761b5b75a690c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede83d8b15b0a97818783031abf3ea8a"><td class="memItemLeft" align="right" valign="top"><a id="aede83d8b15b0a97818783031abf3ea8a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_SET_FINISHED_FUNCTION</b> (MKLDNN, EventSetFinishedCPU)</td></tr>
<tr class="separator:aede83d8b15b0a97818783031abf3ea8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76329d4e6074ba478dc9edd7fabd163e"><td class="memItemLeft" align="right" valign="top"><a id="a76329d4e6074ba478dc9edd7fabd163e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_EVENT_RESET_FUNCTION</b> (MKLDNN, EventResetCPU)</td></tr>
<tr class="separator:a76329d4e6074ba478dc9edd7fabd163e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1648d6337dc12709f38fc025a2fc2993"><td class="memItemLeft" align="right" valign="top"><a id="a1648d6337dc12709f38fc025a2fc2993"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_DECLARE_REGISTRY</b> (MKLOperatorRegistry, <a class="el" href="classcaffe2_1_1OperatorBase.html">OperatorBase</a>, const OperatorDef &amp;, <a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *)</td></tr>
<tr class="separator:a1648d6337dc12709f38fc025a2fc2993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a56c8772bdd2ef5e10e82e32a2812c"><td class="memItemLeft" align="right" valign="top"><a id="a00a56c8772bdd2ef5e10e82e32a2812c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>tryConvertToMPSCNN</b> (const NetDef &amp;initNet, const NetDef &amp;predictNet, NetDef *mpscnnPredictNet)</td></tr>
<tr class="separator:a00a56c8772bdd2ef5e10e82e32a2812c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf6374034df05c127ea22e3d824285b"><td class="memItemLeft" align="right" valign="top"><a id="abaf6374034df05c127ea22e3d824285b"></a>
NetDef&#160;</td><td class="memItemRight" valign="bottom"><b>annotateDefWithReadCounts</b> (const NetDef &amp;net)</td></tr>
<tr class="separator:abaf6374034df05c127ea22e3d824285b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a2fbd617c017bb2fd9f8e22b8aaf96"><td class="memItemLeft" align="right" valign="top"><a id="a57a2fbd617c017bb2fd9f8e22b8aaf96"></a>
NetDef&#160;</td><td class="memItemRight" valign="bottom"><b>rewriteForMetal</b> (const NetDef &amp;net)</td></tr>
<tr class="separator:a57a2fbd617c017bb2fd9f8e22b8aaf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2ebb0246dd4f78e67f3184b5690b0f"><td class="memItemLeft" align="right" valign="top"><a id="a7d2ebb0246dd4f78e67f3184b5690b0f"></a>
NetDef&#160;</td><td class="memItemRight" valign="bottom"><b>runMPSCNNFusion</b> (const NetDef &amp;net)</td></tr>
<tr class="separator:a7d2ebb0246dd4f78e67f3184b5690b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c02c3cd6007350fa5ba718046d4ecc"><td class="memItemLeft" align="right" valign="top"><a id="a53c02c3cd6007350fa5ba718046d4ecc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpDef</b> (const NetDef &amp;d)</td></tr>
<tr class="separator:a53c02c3cd6007350fa5ba718046d4ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254d6a74b0298a661e86c225705e39a6"><td class="memItemLeft" align="right" valign="top"><a id="a254d6a74b0298a661e86c225705e39a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>mpscnnRecordExecutionFinish</b> ()</td></tr>
<tr class="separator:a254d6a74b0298a661e86c225705e39a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe607097a57d84acd3ea177a85b7744"><td class="memItemLeft" align="right" valign="top"><a id="aabe607097a57d84acd3ea177a85b7744"></a>
<a class="el" href="structcaffe2_1_1MPSCNNContext.html">MPSCNNContext</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getMPSCNNContext</b> ()</td></tr>
<tr class="separator:aabe607097a57d84acd3ea177a85b7744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8ffd3689386b85c0d49a5200959f96"><td class="memItemLeft" align="right" valign="top"><a id="a9a8ffd3689386b85c0d49a5200959f96"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>tryConvertToMPSCNNIntermediateCopies</b> (const NetDef &amp;initNet, const NetDef &amp;predictNet, NetDef *mpscnnPredictNet)</td></tr>
<tr class="separator:a9a8ffd3689386b85c0d49a5200959f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc4186274961983247e54472fbeed42"><td class="memItemLeft" align="right" valign="top"><a id="a1fc4186274961983247e54472fbeed42"></a>
NetDef&#160;</td><td class="memItemRight" valign="bottom"><b>setSpecialArgs</b> (const NetDef &amp;def)</td></tr>
<tr class="separator:a1fc4186274961983247e54472fbeed42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8da6bdc5a7c0d551de725a92530fd56"><td class="memItemLeft" align="right" valign="top"><a id="ae8da6bdc5a7c0d551de725a92530fd56"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>testMPSCNN</b> ()</td></tr>
<tr class="separator:ae8da6bdc5a7c0d551de725a92530fd56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7065bb8848760071b8aa75997125eb"><td class="memItemLeft" align="right" valign="top"><a id="afe7065bb8848760071b8aa75997125eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>compareModels</b> (const NetDef &amp;initNet, NetDef predictNet)</td></tr>
<tr class="separator:afe7065bb8848760071b8aa75997125eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2a0d95be0f12114e4628c99cee76e6"><td class="memItemLeft" align="right" valign="top"><a id="aca2a0d95be0f12114e4628c99cee76e6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>verifyRewrite</b> (const NetDef &amp;initNet, const NetDef &amp;net, std::vector&lt; int &gt; inputDims)</td></tr>
<tr class="separator:aca2a0d95be0f12114e4628c99cee76e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a2cf95a76f857355e90cdc09f95891"><td class="memItemLeft" align="right" valign="top"><a id="a99a2cf95a76f857355e90cdc09f95891"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classGLImage.html">GLImage</a>&lt; float &gt;)</td></tr>
<tr class="separator:a99a2cf95a76f857355e90cdc09f95891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e0d8f3a1beb7c691f9dfa0a58fcd5f"><td class="memItemLeft" align="right" valign="top"><a id="ac2e0d8f3a1beb7c691f9dfa0a58fcd5f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classGLImage.html">GLImage</a>&lt; uint8_t &gt;)</td></tr>
<tr class="separator:ac2e0d8f3a1beb7c691f9dfa0a58fcd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86424036ce60f30d9d20148f0c047928"><td class="memItemLeft" align="right" valign="top"><a id="a86424036ce60f30d9d20148f0c047928"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classGLImageVector.html">GLImageVector</a>&lt; float &gt;)</td></tr>
<tr class="separator:a86424036ce60f30d9d20148f0c047928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d86246574e79c9704eef9a8b970c7ad"><td class="memItemLeft" align="right" valign="top"><a id="a4d86246574e79c9704eef9a8b970c7ad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classGLImageVector.html">GLImageVector</a>&lt; uint8_t &gt;)</td></tr>
<tr class="separator:a4d86246574e79c9704eef9a8b970c7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22af4c5c13ab6a949f0c243daa773e4d"><td class="memTemplParams" colspan="2"><a id="a22af4c5c13ab6a949f0c243daa773e4d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a22af4c5c13ab6a949f0c243daa773e4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>shareInputGLImage</b> (<a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *ws, const std::string &amp;name, <a class="el" href="classGLImageVector.html">GLImageVector</a>&lt; T &gt; *input)</td></tr>
<tr class="separator:a22af4c5c13ab6a949f0c243daa773e4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946e2544ac9ed60720014ec97e8f7dfe"><td class="memTemplParams" colspan="2"><a id="a946e2544ac9ed60720014ec97e8f7dfe"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a946e2544ac9ed60720014ec97e8f7dfe"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classGLImageVector.html">GLImageVector</a>&lt; T &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>extractOutputGLImage</b> (<a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *ws, const std::string &amp;name)</td></tr>
<tr class="separator:a946e2544ac9ed60720014ec97e8f7dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7774d202f45f941a142e798aeb4b4177"><td class="memItemLeft" align="right" valign="top"><a id="a7774d202f45f941a142e798aeb4b4177"></a>
const NetDef&#160;</td><td class="memItemRight" valign="bottom"><b>create_gl_run_net</b> (const NetDef &amp;init_net, const NetDef &amp;run_net, bool use_texture_input)</td></tr>
<tr class="separator:a7774d202f45f941a142e798aeb4b4177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae502118ed31ba84378019d9569a62dcf"><td class="memItemLeft" align="right" valign="top"><a id="ae502118ed31ba84378019d9569a62dcf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpDefForOpenGL</b> (const NetDef &amp;d)</td></tr>
<tr class="separator:ae502118ed31ba84378019d9569a62dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a425fe9208a6165ffab7cc3581c71157c"><td class="memItemLeft" align="right" valign="top"><a id="a425fe9208a6165ffab7cc3581c71157c"></a>
NetDef&#160;</td><td class="memItemRight" valign="bottom"><b>rewritePredictNetForOpenGL</b> (const NetDef &amp;predictNet, bool useTextureInput, bool useTiling, bool runFusion)</td></tr>
<tr class="separator:a425fe9208a6165ffab7cc3581c71157c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bac729318dc5966ec85348fe2fa28c1"><td class="memItemLeft" align="right" valign="top"><a id="a3bac729318dc5966ec85348fe2fa28c1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>tryConvertToOpenGL</b> (const NetDef &amp;initNet, const NetDef &amp;predictNet, NetDef *glPredictNet, bool useTextureInput, bool useTiling, bool runFusion)</td></tr>
<tr class="separator:a3bac729318dc5966ec85348fe2fa28c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa69d25c92bdc206d54f93e015242ec"><td class="memItemLeft" align="right" valign="top"><a id="a8fa69d25c92bdc206d54f93e015242ec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLAdd, <a class="el" href="classcaffe2_1_1OpenGLAddOp.html">OpenGLAddOp</a>&lt; float16_t &gt;)</td></tr>
<tr class="separator:a8fa69d25c92bdc206d54f93e015242ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac503c8115c51b1e6bc931e6e325bd2d"><td class="memItemLeft" align="right" valign="top"><a id="aac503c8115c51b1e6bc931e6e325bd2d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLAdd).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:aac503c8115c51b1e6bc931e6e325bd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb598c792a818003b2fe7598f7a35b48"><td class="memItemLeft" align="right" valign="top"><a id="abb598c792a818003b2fe7598f7a35b48"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLConcat, <a class="el" href="classcaffe2_1_1OpenGLConcatOp.html">OpenGLConcatOp</a>&lt; float16_t &gt;)</td></tr>
<tr class="separator:abb598c792a818003b2fe7598f7a35b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7259cc186a8e3fea8ffe3ae5e89304fa"><td class="memItemLeft" align="right" valign="top"><a id="a7259cc186a8e3fea8ffe3ae5e89304fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLConcat).NumInputs(2</td></tr>
<tr class="separator:a7259cc186a8e3fea8ffe3ae5e89304fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d96236d525905b458d20436496cad0a"><td class="memItemLeft" align="right" valign="top"><a id="a5d96236d525905b458d20436496cad0a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumOutputs</b> (1, 2)</td></tr>
<tr class="separator:a5d96236d525905b458d20436496cad0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562fa1d1b3aecd145a748e9876959ae3"><td class="memItemLeft" align="right" valign="top"><a id="a562fa1d1b3aecd145a748e9876959ae3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLConv, <a class="el" href="classcaffe2_1_1OpenGLConvOp.html">OpenGLConvOp</a>&lt; float16_t, false, false &gt;)</td></tr>
<tr class="separator:a562fa1d1b3aecd145a748e9876959ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c1739927bd8cc4d4a11d04fac9dabf"><td class="memItemLeft" align="right" valign="top"><a id="a51c1739927bd8cc4d4a11d04fac9dabf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLConv).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a51c1739927bd8cc4d4a11d04fac9dabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad2045895ce9d95d60bbea96df21bb2"><td class="memItemLeft" align="right" valign="top"><a id="a4ad2045895ce9d95d60bbea96df21bb2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLConvPRelu, <a class="el" href="classcaffe2_1_1OpenGLConvOp.html">OpenGLConvOp</a>&lt; float16_t, true, false &gt;)</td></tr>
<tr class="separator:a4ad2045895ce9d95d60bbea96df21bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78cf3a0839b9488b42ab00693fcfeee8"><td class="memItemLeft" align="right" valign="top"><a id="a78cf3a0839b9488b42ab00693fcfeee8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLConvPRelu).NumInputs(4).NumOutputs(1)</td></tr>
<tr class="separator:a78cf3a0839b9488b42ab00693fcfeee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d657640db149a91e4f7829f0086c6c"><td class="memItemLeft" align="right" valign="top"><a id="af9d657640db149a91e4f7829f0086c6c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLConvRelu, <a class="el" href="classcaffe2_1_1OpenGLConvOp.html">OpenGLConvOp</a>&lt; float16_t, false, true &gt;)</td></tr>
<tr class="separator:af9d657640db149a91e4f7829f0086c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0add19f11967be79c4415381da49b52"><td class="memItemLeft" align="right" valign="top"><a id="ad0add19f11967be79c4415381da49b52"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLConvRelu).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:ad0add19f11967be79c4415381da49b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e15f142efc741d54222e1e3d6bc418"><td class="memItemLeft" align="right" valign="top"><a id="a28e15f142efc741d54222e1e3d6bc418"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLConvTranspose, <a class="el" href="classcaffe2_1_1OpenGLConvTransposeOp.html">OpenGLConvTransposeOp</a>&lt; float16_t, false, false &gt;)</td></tr>
<tr class="separator:a28e15f142efc741d54222e1e3d6bc418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa3f1031549623196fce3ff7565e423"><td class="memItemLeft" align="right" valign="top"><a id="adfa3f1031549623196fce3ff7565e423"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLConvTranspose).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:adfa3f1031549623196fce3ff7565e423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c209443a8d642c0fc92e75cc804928"><td class="memItemLeft" align="right" valign="top"><a id="a33c209443a8d642c0fc92e75cc804928"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLConvTransposePRelu, <a class="el" href="classcaffe2_1_1OpenGLConvTransposeOp.html">OpenGLConvTransposeOp</a>&lt; float16_t, true, false &gt;)</td></tr>
<tr class="separator:a33c209443a8d642c0fc92e75cc804928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1da6ad91c8f87c2d4cf609bb8a3bf77"><td class="memItemLeft" align="right" valign="top"><a id="ad1da6ad91c8f87c2d4cf609bb8a3bf77"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLConvTransposePRelu).NumInputs(4).NumOutputs(1)</td></tr>
<tr class="separator:ad1da6ad91c8f87c2d4cf609bb8a3bf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d119683748f90eb85a7f46aed6c3ddb"><td class="memItemLeft" align="right" valign="top"><a id="a8d119683748f90eb85a7f46aed6c3ddb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLConvTransposeRelu, <a class="el" href="classcaffe2_1_1OpenGLConvTransposeOp.html">OpenGLConvTransposeOp</a>&lt; float16_t, false, true &gt;)</td></tr>
<tr class="separator:a8d119683748f90eb85a7f46aed6c3ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75bc896f55316263a6d782fc025c7137"><td class="memItemLeft" align="right" valign="top"><a id="a75bc896f55316263a6d782fc025c7137"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLConvTransposeRelu).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a75bc896f55316263a6d782fc025c7137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa363487eded29eb0f06b5c928ade9df2"><td class="memItemLeft" align="right" valign="top"><a id="aa363487eded29eb0f06b5c928ade9df2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CopyToOpenGL, <a class="el" href="classcaffe2_1_1CopyToOpenGLOp.html">CopyToOpenGLOp</a>&lt; float16_t &gt;)</td></tr>
<tr class="separator:aa363487eded29eb0f06b5c928ade9df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bf24e83e4f4f37694662f44f8151f9"><td class="memItemLeft" align="right" valign="top"><a id="ab4bf24e83e4f4f37694662f44f8151f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (CopyToOpenGL).NumInputs(1).NumOutputs(1).AllowInplace(</td></tr>
<tr class="separator:ab4bf24e83e4f4f37694662f44f8151f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d8f4dc048d68f62ba6fdaeedee2736"><td class="memItemLeft" align="right" valign="top"><a id="a39d8f4dc048d68f62ba6fdaeedee2736"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CopyFromOpenGL, <a class="el" href="classcaffe2_1_1CopyFromOpenGLOp.html">CopyFromOpenGLOp</a>&lt; float16_t &gt;)</td></tr>
<tr class="separator:a39d8f4dc048d68f62ba6fdaeedee2736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3fc06fc4dd0145ccb12419c550bebe"><td class="memItemLeft" align="right" valign="top"><a id="aca3fc06fc4dd0145ccb12419c550bebe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (CopyFromOpenGL).NumInputs(1).NumOutputs(1).AllowInplace(</td></tr>
<tr class="separator:aca3fc06fc4dd0145ccb12419c550bebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfe142c3cb36f0a70b779287945f670"><td class="memItemLeft" align="right" valign="top"><a id="a8cfe142c3cb36f0a70b779287945f670"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLInstanceNorm, <a class="el" href="classcaffe2_1_1OpenGLInstanceNormPReluOp.html">OpenGLInstanceNormPReluOp</a>&lt; float16_t, false &gt;)</td></tr>
<tr class="separator:a8cfe142c3cb36f0a70b779287945f670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4289a874d297611523bd4c04ecb10877"><td class="memItemLeft" align="right" valign="top"><a id="a4289a874d297611523bd4c04ecb10877"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLInstanceNorm).NumInputs(3</td></tr>
<tr class="separator:a4289a874d297611523bd4c04ecb10877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580cf546fcf6cd1e7c13ac155133bc9d"><td class="memItemLeft" align="right" valign="top"><a id="a580cf546fcf6cd1e7c13ac155133bc9d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumOutputs</b> (1, 3).AllowInplace(</td></tr>
<tr class="separator:a580cf546fcf6cd1e7c13ac155133bc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac848e90af32b50f0b74713fb21bd3418"><td class="memItemLeft" align="right" valign="top"><a id="ac848e90af32b50f0b74713fb21bd3418"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLInstanceNormPRelu, <a class="el" href="classcaffe2_1_1OpenGLInstanceNormPReluOp.html">OpenGLInstanceNormPReluOp</a>&lt; float16_t, true &gt;)</td></tr>
<tr class="separator:ac848e90af32b50f0b74713fb21bd3418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af265eb801817a89e95cfdf2bcd50060e"><td class="memItemLeft" align="right" valign="top"><a id="af265eb801817a89e95cfdf2bcd50060e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLInstanceNormPRelu).NumInputs(3</td></tr>
<tr class="separator:af265eb801817a89e95cfdf2bcd50060e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f43f45f6bb3648bad73ad3e368def9f"><td class="memItemLeft" align="right" valign="top"><a id="a9f43f45f6bb3648bad73ad3e368def9f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLMul, <a class="el" href="classcaffe2_1_1OpenGLMulOp.html">OpenGLMulOp</a>&lt; float16_t &gt;)</td></tr>
<tr class="separator:a9f43f45f6bb3648bad73ad3e368def9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2201ae75277f0e4f5ae0ce44723c9737"><td class="memItemLeft" align="right" valign="top"><a id="a2201ae75277f0e4f5ae0ce44723c9737"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLNormalizePlanarYUV, <a class="el" href="classcaffe2_1_1GLNormPlanarYUVOp.html">GLNormPlanarYUVOp</a>&lt; float16_t &gt;)</td></tr>
<tr class="separator:a2201ae75277f0e4f5ae0ce44723c9737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020b264d6e1e86aa95b13656a48317df"><td class="memItemLeft" align="right" valign="top"><a id="a020b264d6e1e86aa95b13656a48317df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLNormalizePlanarYUV).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a020b264d6e1e86aa95b13656a48317df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c70979d0aa56f1ef9ff6cb244adbe1"><td class="memItemLeft" align="right" valign="top"><a id="a79c70979d0aa56f1ef9ff6cb244adbe1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLPadImage, <a class="el" href="classcaffe2_1_1OpenGLPadImageOp.html">OpenGLPadImageOp</a>&lt; float16_t &gt;)</td></tr>
<tr class="separator:a79c70979d0aa56f1ef9ff6cb244adbe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57421b025505171908ebfe80f178d659"><td class="memItemLeft" align="right" valign="top"><a id="a57421b025505171908ebfe80f178d659"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLPadImage).NumInputs(1).NumOutputs(1)</td></tr>
<tr class="separator:a57421b025505171908ebfe80f178d659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b69735cb72b492e71a1f58b99212fd0"><td class="memItemLeft" align="right" valign="top"><a id="a4b69735cb72b492e71a1f58b99212fd0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLPRelu, <a class="el" href="classcaffe2_1_1OpenGLPReluOp.html">OpenGLPReluOp</a>&lt; float16_t, GLPRelu::PRelu &gt;)</td></tr>
<tr class="separator:a4b69735cb72b492e71a1f58b99212fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae721966f8a4a41ea13ac717698e09672"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>IdenticalTypeAndShape</b> ()</td></tr>
<tr class="separator:ae721966f8a4a41ea13ac717698e09672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d6c2004e74e840211e4683dc49b8b9"><td class="memItemLeft" align="right" valign="top"><a id="a75d6c2004e74e840211e4683dc49b8b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLRelu, <a class="el" href="classcaffe2_1_1OpenGLPReluOp.html">OpenGLPReluOp</a>&lt; float16_t, GLPRelu::Relu &gt;)</td></tr>
<tr class="separator:a75d6c2004e74e840211e4683dc49b8b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fea477f80d5d4fc55c85ee2eedb8ae"><td class="memItemLeft" align="right" valign="top"><a id="a09fea477f80d5d4fc55c85ee2eedb8ae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLResizeNearest, <a class="el" href="classcaffe2_1_1OpenGLResizeNearestOp.html">OpenGLResizeNearestOp</a>&lt; float16_t &gt;)</td></tr>
<tr class="separator:a09fea477f80d5d4fc55c85ee2eedb8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4dbf7c5141481ca02000bf28d62722"><td class="memItemLeft" align="right" valign="top"><a id="adc4dbf7c5141481ca02000bf28d62722"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLResizeNearest).NumInputs(1).NumOutputs(1)</td></tr>
<tr class="separator:adc4dbf7c5141481ca02000bf28d62722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ffa85e4742fa013131a47992d0ff445"><td class="memItemLeft" align="right" valign="top"><a id="a9ffa85e4742fa013131a47992d0ff445"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLSigmoid, <a class="el" href="classcaffe2_1_1OpenGLSigmoidOp.html">OpenGLSigmoidOp</a>&lt; float16_t, Sigmoid &gt;)</td></tr>
<tr class="separator:a9ffa85e4742fa013131a47992d0ff445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f44e83e8259ab5784562b854267df7"><td class="memItemLeft" align="right" valign="top"><a id="a55f44e83e8259ab5784562b854267df7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLTanh, <a class="el" href="classcaffe2_1_1OpenGLSigmoidOp.html">OpenGLSigmoidOp</a>&lt; float16_t, Tanh &gt;)</td></tr>
<tr class="separator:a55f44e83e8259ab5784562b854267df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6fb086ff5a2ad3f989cd803282f9f5"><td class="memItemLeft" align="right" valign="top"><a id="a3b6fb086ff5a2ad3f989cd803282f9f5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLTensorToTextureStylizerPreprocess, <a class="el" href="classcaffe2_1_1OpenGLTensorToTextureStylizerPreprocessOp.html">OpenGLTensorToTextureStylizerPreprocessOp</a>)</td></tr>
<tr class="separator:a3b6fb086ff5a2ad3f989cd803282f9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb2489f195c89f24b58a2e6152afa51"><td class="memItemLeft" align="right" valign="top"><a id="a1eb2489f195c89f24b58a2e6152afa51"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLTensorToTextureStylizerPreprocess).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a1eb2489f195c89f24b58a2e6152afa51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c16cd185a74811c285d02af042e26e"><td class="memItemLeft" align="right" valign="top"><a id="a19c16cd185a74811c285d02af042e26e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLTextureToTextureStylizerPreprocess, <a class="el" href="classcaffe2_1_1OpenGLTextureToTextureStylizerPreprocessOp.html">OpenGLTextureToTextureStylizerPreprocessOp</a>&lt; RGBA &gt;)</td></tr>
<tr class="separator:a19c16cd185a74811c285d02af042e26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68cba7375a7c56f6f13a3db03b735130"><td class="memItemLeft" align="right" valign="top"><a id="a68cba7375a7c56f6f13a3db03b735130"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLTextureToTextureStylizerPreprocess).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a68cba7375a7c56f6f13a3db03b735130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55c452e50850da2f77991d9434f80ba"><td class="memItemLeft" align="right" valign="top"><a id="ab55c452e50850da2f77991d9434f80ba"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLTextureToTensorStylizerDeprocess, <a class="el" href="classcaffe2_1_1OpenGLTextureToTensorStylizerDeprocessOp.html">OpenGLTextureToTensorStylizerDeprocessOp</a>)</td></tr>
<tr class="separator:ab55c452e50850da2f77991d9434f80ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb16d0b59b3c2b976968999e9462ff46"><td class="memItemLeft" align="right" valign="top"><a id="acb16d0b59b3c2b976968999e9462ff46"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLTextureToTensorStylizerDeprocess).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:acb16d0b59b3c2b976968999e9462ff46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1b784c4bdb68699acb802a343f2384"><td class="memItemLeft" align="right" valign="top"><a id="afd1b784c4bdb68699acb802a343f2384"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLTextureToTextureStylizerDeprocess, <a class="el" href="classcaffe2_1_1OpenGLTextureToTextureStylizerDeprocessOp.html">OpenGLTextureToTextureStylizerDeprocessOp</a>&lt; RGBA &gt;)</td></tr>
<tr class="separator:afd1b784c4bdb68699acb802a343f2384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92cdda1b3754f19e5772a851d13cfda9"><td class="memItemLeft" align="right" valign="top"><a id="a92cdda1b3754f19e5772a851d13cfda9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLTextureToTextureStylizerDeprocess).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a92cdda1b3754f19e5772a851d13cfda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2fdf45d7817bd5874faf40f185e580"><td class="memItemLeft" align="right" valign="top"><a id="a3e2fdf45d7817bd5874faf40f185e580"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OpenGLSub, <a class="el" href="classcaffe2_1_1OpenGLSubOp.html">OpenGLSubOp</a>&lt; float16_t &gt;)</td></tr>
<tr class="separator:a3e2fdf45d7817bd5874faf40f185e580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af546d56314eecef6baa0cc93385ef46d"><td class="memItemLeft" align="right" valign="top"><a id="af546d56314eecef6baa0cc93385ef46d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (OpenGLSub).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:af546d56314eecef6baa0cc93385ef46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf0a4d8c3d3b32bc845b2624cc369fd"><td class="memItemLeft" align="right" valign="top"><a id="accf0a4d8c3d3b32bc845b2624cc369fd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>testOpenGL</b> ()</td></tr>
<tr class="separator:accf0a4d8c3d3b32bc845b2624cc369fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc451d7ad7ba65fd324bf5ae114499e"><td class="memItemLeft" align="right" valign="top"><a id="a5bc451d7ad7ba65fd324bf5ae114499e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>compareModelsForOpenGL</b> (std::string name, const NetDef &amp;initNet, NetDef predictNet, int width, int height, int channel, std::string input_type, std::string input_order)</td></tr>
<tr class="separator:a5bc451d7ad7ba65fd324bf5ae114499e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f1ee5453d7f449564ec3e970596334"><td class="memItemLeft" align="right" valign="top"><a id="a28f1ee5453d7f449564ec3e970596334"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>compareBatchedToTiledModels</b> (std::string name, const NetDef &amp;initNet, NetDef predictNet, int width, int height, int channel, std::string input_type, std::string input_order)</td></tr>
<tr class="separator:a28f1ee5453d7f449564ec3e970596334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2165da55a2a3eaf378664b82975a72"><td class="memItemLeft" align="right" valign="top"><a id="a3a2165da55a2a3eaf378664b82975a72"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>runModelBenchmarks</b> (caffe2::NetDef &amp;init_net, caffe2::NetDef &amp;predict_net, int warm_up_runs, int main_runs, int channel, int height, int width, std::string input_type, std::string input_order, std::string engine, bool run_individual=false, bool use_texture_input=false, bool use_tiling=false, bool run_fusion=true)</td></tr>
<tr class="separator:a3a2165da55a2a3eaf378664b82975a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2457b3242eeca40cf4f65e6cb0b75d20"><td class="memItemLeft" align="right" valign="top"><a id="a2457b3242eeca40cf4f65e6cb0b75d20"></a>
std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>gSNPELocation</b> ()</td></tr>
<tr class="separator:a2457b3242eeca40cf4f65e6cb0b75d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade211aa656d7303d830b20fe176f9346"><td class="memItemLeft" align="right" valign="top"><a id="ade211aa656d7303d830b20fe176f9346"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SNPE, <a class="el" href="classcaffe2_1_1SNPEOp.html">SNPEOp</a>)</td></tr>
<tr class="separator:ade211aa656d7303d830b20fe176f9346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858eac856ff7f62c769e23ddb9af406b"><td class="memItemLeft" align="right" valign="top"><a id="a858eac856ff7f62c769e23ddb9af406b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>uniformQuantize2b1b</b> (const <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> &amp;X, const std::vector&lt; std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> &gt;&gt; &amp;XQ, float offset, float inter_center_distance)</td></tr>
<tr class="separator:a858eac856ff7f62c769e23ddb9af406b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1476ad461eaf378d7917e80bce3edb09"><td class="memItemLeft" align="right" valign="top"><a id="a1476ad461eaf378d7917e80bce3edb09"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>qconv</b> (const <a class="el" href="structcaffe2_1_1ConvArgs.html">ConvArgs</a> &amp;args, const <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> &amp;X, const <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> &amp;W, const <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> *b, <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> *Y)</td></tr>
<tr class="separator:a1476ad461eaf378d7917e80bce3edb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17277f2033ff1b4578c1864754c1054"><td class="memItemLeft" align="right" valign="top"><a id="ad17277f2033ff1b4578c1864754c1054"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>qpad_zero</b> (const <a class="el" href="structcaffe2_1_1ConvArgs.html">ConvArgs</a> &amp;args, const <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> &amp;X, <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> *Y)</td></tr>
<tr class="separator:ad17277f2033ff1b4578c1864754c1054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708c5c82f39bd355506a0d5e89422bb5"><td class="memItemLeft" align="right" valign="top"><a id="a708c5c82f39bd355506a0d5e89422bb5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>signQuantize</b> (const <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> &amp;X, <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> *XQ)</td></tr>
<tr class="separator:a708c5c82f39bd355506a0d5e89422bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3400d9dcadd25caed54ad3942ff62493"><td class="memItemLeft" align="right" valign="top"><a id="a3400d9dcadd25caed54ad3942ff62493"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>filterNormalization11</b> (const <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> &amp;WQ, <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> *WQN)</td></tr>
<tr class="separator:a3400d9dcadd25caed54ad3942ff62493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197ad7509c858d29fc1bf80dc3b9ec92"><td class="memItemLeft" align="right" valign="top"><a id="a197ad7509c858d29fc1bf80dc3b9ec92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>filterNormalizationL1</b> (const <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> &amp;W, <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> *WL1)</td></tr>
<tr class="separator:a197ad7509c858d29fc1bf80dc3b9ec92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba550b3a9c6fd24a91ad9a114f1bb788"><td class="memItemLeft" align="right" valign="top"><a id="aba550b3a9c6fd24a91ad9a114f1bb788"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>qim2col</b> (const <a class="el" href="structcaffe2_1_1ConvArgs.html">ConvArgs</a> &amp;args, const <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> &amp;XQ, const <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> &amp;WQ, <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> *XQcol)</td></tr>
<tr class="separator:aba550b3a9c6fd24a91ad9a114f1bb788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082c6d0b3cd4fd632e1287358b7d34fe"><td class="memItemLeft" align="right" valign="top"><a id="a082c6d0b3cd4fd632e1287358b7d34fe"></a>
std::unique_ptr&lt; <a class="el" href="structcaffe2_1_1QConvState.html">QConvState</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>create2b1bConvState</b> (<a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *ws, const <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> &amp;W, const <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> *b)</td></tr>
<tr class="separator:a082c6d0b3cd4fd632e1287358b7d34fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c829fb3b775c8790d3ef0419d6a731"><td class="memItemLeft" align="right" valign="top"><a id="a94c829fb3b775c8790d3ef0419d6a731"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>run2b1bConvGeneric</b> (<a class="el" href="structcaffe2_1_1QConvState.html">QConvState</a> *state, const <a class="el" href="structcaffe2_1_1ConvArgs.html">ConvArgs</a> &amp;args, const <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> &amp;X, <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> *Y)</td></tr>
<tr class="separator:a94c829fb3b775c8790d3ef0419d6a731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b77566807b3576fa21053ba071c114a"><td class="memItemLeft" align="right" valign="top"><a id="a3b77566807b3576fa21053ba071c114a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>run2b1bUnification</b> (<a class="el" href="structcaffe2_1_1QConvState.html">QConvState</a> *state, size_t N, size_t C, const float *WQNVdata, const float *YQs0Vdata, const float *YQs1Vdata, size_t YQstride, float *Ydata, size_t Ystride, const float *bias)</td></tr>
<tr class="separator:a3b77566807b3576fa21053ba071c114a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8246b69b4a3b8c68c512cafd006df397"><td class="memItemLeft" align="right" valign="top"><a id="a8246b69b4a3b8c68c512cafd006df397"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (QConv, <a class="el" href="classcaffe2_1_1QConvOp.html">QConvOp</a>)</td></tr>
<tr class="separator:a8246b69b4a3b8c68c512cafd006df397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac67d9a6a97914fb3a6c54045667b004"><td class="memItemLeft" align="right" valign="top"><a id="aac67d9a6a97914fb3a6c54045667b004"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>divRoundUp</b> (size_t x, size_t d)</td></tr>
<tr class="separator:aac67d9a6a97914fb3a6c54045667b004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88af923ed6cef1948561dc4d24d9c9f"><td class="memItemLeft" align="right" valign="top"><a id="ab88af923ed6cef1948561dc4d24d9c9f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>run2b1bConvNeon</b> (<a class="el" href="structcaffe2_1_1QConvState.html">QConvState</a> *state, const <a class="el" href="structcaffe2_1_1ConvArgs.html">ConvArgs</a> &amp;args, const <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> &amp;X, <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> *Y)</td></tr>
<tr class="separator:ab88af923ed6cef1948561dc4d24d9c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff22675a2de1f5235fc243775d19dbfd"><td class="memItemLeft" align="right" valign="top"><a id="aff22675a2de1f5235fc243775d19dbfd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classcaffe2_1_1MPICommonWorldWrapper.html">MPICommonWorldWrapper</a>)</td></tr>
<tr class="separator:aff22675a2de1f5235fc243775d19dbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bee4c02cf9a7fdb6868b05b8cd41df5"><td class="memItemLeft" align="right" valign="top"><a id="a8bee4c02cf9a7fdb6868b05b8cd41df5"></a>
std::mutex &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>MPIMutex</b> ()</td></tr>
<tr class="separator:a8bee4c02cf9a7fdb6868b05b8cd41df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca313bd69abda6cc82792348e1d64cc1"><td class="memItemLeft" align="right" valign="top">MPI_Comm&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#aca313bd69abda6cc82792348e1d64cc1">GlobalMPIComm</a> ()</td></tr>
<tr class="memdesc:aca313bd69abda6cc82792348e1d64cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the global MPI communicator used by Caffe2.  <a href="#aca313bd69abda6cc82792348e1d64cc1">More...</a><br /></td></tr>
<tr class="separator:aca313bd69abda6cc82792348e1d64cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eaa1a07583fa2d94c3e66a7496f4790"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a1eaa1a07583fa2d94c3e66a7496f4790">SetGlobalMPIComm</a> (MPI_Comm new_comm)</td></tr>
<tr class="memdesc:a1eaa1a07583fa2d94c3e66a7496f4790"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the global MPI communicator.  <a href="#a1eaa1a07583fa2d94c3e66a7496f4790">More...</a><br /></td></tr>
<tr class="separator:a1eaa1a07583fa2d94c3e66a7496f4790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395b8f7fc95f3e07aa97c327c7bb73a0"><td class="memItemLeft" align="right" valign="top"><a id="a395b8f7fc95f3e07aa97c327c7bb73a0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a395b8f7fc95f3e07aa97c327c7bb73a0">MPICommSize</a> (MPI_Comm comm)</td></tr>
<tr class="memdesc:a395b8f7fc95f3e07aa97c327c7bb73a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to return the size of the given communicator. <br /></td></tr>
<tr class="separator:a395b8f7fc95f3e07aa97c327c7bb73a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b5d7b216271612f282cb791533d010"><td class="memItemLeft" align="right" valign="top"><a id="ad7b5d7b216271612f282cb791533d010"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#ad7b5d7b216271612f282cb791533d010">MPICommRank</a> (MPI_Comm comm)</td></tr>
<tr class="memdesc:ad7b5d7b216271612f282cb791533d010"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper function to return the rank of the given communicator. <br /></td></tr>
<tr class="separator:ad7b5d7b216271612f282cb791533d010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc2404153d4045abf87562f016a7fa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a4dc2404153d4045abf87562f016a7fa4">MPISetupPeers</a> (const int replicas, const string &amp;role, const string &amp;job_path)</td></tr>
<tr class="memdesc:a4dc2404153d4045abf87562f016a7fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function used to perform peer setup so one does not need to use mpirun / mpiexec to run the binary.  <a href="#a4dc2404153d4045abf87562f016a7fa4">More...</a><br /></td></tr>
<tr class="separator:a4dc2404153d4045abf87562f016a7fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3f85d0b09bfde9dc265180f24bf01a"><td class="memItemLeft" align="right" valign="top"><a id="a9f3f85d0b09bfde9dc265180f24bf01a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CheckInitializedMPI</b> ()</td></tr>
<tr class="separator:a9f3f85d0b09bfde9dc265180f24bf01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a803b9c936189ddd9e0597b57dcae8a8b"><td class="memItemLeft" align="right" valign="top"><a id="a803b9c936189ddd9e0597b57dcae8a8b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Abs, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1AbsCPUFunctor.html">AbsCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:a803b9c936189ddd9e0597b57dcae8a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311e9893af99362096e094fa669b23d0"><td class="memItemLeft" align="right" valign="top"><a id="a311e9893af99362096e094fa669b23d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AbsGradient, <a class="el" href="classcaffe2_1_1BinaryElementwiseOp.html">BinaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1WithoutBroadcast.html">WithoutBroadcast</a>&lt; <a class="el" href="structcaffe2_1_1AbsGradientCPUFunctor.html">AbsGradientCPUFunctor</a> &gt;&gt;)</td></tr>
<tr class="separator:a311e9893af99362096e094fa669b23d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595402ec02d4152b5a8cf8804bd75a35"><td class="memItemLeft" align="right" valign="top"><a id="a595402ec02d4152b5a8cf8804bd75a35"></a>
element wise DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;input&quot;, &quot;Input tensor&quot;) .Output(0</td></tr>
<tr class="separator:a595402ec02d4152b5a8cf8804bd75a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5b6698cbdefdc707ad876a1cf28b34"><td class="memItemLeft" align="right" valign="top"><a id="acf5b6698cbdefdc707ad876a1cf28b34"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (AbsGradient).NumInputs(2).NumOutputs(1).IdenticalTypeAndShape()</td></tr>
<tr class="separator:acf5b6698cbdefdc707ad876a1cf28b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bf41d31992d47858547cd42193c8964"><td class="memItemLeft" align="right" valign="top"><a id="a4bf41d31992d47858547cd42193c8964"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Abs, <a class="el" href="classcaffe2_1_1GetAbsGradient.html">GetAbsGradient</a>)</td></tr>
<tr class="separator:a4bf41d31992d47858547cd42193c8964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df747d59995127f18ad03be32131e9d"><td class="memItemLeft" align="right" valign="top"><a id="a0df747d59995127f18ad03be32131e9d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Accumulate, <a class="el" href="classcaffe2_1_1AccumulateOp.html">AccumulateOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a0df747d59995127f18ad03be32131e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef89da8eec4e32dce0a3695f7ff9b00"><td class="memItemLeft" align="right" valign="top"><a id="a2ef89da8eec4e32dce0a3695f7ff9b00"></a>
we first initialize the output tensor to all and then do accumulation Any further calls to the&#160;</td><td class="memItemRight" valign="bottom"><b>operator, given that no one else fiddles with the output in the interim, will do simple accumulations. Accumulation is done using Axpby operation as shown:Y=1 *X+gamma *Y where X is the input tensor, Y is the output tensor and gamma is the multiplier argument.) DOC&quot;) .Arg</b> (&quot;gamma&quot;, &quot;(float, default 1.0) Accumulation multiplier&quot;) .Input(0</td></tr>
<tr class="separator:a2ef89da8eec4e32dce0a3695f7ff9b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bb84f815eb7f900bb1893980cd47f4"><td class="memItemLeft" align="right" valign="top"><a id="a25bb84f815eb7f900bb1893980cd47f4"></a>
we first initialize the output tensor to all and then do accumulation Any further calls to the The input tensor that has to be accumulated to the output tensor If the output size is not the same as input the output tensor is first reshaped and initialized to and only accumulation is done&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;output&quot;, &quot;Accumulated output tensor&quot;)</td></tr>
<tr class="separator:a25bb84f815eb7f900bb1893980cd47f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e78bc14e4f415df7ecbd5dc021f364a"><td class="memItemLeft" align="right" valign="top"><a id="a9e78bc14e4f415df7ecbd5dc021f364a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Accumulate)</td></tr>
<tr class="separator:a9e78bc14e4f415df7ecbd5dc021f364a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226a3949dd6bbe06e017eda3bd9c7871"><td class="memItemLeft" align="right" valign="top"><a id="a226a3949dd6bbe06e017eda3bd9c7871"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Accuracy, <a class="el" href="classcaffe2_1_1AccuracyOp.html">AccuracyOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a226a3949dd6bbe06e017eda3bd9c7871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade465a1be9535ecde85ef986fd6433d4"><td class="memItemLeft" align="right" valign="top"><a id="ade465a1be9535ecde85ef986fd6433d4"></a>
NumInputs(2) .NumOutputs(1) .ScalarType(TensorProto&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Accuracy)</td></tr>
<tr class="separator:ade465a1be9535ecde85ef986fd6433d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1935fbf87dd5962a9730b559808baa0"><td class="memItemLeft" align="right" valign="top"><a id="ab1935fbf87dd5962a9730b559808baa0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Assert, <a class="el" href="classcaffe2_1_1AssertOp.html">AssertOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab1935fbf87dd5962a9730b559808baa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50526dec994e9ac82f4caf91faa4fdad"><td class="memItemLeft" align="right" valign="top"><a id="a50526dec994e9ac82f4caf91faa4fdad"></a>
or long longs and checks if all values are true when coerced into a boolean In other for non bool types this asserts that all values in the tensor are non zero DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;error_msg&quot;, &quot;An error message to print when the assert fails.&quot;, false)</td></tr>
<tr class="separator:a50526dec994e9ac82f4caf91faa4fdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28b63bd573fb8ac2c243c9f1d158fe9"><td class="memItemLeft" align="right" valign="top"><a id="ae28b63bd573fb8ac2c243c9f1d158fe9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BatchGather, <a class="el" href="classcaffe2_1_1BatchGatherOp.html">BatchGatherOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae28b63bd573fb8ac2c243c9f1d158fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded54ac490ac9528615bf2da79a8a93c"><td class="memItemLeft" align="right" valign="top"><a id="aded54ac490ac9528615bf2da79a8a93c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BatchGatherGradient, <a class="el" href="classcaffe2_1_1BatchGatherGradientOp.html">BatchGatherGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aded54ac490ac9528615bf2da79a8a93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75aacceae79778892366c1475e3a6e44"><td class="memItemLeft" align="right" valign="top"><a id="a75aacceae79778892366c1475e3a6e44"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (2) .NumOutputs(1) .TensorInferenceFunction([](const OperatorDef &amp;def</td></tr>
<tr class="separator:a75aacceae79778892366c1475e3a6e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7b4cc9e95fa3d06364db3448f7efd7"><td class="memItemLeft" align="right" valign="top"><a id="a9b7b4cc9e95fa3d06364db3448f7efd7"></a>
output_dims&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (data_dims[0])</td></tr>
<tr class="separator:a9b7b4cc9e95fa3d06364db3448f7efd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8886922a57252e67c2d3f9a0d6adb45"><td class="memItemLeft" align="right" valign="top"><a id="af8886922a57252e67c2d3f9a0d6adb45"></a>
output_dims&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (output_dims.end(), indices_dims.begin(), indices_dims.end())</td></tr>
<tr class="separator:af8886922a57252e67c2d3f9a0d6adb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c60dd54c505c4eeeffd3e0db7165f0b"><td class="memItemLeft" align="right" valign="top"><a id="a5c60dd54c505c4eeeffd3e0db7165f0b"></a>
output_dims&#160;</td><td class="memItemRight" valign="bottom"><b>insert</b> (output_dims.end(), data_dims.begin()+2, data_dims.end())</td></tr>
<tr class="separator:a5c60dd54c505c4eeeffd3e0db7165f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ddeb38db7e5325f8d430c2e0f28981"><td class="memItemLeft" align="right" valign="top"><a id="af6ddeb38db7e5325f8d430c2e0f28981"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Batch gather operation, first dimension in DATA is the batch size.
Given DATA tensor of rank r &gt;= 2, and INDICES tensor of rank q &gt;= 1, gather
entries of the outer-most dimension of DATA indexed by INDICES, and concatenate
them in an output tensor of rank (q - 1) + (r - 1).

Example:
  DATA  = [
      [1.0, 1.2, 2.4, 4.5],
      [2.3, 3.4, 3.6, 2.3],
      [4.5, 5.7, 1.2, 4.5],
  ]
  INDICES = [
      [0, 2],
  ]
  OUTPUT = [
      [1.0, 2.4],
      [2.3, 3.6],
      [4.5, 1.2],
  ]
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:af6ddeb38db7e5325f8d430c2e0f28981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae501b0cebcf0e0bc8c3a710d97f9765a"><td class="memItemLeft" align="right" valign="top"><a id="ae501b0cebcf0e0bc8c3a710d97f9765a"></a>
<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> of rank of any rank q&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;OUTPUT&quot;, &quot;<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> of rank (q - 1) + (r - 1).&quot;)</td></tr>
<tr class="separator:ae501b0cebcf0e0bc8c3a710d97f9765a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040943feb691c6d2783bfc48d09c4ad6"><td class="memItemLeft" align="right" valign="top"><a id="a040943feb691c6d2783bfc48d09c4ad6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (BatchGatherGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a040943feb691c6d2783bfc48d09c4ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2ab4ef78e8d53533fd78a515f238b3"><td class="memItemLeft" align="right" valign="top"><a id="a3c2ab4ef78e8d53533fd78a515f238b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (BatchGather, <a class="el" href="classcaffe2_1_1GetBatchGatherGradient.html">GetBatchGatherGradient</a>)</td></tr>
<tr class="separator:a3c2ab4ef78e8d53533fd78a515f238b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b50d8d37c31c759a576e1e9dec98a9c"><td class="memItemLeft" align="right" valign="top"><a id="a2b50d8d37c31c759a576e1e9dec98a9c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BatchMatMul, <a class="el" href="classcaffe2_1_1BatchMatMulOp.html">BatchMatMulOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a2b50d8d37c31c759a576e1e9dec98a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa073d42eae2ee6b2076beb0f6d8f2670"><td class="memItemLeft" align="right" valign="top"><a id="aa073d42eae2ee6b2076beb0f6d8f2670"></a>
where A has&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b> (dim0, dim1,... M, K)</td></tr>
<tr class="separator:aa073d42eae2ee6b2076beb0f6d8f2670"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9937388abcbfd3dd95e8bd301a8a449"><td class="memItemLeft" align="right" valign="top"><a id="ab9937388abcbfd3dd95e8bd301a8a449"></a>
where A has B has&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b> (dim0, dim1,... K, N)</td></tr>
<tr class="separator:ab9937388abcbfd3dd95e8bd301a8a449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07d732ffb0cdc05fef37d6e8b8f048c"><td class="memItemLeft" align="right" valign="top"><a id="af07d732ffb0cdc05fef37d6e8b8f048c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BatchSparseToDense, <a class="el" href="classcaffe2_1_1BatchSparseToDenseOp.html">BatchSparseToDenseOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af07d732ffb0cdc05fef37d6e8b8f048c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b21f9f765ec3fa068f939bc0be729c"><td class="memItemLeft" align="right" valign="top"><a id="ac6b21f9f765ec3fa068f939bc0be729c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (3, 4) .NumOutputs(1) .SetDoc(R&quot;DOC( Convert sparse matrix representation into dense matrix. A sparse matrix is represented by `lengths` vector</td></tr>
<tr class="separator:ac6b21f9f765ec3fa068f939bc0be729c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f14b62415adb087c4825578f8de71e"><td class="memItemLeft" align="right" valign="top"><a id="a58f14b62415adb087c4825578f8de71e"></a>
indices and values vector Each element in lengths&#160;</td><td class="memItemRight" valign="bottom"><b>vector</b> (lengths[`i`]) represents the number of indices in this batch(batch `i`). With in each batch</td></tr>
<tr class="separator:a58f14b62415adb087c4825578f8de71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661de2e8bd57d969076dca9fbbd15c77"><td class="memItemLeft" align="right" valign="top"><a id="a661de2e8bd57d969076dca9fbbd15c77"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BooleanMask, <a class="el" href="classcaffe2_1_1BooleanMaskOp.html">BooleanMaskOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a661de2e8bd57d969076dca9fbbd15c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c40f697e54ef82185afeb0d5b9472f"><td class="memItemLeft" align="right" valign="top"><a id="ad6c40f697e54ef82185afeb0d5b9472f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BooleanMaskLengths, BooleanMaskLengthsOp&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad6c40f697e54ef82185afeb0d5b9472f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4593c557a01e172544a14942a0e6c92e"><td class="memItemLeft" align="right" valign="top"><a id="a4593c557a01e172544a14942a0e6c92e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given a data tensor and a 1D boolean mask tensor, returns a tensor containing
only the elements corresponding to positions where the mask is true.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:a4593c557a01e172544a14942a0e6c92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae049af5cc1f5f615b9b222081907e356"><td class="memItemLeft" align="right" valign="top"><a id="ae049af5cc1f5f615b9b222081907e356"></a>
original data tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;mask&quot;, &quot;A tensor of bools of same shape as `data`.&quot;) .Output(0</td></tr>
<tr class="separator:ae049af5cc1f5f615b9b222081907e356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db4098dd8c1fbf83dab0f975b1fd91d"><td class="memItemLeft" align="right" valign="top"><a id="a7db4098dd8c1fbf83dab0f975b1fd91d"></a>
original data tensor A tensor of same type as data&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1, &quot;masked_indices&quot;, &quot;A tensor for indices.&quot;)</td></tr>
<tr class="separator:a7db4098dd8c1fbf83dab0f975b1fd91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e363bd491af5f0abf7ab385ff64df0"><td class="memItemLeft" align="right" valign="top"><a id="a33e363bd491af5f0abf7ab385ff64df0"></a>
return the segment lengths of a corresponding segmented tensor after BooleanMask is applied DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;lengths&quot;, &quot;A 1D int32 tensor representing segment lengths.&quot;) .Input(1</td></tr>
<tr class="separator:a33e363bd491af5f0abf7ab385ff64df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353b87524e0ced16606cf17077d7bb25"><td class="memItemLeft" align="right" valign="top"><a id="a353b87524e0ced16606cf17077d7bb25"></a>
return the segment lengths of a corresponding segmented tensor after BooleanMask is applied DOC A bool tensor of values to keep&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;masked_lengths&quot;, &quot;Segment lengths of a masked tensor.&quot;)</td></tr>
<tr class="separator:a353b87524e0ced16606cf17077d7bb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e1a77ca62e15fbbaa617134bbc329c"><td class="memItemLeft" align="right" valign="top"><a id="a16e1a77ca62e15fbbaa617134bbc329c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (BooleanMaskLengths)</td></tr>
<tr class="separator:a16e1a77ca62e15fbbaa617134bbc329c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396cc6a0218fb358da4ef87d070a6b0e"><td class="memTemplParams" colspan="2"><a id="a396cc6a0218fb358da4ef87d070a6b0e"></a>
template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a396cc6a0218fb358da4ef87d070a6b0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MaskWithFunctor</b> (size_t N, size_t M, int B, const float *in, Functor fn, float fill_val, float *out)</td></tr>
<tr class="separator:a396cc6a0218fb358da4ef87d070a6b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2dd33050e43e411fc20d2865a804d8"><td class="memTemplParams" colspan="2"><a id="a5d2dd33050e43e411fc20d2865a804d8"></a>
template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:a5d2dd33050e43e411fc20d2865a804d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RepeatedMaskWithFunctor</b> (size_t N, size_t M, int D, const float *in, Functor fn, float fill_val, float *out)</td></tr>
<tr class="separator:a5d2dd33050e43e411fc20d2865a804d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ac3b44a6339d941867ae3df4f345cd"><td class="memItemLeft" align="right" valign="top"><a id="a97ac3b44a6339d941867ae3df4f345cd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SequenceMask, <a class="el" href="classcaffe2_1_1SequenceMaskOp.html">SequenceMaskOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a97ac3b44a6339d941867ae3df4f345cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae052e727bfc0c72e48ddc42578535e54"><td class="memItemLeft" align="right" valign="top"><a id="ae052e727bfc0c72e48ddc42578535e54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BooleanUnmask, <a class="el" href="classcaffe2_1_1BooleanUnmaskOp.html">BooleanUnmaskOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae052e727bfc0c72e48ddc42578535e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c22c792c879a883a3eb98b1eba5ae50"><td class="memItemLeft" align="right" valign="top"><a id="a1c22c792c879a883a3eb98b1eba5ae50"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> ([](int n) { return n &gt; 0 &amp;&amp;n % 2==0;}) .NumOutputs(1) .SetDoc(R&quot;DOC( Given a series of mask and values</td></tr>
<tr class="separator:a1c22c792c879a883a3eb98b1eba5ae50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa491c0b3b3ce638633901a3f8d7f91d6"><td class="memItemLeft" align="right" valign="top"><a id="aa491c0b3b3ce638633901a3f8d7f91d6"></a>
reconstruct values together according to masks A comprehensive False False True Reconstruct We Note that for all mask there must be at least one True If for a field there are multiple True we will accept the first value For False False False True DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;unmasked_data&quot;, &quot;The final reconstructed unmasked data&quot;)</td></tr>
<tr class="separator:aa491c0b3b3ce638633901a3f8d7f91d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e06f847fb5a26f54e6225b3cf9e5c93"><td class="memItemLeft" align="right" valign="top"><a id="a6e06f847fb5a26f54e6225b3cf9e5c93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Cast, <a class="el" href="classcaffe2_1_1CastOp.html">CastOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a6e06f847fb5a26f54e6225b3cf9e5c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5a699c6188189a84f0cb3c1881a743"><td class="memItemLeft" align="right" valign="top"><a id="a4b5a699c6188189a84f0cb3c1881a743"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (1) .NumOutputs(1) .TensorInferenceFunction([](const OperatorDef &amp;def</td></tr>
<tr class="separator:a4b5a699c6188189a84f0cb3c1881a743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322565961cb52c6e30b4b0cb280c0b04"><td class="memItemLeft" align="right" valign="top"><a id="a322565961cb52c6e30b4b0cb280c0b04"></a>
out&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (in[0])</td></tr>
<tr class="separator:a322565961cb52c6e30b4b0cb280c0b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5f7ae8d5e44b091c0c572b6ddc1290"><td class="memItemLeft" align="right" valign="top"><a id="a7e5f7ae8d5e44b091c0c572b6ddc1290"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>set_data_type</b> (cast::GetCastDataType(helper, &quot;to&quot;))</td></tr>
<tr class="separator:a7e5f7ae8d5e44b091c0c572b6ddc1290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bef880d669673227e58a56e052ccdca"><td class="memItemLeft" align="right" valign="top"><a id="a2bef880d669673227e58a56e052ccdca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
The operator casts the elements of a given input tensor to a data type
specified by the 'to' argument and returns an output tensor of the same size in
the converted type. The 'to' argument must be one of the data types specified
in the 'DataType' enum field in the TensorProto message. If the 'to' argument
is not provided or is not one of the enumerated types in DataType, Caffe2
throws an Enforce error.

NOTE: Casting to and from strings is not supported yet.
)DOC&quot;) .Arg(&quot;to&quot;</td></tr>
<tr class="separator:a2bef880d669673227e58a56e052ccdca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d0f9321d37b773703cc7606ec491d5"><td class="memItemLeft" align="right" valign="top"><a id="ac2d0f9321d37b773703cc7606ec491d5"></a>
The data type to which the elements of the input tensor are cast Strictly must be one of the types from DataType enum in TensorProto&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;input&quot;, &quot;Input tensor to be cast.&quot;) .Output(0</td></tr>
<tr class="separator:ac2d0f9321d37b773703cc7606ec491d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca31f20f5f48826244c16253688e969"><td class="memItemLeft" align="right" valign="top"><a id="a8ca31f20f5f48826244c16253688e969"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Cast, <a class="el" href="classcaffe2_1_1GetCastGradient.html">GetCastGradient</a>)</td></tr>
<tr class="separator:a8ca31f20f5f48826244c16253688e969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1174a2acc80f69b1c4900bedf764eb7"><td class="memItemLeft" align="right" valign="top"><a id="aa1174a2acc80f69b1c4900bedf764eb7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ChannelShuffle, <a class="el" href="classcaffe2_1_1ChannelShuffleOp.html">ChannelShuffleOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa1174a2acc80f69b1c4900bedf764eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8762881e165e41fac886eec2da7c5b"><td class="memItemLeft" align="right" valign="top"><a id="a9a8762881e165e41fac886eec2da7c5b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ChannelShuffleGradient, <a class="el" href="classcaffe2_1_1ChannelShuffleGradientOp.html">ChannelShuffleGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9a8762881e165e41fac886eec2da7c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1942f40b3c748c8fed39212060a1d1af"><td class="memItemLeft" align="right" valign="top"><a id="a1942f40b3c748c8fed39212060a1d1af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ChannelShuffle, <a class="el" href="classcaffe2_1_1GetChannelShuffleGradient.html">GetChannelShuffleGradient</a>)</td></tr>
<tr class="separator:a1942f40b3c748c8fed39212060a1d1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5193b73ccc1a3de3067c1b65af80f23"><td class="memItemLeft" align="right" valign="top"><a id="ac5193b73ccc1a3de3067c1b65af80f23"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Clip, <a class="el" href="classcaffe2_1_1ClipOp.html">ClipOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac5193b73ccc1a3de3067c1b65af80f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36ac85145caad91c4f7aca4a37a4b0d"><td class="memItemLeft" align="right" valign="top"><a id="ad36ac85145caad91c4f7aca4a37a4b0d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ClipGradient, <a class="el" href="classcaffe2_1_1ClipGradientOp.html">ClipGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad36ac85145caad91c4f7aca4a37a4b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f7126205a3ff8c1be4df06db4fb3888"><td class="memItemLeft" align="right" valign="top"><a id="a1f7126205a3ff8c1be4df06db4fb3888"></a>
Key value handler for&#160;</td><td class="memItemRight" valign="bottom"><b>rendezvous</b> (optional).&quot;) .Output(0</td></tr>
<tr class="separator:a1f7126205a3ff8c1be4df06db4fb3888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a273f84a23fdb03f4485cf51e0fc193"><td class="memItemLeft" align="right" valign="top"><a id="a7a273f84a23fdb03f4485cf51e0fc193"></a>
Key value handler for A common world for collective operations&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;size&quot;, &quot;(int) size of the common world.&quot;) .Arg(&quot;rank&quot;</td></tr>
<tr class="separator:a7a273f84a23fdb03f4485cf51e0fc193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729ff7988bb07de7506dfc93bbc313c3"><td class="memItemLeft" align="right" valign="top"><a id="a729ff7988bb07de7506dfc93bbc313c3"></a>
Existing common world to clone&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;comm_world&quot;, &quot;A common world for collective operations.&quot;)</td></tr>
<tr class="separator:a729ff7988bb07de7506dfc93bbc313c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab43d6903ad553ec210d993b60cff17d4"><td class="memItemLeft" align="right" valign="top"><a id="ab43d6903ad553ec210d993b60cff17d4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (&quot;Closes all connections managed by a common world.&quot;) .Input(0</td></tr>
<tr class="separator:ab43d6903ad553ec210d993b60cff17d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa712339e351b1b52ffeb7fbd576f11ed"><td class="memItemLeft" align="right" valign="top"><a id="aa712339e351b1b52ffeb7fbd576f11ed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputsOutputs</b> ([](int in, int out) { return in &gt;=2 &amp;&amp;out==(in - 1);}) .EnforceInplace([](int in</td></tr>
<tr class="separator:aa712339e351b1b52ffeb7fbd576f11ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8e8917de68709241133bea8d9bcef9"><td class="memItemLeft" align="right" valign="top"><a id="a4b8e8917de68709241133bea8d9bcef9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>InputsCanCrossDevices</b> () .IdenticalTypeAndShapeOfInput(0) .SetDoc(R&quot;DOC( Does a broadcast operation from the root node to every other node. The tensor on each node should have been pre-created with the same shape and data type. )DOC&quot;) .Input(0</td></tr>
<tr class="separator:a4b8e8917de68709241133bea8d9bcef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784436bc2958b781e7d7d6368bbbdb29"><td class="memItemLeft" align="right" valign="top"><a id="a784436bc2958b781e7d7d6368bbbdb29"></a>
The common world&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;X&quot;, &quot;A tensor to be broadcasted.&quot;) .Output(0</td></tr>
<tr class="separator:a784436bc2958b781e7d7d6368bbbdb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39192c2df7610679e55a3bf170d476b"><td class="memItemLeft" align="right" valign="top"><a id="af39192c2df7610679e55a3bf170d476b"></a>
The common world In place as input&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;root&quot;, &quot;(int, default 0) the root to run broadcast from.&quot;)</td></tr>
<tr class="separator:af39192c2df7610679e55a3bf170d476b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216524ae883a44f9563a8cdc2819c990"><td class="memItemLeft" align="right" valign="top"><a id="a216524ae883a44f9563a8cdc2819c990"></a>
The common world&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;X&quot;, &quot;A tensor to be reduced.&quot;) .Output(0</td></tr>
<tr class="separator:a216524ae883a44f9563a8cdc2819c990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806d63aa7d38acc4a97d2113d7d13d5d"><td class="memItemLeft" align="right" valign="top"><a id="a806d63aa7d38acc4a97d2113d7d13d5d"></a>
The common world The reduced result on not set for other nodes&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;root&quot;, &quot;(int, default 0) the root to run reduce into.&quot;)</td></tr>
<tr class="separator:a806d63aa7d38acc4a97d2113d7d13d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178ca081fca1c3dccda48652ce75204a"><td class="memItemLeft" align="right" valign="top"><a id="a178ca081fca1c3dccda48652ce75204a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>IdenticalTypeAndShapeOfInput</b> (0) .InputsCanCrossDevices() .SetDoc(R&quot;DOC( Does an allreduce operation among the nodes. Currently only Sum is supported. )DOC&quot;) .Input(0</td></tr>
<tr class="separator:a178ca081fca1c3dccda48652ce75204a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6700626b71e491ea7029675c3856fbf2"><td class="memItemLeft" align="right" valign="top"><a id="a6700626b71e491ea7029675c3856fbf2"></a>
The common world&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;X&quot;, &quot;A tensor to be allreduced.&quot;) .Output(0</td></tr>
<tr class="separator:a6700626b71e491ea7029675c3856fbf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0122ed31d6bca328bfd9462597de08"><td class="memItemLeft" align="right" valign="top"><a id="abc0122ed31d6bca328bfd9462597de08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (2, INT_MAX) .NumOutputs(1) .InputsCanCrossDevices() .SetDoc(R&quot;DOC( Does an allgather operation among the nodes. )DOC&quot;) .Input(0</td></tr>
<tr class="separator:abc0122ed31d6bca328bfd9462597de08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab540a4f5989cc2f6f9ada419b173172a"><td class="memItemLeft" align="right" valign="top"><a id="ab540a4f5989cc2f6f9ada419b173172a"></a>
The common world&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;X&quot;, &quot;A tensor to be allgathered.&quot;) .Output(0</td></tr>
<tr class="separator:ab540a4f5989cc2f6f9ada419b173172a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba241373e4ff7609d117a00c3551c41"><td class="memItemLeft" align="right" valign="top"><a id="abba241373e4ff7609d117a00c3551c41"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> ({2, 4}) .NumOutputs(0) .SetDoc(R&quot;DOC( Sends the tensor to another node. )DOC&quot;) .Input(0</td></tr>
<tr class="separator:abba241373e4ff7609d117a00c3551c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6fc3a8464360558458b4c85e6c93e04"><td class="memItemLeft" align="right" valign="top"><a id="ad6fc3a8464360558458b4c85e6c93e04"></a>
The common world An int CPUtensor of size specifying the rank If this overrides the to argument of the op&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3, &quot;tag&quot;, &quot;An int CPUtensor of size 1 specifying the tag to &quot; &quot;send the tensor with. This overrides the 'tag' &quot; &quot;argument of the op.&quot;) .Arg(&quot;dst&quot;</td></tr>
<tr class="separator:ad6fc3a8464360558458b4c85e6c93e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528be2a12ea02f3f96f0a911c1fc18d2"><td class="memItemLeft" align="right" valign="top"><a id="a528be2a12ea02f3f96f0a911c1fc18d2"></a>
The common world An int CPUtensor of size specifying the rank If this overrides the to argument of the op The rank to send the tensor to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;tag&quot;, &quot;(int) a tag to send the tensor with.&quot;) .Arg(&quot;raw_buffer&quot;</td></tr>
<tr class="separator:a528be2a12ea02f3f96f0a911c1fc18d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe9f22837ad346edc0331c6a7655988"><td class="memItemLeft" align="right" valign="top"><a id="affe9f22837ad346edc0331c6a7655988"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AllowInplace</b> ({{2, 1}, {3, 2}}) .SetDoc(R&quot;DOC( Receives the tensor from another node. )DOC&quot;) .Input(0</td></tr>
<tr class="separator:affe9f22837ad346edc0331c6a7655988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa915ff9615f84e969afbae4a248a7905"><td class="memItemLeft" align="right" valign="top"><a id="aa915ff9615f84e969afbae4a248a7905"></a>
The common world&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;Y&quot;, &quot;In-place output. If raw_buffer is specified, &quot; &quot;Y should have pre-allocated data and type..&quot;) .Input(2</td></tr>
<tr class="separator:aa915ff9615f84e969afbae4a248a7905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96405b7e799fe93858f936d527b7d805"><td class="memItemLeft" align="right" valign="top"><a id="a96405b7e799fe93858f936d527b7d805"></a>
The common world An int CPUtensor of size specifying the rank If this overrides the from argument of the op The received tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1, &quot;src&quot;, &quot;The sender that sent the message as a CPUTensor &quot; &quot;of size 1 and of type int.&quot;) .Output(2</td></tr>
<tr class="separator:a96405b7e799fe93858f936d527b7d805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a342656f7cd5cdd3b92ff85a39490057c"><td class="memItemLeft" align="right" valign="top"><a id="a342656f7cd5cdd3b92ff85a39490057c"></a>
The common world An int CPUtensor of size specifying the rank If this overrides the from argument of the op The received tensor The tag that the message is sent with as a CPUTensor of size and of type int&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;src&quot;, &quot;(int) he rank to receive the tensor from.&quot;) .Arg(&quot;tag&quot;</td></tr>
<tr class="separator:a342656f7cd5cdd3b92ff85a39490057c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040dbe572da5018f44386853bd1f0903"><td class="memItemLeft" align="right" valign="top"><a id="a040dbe572da5018f44386853bd1f0903"></a>
The common world An int CPUtensor of size specifying the rank If this overrides the from argument of the op The received tensor The tag that the message is sent with as a CPUTensor of size and of type int int a tag to receive the tensor with&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;raw_buffer&quot;, &quot;(bool) if set, only send the content and assume that the receiver &quot; &quot;has already known the tensor's shape and information.&quot;)</td></tr>
<tr class="separator:a040dbe572da5018f44386853bd1f0903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49539000e2a5fc0eed28624a67cc016"><td class="memItemLeft" align="right" valign="top"><a id="ad49539000e2a5fc0eed28624a67cc016"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (CreateCommonWorld)</td></tr>
<tr class="separator:ad49539000e2a5fc0eed28624a67cc016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd80fe8cac2b741aa8fa72047c63e664"><td class="memItemLeft" align="right" valign="top"><a id="acd80fe8cac2b741aa8fa72047c63e664"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (CloneCommonWorld)</td></tr>
<tr class="separator:acd80fe8cac2b741aa8fa72047c63e664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ae8b96d0cee85e6a82db74a3618dc2"><td class="memItemLeft" align="right" valign="top"><a id="a19ae8b96d0cee85e6a82db74a3618dc2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (DestroyCommonWorld)</td></tr>
<tr class="separator:a19ae8b96d0cee85e6a82db74a3618dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c8f29f71652e7c3a907d4535eb6159"><td class="memItemLeft" align="right" valign="top"><a id="a21c8f29f71652e7c3a907d4535eb6159"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Broadcast)</td></tr>
<tr class="separator:a21c8f29f71652e7c3a907d4535eb6159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48195cc4cdfc484aff4e373cd0648805"><td class="memItemLeft" align="right" valign="top"><a id="a48195cc4cdfc484aff4e373cd0648805"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Reduce)</td></tr>
<tr class="separator:a48195cc4cdfc484aff4e373cd0648805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486e2bba9d4e92afa02816e855cafd6e"><td class="memItemLeft" align="right" valign="top"><a id="a486e2bba9d4e92afa02816e855cafd6e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Allgather)</td></tr>
<tr class="separator:a486e2bba9d4e92afa02816e855cafd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3650a7bd191ce63b9d6d128755473a84"><td class="memItemLeft" align="right" valign="top"><a id="a3650a7bd191ce63b9d6d128755473a84"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Allreduce)</td></tr>
<tr class="separator:a3650a7bd191ce63b9d6d128755473a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75ea3114660c16d1481ce94385984ea0"><td class="memItemLeft" align="right" valign="top"><a id="a75ea3114660c16d1481ce94385984ea0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Barrier)</td></tr>
<tr class="separator:a75ea3114660c16d1481ce94385984ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af05c9bf4569fc7a1e46136e8662568"><td class="memItemLeft" align="right" valign="top"><a id="a1af05c9bf4569fc7a1e46136e8662568"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (SendTensor)</td></tr>
<tr class="separator:a1af05c9bf4569fc7a1e46136e8662568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809d0c77d10a4a63338f8ca0fbc47de3"><td class="memItemLeft" align="right" valign="top"><a id="a809d0c77d10a4a63338f8ca0fbc47de3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (ReceiveTensor)</td></tr>
<tr class="separator:a809d0c77d10a4a63338f8ca0fbc47de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ffb04b412a41b84a40a7fd9b6af946"><td class="memItemLeft" align="right" valign="top"><a id="a82ffb04b412a41b84a40a7fd9b6af946"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CreateCommonWorld, <a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a82ffb04b412a41b84a40a7fd9b6af946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f12b032101d7aa1e795701b551e4b3"><td class="memItemLeft" align="right" valign="top"><a id="a01f12b032101d7aa1e795701b551e4b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CloneCommonWorld, <a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a01f12b032101d7aa1e795701b551e4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9201ba82eb22aa93623df5a9fbace5cc"><td class="memItemLeft" align="right" valign="top"><a id="a9201ba82eb22aa93623df5a9fbace5cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DestroyCommonWorld, <a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9201ba82eb22aa93623df5a9fbace5cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd7b087b2d8b2dc61f4f112ca50e9a1"><td class="memItemLeft" align="right" valign="top"><a id="aafd7b087b2d8b2dc61f4f112ca50e9a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Broadcast, <a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aafd7b087b2d8b2dc61f4f112ca50e9a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacce28a459d4946861f99180a38be193"><td class="memItemLeft" align="right" valign="top"><a id="aacce28a459d4946861f99180a38be193"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Reduce, <a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aacce28a459d4946861f99180a38be193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19489cdede91acaa8530900fdfae472"><td class="memItemLeft" align="right" valign="top"><a id="aa19489cdede91acaa8530900fdfae472"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Allgather, <a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa19489cdede91acaa8530900fdfae472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38bf22b5e8ec68635f0d7351a55d8ea9"><td class="memItemLeft" align="right" valign="top"><a id="a38bf22b5e8ec68635f0d7351a55d8ea9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Allreduce, <a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a38bf22b5e8ec68635f0d7351a55d8ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0484a83e1404939b456a983ec76da4b"><td class="memItemLeft" align="right" valign="top"><a id="aa0484a83e1404939b456a983ec76da4b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Barrier, <a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa0484a83e1404939b456a983ec76da4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a563f491bf45a8612a48b0f04bfe435"><td class="memItemLeft" align="right" valign="top"><a id="a3a563f491bf45a8612a48b0f04bfe435"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SendTensor, <a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3a563f491bf45a8612a48b0f04bfe435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a16bcddd44f6b9d0f58f054404c8be"><td class="memItemLeft" align="right" valign="top"><a id="a26a16bcddd44f6b9d0f58f054404c8be"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReceiveTensor, <a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a26a16bcddd44f6b9d0f58f054404c8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9536c5e72afa35d3384fcea4e85915"><td class="memItemLeft" align="right" valign="top"><a id="a3c9536c5e72afa35d3384fcea4e85915"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CreateCommonWorld, <a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a3c9536c5e72afa35d3384fcea4e85915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae687b04805f1b278252e645b04845609"><td class="memItemLeft" align="right" valign="top"><a id="ae687b04805f1b278252e645b04845609"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CloneCommonWorld, <a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ae687b04805f1b278252e645b04845609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78998b74f7a886416d7a5cd6c98e1d0d"><td class="memItemLeft" align="right" valign="top"><a id="a78998b74f7a886416d7a5cd6c98e1d0d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Broadcast, <a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a78998b74f7a886416d7a5cd6c98e1d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41cf14488f591c1013139b4fb48fcb05"><td class="memItemLeft" align="right" valign="top"><a id="a41cf14488f591c1013139b4fb48fcb05"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Reduce, <a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a41cf14488f591c1013139b4fb48fcb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb5146bdc443e27be1d0feb34aa305c"><td class="memItemLeft" align="right" valign="top"><a id="a8bb5146bdc443e27be1d0feb34aa305c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Allgather, <a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a8bb5146bdc443e27be1d0feb34aa305c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e6a068bd3b4a89754a5d5db34d414b"><td class="memItemLeft" align="right" valign="top"><a id="a25e6a068bd3b4a89754a5d5db34d414b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Allreduce, <a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a25e6a068bd3b4a89754a5d5db34d414b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1514f4ab94c412972f50cc3f9fd2110c"><td class="memItemLeft" align="right" valign="top"><a id="a1514f4ab94c412972f50cc3f9fd2110c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (SendTensor, <a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a1514f4ab94c412972f50cc3f9fd2110c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e2dadc8ec3fab95bd31ae67f00ac04"><td class="memItemLeft" align="right" valign="top"><a id="a37e2dadc8ec3fab95bd31ae67f00ac04"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (ReceiveTensor, <a class="el" href="classcaffe2_1_1NoDefaultEngineOp.html">NoDefaultEngineOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a37e2dadc8ec3fab95bd31ae67f00ac04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f36c0089fc94b6017420b6e513ea631"><td class="memItemLeft" align="right" valign="top"><a id="a9f36c0089fc94b6017420b6e513ea631"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Split, <a class="el" href="classcaffe2_1_1SplitOp.html">SplitOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9f36c0089fc94b6017420b6e513ea631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dadc37c106c87f6b5a4f1fa50260d6"><td class="memItemLeft" align="right" valign="top"><a id="a96dadc37c106c87f6b5a4f1fa50260d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Concat, <a class="el" href="classcaffe2_1_1ConcatOp.html">ConcatOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a96dadc37c106c87f6b5a4f1fa50260d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b430cc0abd6f708a5712c5d7b7922c"><td class="memItemLeft" align="right" valign="top"><a id="a28b430cc0abd6f708a5712c5d7b7922c"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;input&quot;, &quot;The tensor to split&quot;) .Input(1</td></tr>
<tr class="separator:a28b430cc0abd6f708a5712c5d7b7922c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5bb4ef5f44f680faaf8007994f2801"><td class="memItemLeft" align="right" valign="top"><a id="a8d5bb4ef5f44f680faaf8007994f2801"></a>
INT_MAX Optional list of output&#160;</td><td class="memItemRight" valign="bottom"><b>lengths</b> (see also arg 'split')&quot;) .Arg(&quot;axis&quot;</td></tr>
<tr class="separator:a8d5bb4ef5f44f680faaf8007994f2801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b23924727e6cc5e5947b3d0ae2da73"><td class="memItemLeft" align="right" valign="top"><a id="a45b23924727e6cc5e5947b3d0ae2da73"></a>
INT_MAX Optional list of output Which axis to split on&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;split&quot;, &quot;length of each output&quot;) .Arg(&quot;order&quot;</td></tr>
<tr class="separator:a45b23924727e6cc5e5947b3d0ae2da73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4219d17aa2d9020922110170a26b1c67"><td class="memItemLeft" align="right" valign="top"><a id="a4219d17aa2d9020922110170a26b1c67"></a>
INT_MAX Optional list of output Which axis to split on Either NHWC or will split on C defaults to NCHW&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(Split a tensor into a list of tensors, along the specified
    'axis'. The lengths of the split can be specified using argument 'axis' or
    optional second input blob to the operator. Otherwise, the tensor is split
    to equal sized parts.
    )DOC&quot;)</td></tr>
<tr class="separator:a4219d17aa2d9020922110170a26b1c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff6b2bc663803a5c8fd5920c0bfd319"><td class="memItemLeft" align="right" valign="top"><a id="a1ff6b2bc663803a5c8fd5920c0bfd319"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (1, INT_MAX) .NumOutputs(2) .Arg(&quot;axis&quot;</td></tr>
<tr class="separator:a1ff6b2bc663803a5c8fd5920c0bfd319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af797253a5242bf30774c69630a8eefd4"><td class="memItemLeft" align="right" valign="top"><a id="af797253a5242bf30774c69630a8eefd4"></a>
Which axis to concat on&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;order&quot;, &quot;Either NHWC or NCHW, will concat on C axis, defaults to NCHW&quot;) .Arg(&quot;add_axis&quot;</td></tr>
<tr class="separator:af797253a5242bf30774c69630a8eefd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e6292699bfe4a93ef249a31d5ae40e"><td class="memItemLeft" align="right" valign="top"><a id="a76e6292699bfe4a93ef249a31d5ae40e"></a>
Which axis to concat on Pass to add the axis specified in arg axis to all input tensors&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> ([](const OperatorDef &amp;def, const vector&lt; TensorShape &gt; &amp;in) { <a class="el" href="classcaffe2_1_1ArgumentHelper.html">ArgumentHelper</a> helper(def);const int axis=helper.HasArgument(&quot;axis&quot;) ? helper.GetSingleArgument&lt; int &gt;(&quot;axis&quot;, -1) :GetDimFromOrderString(helper.GetSingleArgument&lt; string &gt;(&quot;order&quot;, &quot;NCHW&quot;));bool add_axis=helper.GetSingleArgument&lt; int &gt;(&quot;add_axis&quot;, 0) !=0;const int canonical_axis=canonical_axis_index_(axis, in[0].dims_size());CAFFE_ENFORCE_GT(in.size(), 0);vector&lt; int &gt; split_shape(1, in.size());vector&lt; int &gt; out_shape(in[0].dims().begin(), in[0].dims().end());if(add_axis) { out_shape.insert(out_shape.begin()+canonical_axis, in.size());} else { for(int i=1;i&lt; in.size();++i) { out_shape[canonical_axis]+=in[i].dims(canonical_axis);} } if(def.output_size()==1) { return vector&lt; TensorShape &gt;{ CreateTensorShape(out_shape, in[0].data_type())};} return vector&lt; TensorShape &gt;{ CreateTensorShape(out_shape, in[0].data_type()), CreateTensorShape(split_shape, TensorProto::INT32)};}) .SetDoc(&quot;Concatenate a list of tensors into a single tensor&quot;) .Output(0</td></tr>
<tr class="separator:a76e6292699bfe4a93ef249a31d5ae40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0504e8420cd32f1a85b4f5c8f8844a97"><td class="memItemLeft" align="right" valign="top"><a id="a0504e8420cd32f1a85b4f5c8f8844a97"></a>
Which axis to concat on Pass to add the axis specified in arg axis to all input tensors Concatenated tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1, &quot;split_info&quot;, &quot;The dimensions of the inputs.&quot;)</td></tr>
<tr class="separator:a0504e8420cd32f1a85b4f5c8f8844a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dee9617b37d653dc8af9efc6e59ca39"><td class="memItemLeft" align="right" valign="top"><a id="a7dee9617b37d653dc8af9efc6e59ca39"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DepthSplit, <a class="el" href="classcaffe2_1_1SplitOp.html">SplitOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7dee9617b37d653dc8af9efc6e59ca39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e29368e00f7b6bbe85ac05aa1f23ea"><td class="memItemLeft" align="right" valign="top"><a id="a16e29368e00f7b6bbe85ac05aa1f23ea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DepthConcat, <a class="el" href="classcaffe2_1_1ConcatOp.html">ConcatOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a16e29368e00f7b6bbe85ac05aa1f23ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0d4cebb2b53b2311c7010f5aa3979e"><td class="memItemLeft" align="right" valign="top"><a id="a4d0d4cebb2b53b2311c7010f5aa3979e"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (&quot;Backward compatible operator name for Split.&quot;)</td></tr>
<tr class="separator:a4d0d4cebb2b53b2311c7010f5aa3979e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa280a02008baa5e6d85aeee0d890a968"><td class="memItemLeft" align="right" valign="top"><a id="aa280a02008baa5e6d85aeee0d890a968"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Split, <a class="el" href="classcaffe2_1_1GetSplitGradient.html">GetSplitGradient</a>)</td></tr>
<tr class="separator:aa280a02008baa5e6d85aeee0d890a968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ae96181d03ea1ae68aba6dc91adda4"><td class="memItemLeft" align="right" valign="top"><a id="a13ae96181d03ea1ae68aba6dc91adda4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (DepthSplit, <a class="el" href="classcaffe2_1_1GetSplitGradient.html">GetSplitGradient</a>)</td></tr>
<tr class="separator:a13ae96181d03ea1ae68aba6dc91adda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398a8621852a16e99cc7beeb198416a0"><td class="memItemLeft" align="right" valign="top"><a id="a398a8621852a16e99cc7beeb198416a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Concat, <a class="el" href="classcaffe2_1_1GetConcatGradient.html">GetConcatGradient</a>)</td></tr>
<tr class="separator:a398a8621852a16e99cc7beeb198416a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ef6f1bee2d410e1173b6f2303091f2"><td class="memItemLeft" align="right" valign="top"><a id="aa5ef6f1bee2d410e1173b6f2303091f2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (DepthConcat, <a class="el" href="classcaffe2_1_1GetConcatGradient.html">GetConcatGradient</a>)</td></tr>
<tr class="separator:aa5ef6f1bee2d410e1173b6f2303091f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf259b0449f20ec531eca7fab0c7c08"><td class="memItemLeft" align="right" valign="top"><a id="adbf259b0449f20ec531eca7fab0c7c08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Split, <a class="el" href="classcaffe2_1_1SplitOp.html">SplitOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:adbf259b0449f20ec531eca7fab0c7c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0a837afc1d3fc0bb6641916b60d183"><td class="memItemLeft" align="right" valign="top"><a id="a0c0a837afc1d3fc0bb6641916b60d183"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Concat, <a class="el" href="classcaffe2_1_1ConcatOp.html">ConcatOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a0c0a837afc1d3fc0bb6641916b60d183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf43127339fd7014056ad39fa6ab9a5"><td class="memItemLeft" align="right" valign="top"><a id="a7bf43127339fd7014056ad39fa6ab9a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (DepthSplit, <a class="el" href="classcaffe2_1_1SplitOp.html">SplitOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a7bf43127339fd7014056ad39fa6ab9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe48756a227d7227b1c04866552fa49e"><td class="memItemLeft" align="right" valign="top"><a id="abe48756a227d7227b1c04866552fa49e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (DepthConcat, <a class="el" href="classcaffe2_1_1ConcatOp.html">ConcatOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:abe48756a227d7227b1c04866552fa49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3daa15e8091929ad231fc747b512a49e"><td class="memItemLeft" align="right" valign="top"><a id="a3daa15e8091929ad231fc747b512a49e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Conditional, <a class="el" href="classcaffe2_1_1ConditionalOp.html">ConditionalOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3daa15e8091929ad231fc747b512a49e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fd1dc173c4ddfc3bd4341e8de2c9a5"><td class="memItemLeft" align="right" valign="top"><a id="a82fd1dc173c4ddfc3bd4341e8de2c9a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (3) .NumOutputs(1) .SetDoc(R&quot;DOC( Given a 1-D tensor of boolean values</td></tr>
<tr class="separator:a82fd1dc173c4ddfc3bd4341e8de2c9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fd1c9c5655e50be1986a2d5bbcc419c"><td class="memItemLeft" align="right" valign="top"><a id="a3fd1c9c5655e50be1986a2d5bbcc419c"></a>
apply conditional&#160;</td><td class="memItemRight" valign="bottom"><b>operator along the first dimension of DataT and DataF and return DataO. Note, DataT and DataF must have the exact same shape and type.) DOC&quot;) .Input</b> (0, &quot;Condition&quot;, &quot;Boolean tensor to select DataT or DataF&quot;) .Input(1</td></tr>
<tr class="separator:a3fd1c9c5655e50be1986a2d5bbcc419c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9482aff8f29490da87eee28e13e2c2"><td class="memItemLeft" align="right" valign="top"><a id="aae9482aff8f29490da87eee28e13e2c2"></a>
apply conditional Data to use when True&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (2, &quot;DataF&quot;, &quot;Data to use when False&quot;) .Output(0</td></tr>
<tr class="separator:aae9482aff8f29490da87eee28e13e2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257fa8ed03c06d3e11a454096c47b128"><td class="memItemLeft" align="right" valign="top"><a id="a257fa8ed03c06d3e11a454096c47b128"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (Conditional)</td></tr>
<tr class="separator:a257fa8ed03c06d3e11a454096c47b128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de298be2221d805d6cf340faa5c2265"><td class="memItemLeft" align="right" valign="top"><a id="a2de298be2221d805d6cf340faa5c2265"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ConvGradient, <a class="el" href="classcaffe2_1_1ConvGradientOp.html">ConvGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a2de298be2221d805d6cf340faa5c2265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8052eeee20416bfbdb6da73fa3af29d3"><td class="memItemLeft" align="right" valign="top"><a id="a8052eeee20416bfbdb6da73fa3af29d3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ConvGradient).NumInputs(2</td></tr>
<tr class="separator:a8052eeee20416bfbdb6da73fa3af29d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfdb1488130c01386f73e009ebdea3e"><td class="memItemLeft" align="right" valign="top"><a id="a0dfdb1488130c01386f73e009ebdea3e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Conv1DGradient, <a class="el" href="classcaffe2_1_1ConvGradientOp.html">ConvGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a0dfdb1488130c01386f73e009ebdea3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62e6db089dfe1d69e2ca5cbf652967f"><td class="memItemLeft" align="right" valign="top"><a id="ad62e6db089dfe1d69e2ca5cbf652967f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (Conv1DGradient).NumInputs(2</td></tr>
<tr class="separator:ad62e6db089dfe1d69e2ca5cbf652967f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11dcdfa25eba74b23ae88c1f44ba203"><td class="memItemLeft" align="right" valign="top"><a id="ac11dcdfa25eba74b23ae88c1f44ba203"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Conv2DGradient, <a class="el" href="classcaffe2_1_1ConvGradientOp.html">ConvGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac11dcdfa25eba74b23ae88c1f44ba203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f149930c99026da1f513db4befb90c"><td class="memItemLeft" align="right" valign="top"><a id="ae5f149930c99026da1f513db4befb90c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (Conv2DGradient).NumInputs(2</td></tr>
<tr class="separator:ae5f149930c99026da1f513db4befb90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d87b91c30feba32d163573ad815f0ce"><td class="memItemLeft" align="right" valign="top"><a id="a8d87b91c30feba32d163573ad815f0ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Conv3DGradient, <a class="el" href="classcaffe2_1_1ConvGradientOp.html">ConvGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a8d87b91c30feba32d163573ad815f0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862914a1ce4ce4da75ad17b8858e55ea"><td class="memItemLeft" align="right" valign="top"><a id="a862914a1ce4ce4da75ad17b8858e55ea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (Conv3DGradient).NumInputs(2</td></tr>
<tr class="separator:a862914a1ce4ce4da75ad17b8858e55ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0539c8ad037562f59ed975c7ac7f228"><td class="memItemLeft" align="right" valign="top"><a id="ab0539c8ad037562f59ed975c7ac7f228"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Conv, <a class="el" href="classcaffe2_1_1GetConvGradient.html">GetConvGradient</a>)</td></tr>
<tr class="separator:ab0539c8ad037562f59ed975c7ac7f228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e1facdf457ef2f4a647bd0c1ef778c"><td class="memItemLeft" align="right" valign="top"><a id="a50e1facdf457ef2f4a647bd0c1ef778c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Conv1D, <a class="el" href="classcaffe2_1_1GetConvGradient.html">GetConvGradient</a>)</td></tr>
<tr class="separator:a50e1facdf457ef2f4a647bd0c1ef778c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff75df71a3e0f3d4fb9d75cf0482770"><td class="memItemLeft" align="right" valign="top"><a id="a3ff75df71a3e0f3d4fb9d75cf0482770"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Conv2D, <a class="el" href="classcaffe2_1_1GetConvGradient.html">GetConvGradient</a>)</td></tr>
<tr class="separator:a3ff75df71a3e0f3d4fb9d75cf0482770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d7d7984044891abad49d3f2bb4e5e2"><td class="memItemLeft" align="right" valign="top"><a id="af3d7d7984044891abad49d3f2bb4e5e2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Conv3D, <a class="el" href="classcaffe2_1_1GetConvGradient.html">GetConvGradient</a>)</td></tr>
<tr class="separator:af3d7d7984044891abad49d3f2bb4e5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdb4117c1bb618fdcb09cc2ac08a05b"><td class="memItemLeft" align="right" valign="top"><a id="a4cdb4117c1bb618fdcb09cc2ac08a05b"></a>
std::function&lt; void(<a class="el" href="classcaffe2_1_1OpSchema.html">OpSchema</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConvDocGenerator</b> (const char *dim)</td></tr>
<tr class="separator:a4cdb4117c1bb618fdcb09cc2ac08a05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a8f1035b50560b24e2f5e6abcbd334"><td class="memItemLeft" align="right" valign="top"><a id="af4a8f1035b50560b24e2f5e6abcbd334"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Conv, <a class="el" href="classcaffe2_1_1ConvOp.html">ConvOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af4a8f1035b50560b24e2f5e6abcbd334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035c36ce45aefac076a5c9ac8a7f9c9f"><td class="memItemLeft" align="right" valign="top"><a id="a035c36ce45aefac076a5c9ac8a7f9c9f"></a>
NumInputs(2, 3) .NumOutputs(1) .TensorInferenceFunction(<a class="el" href="classcaffe2_1_1ConvPoolOpBase.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Conv1D, <a class="el" href="classcaffe2_1_1ConvOp.html">ConvOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a035c36ce45aefac076a5c9ac8a7f9c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e40db5ddd44443696571030136db98e"><td class="memItemLeft" align="right" valign="top"><a id="a4e40db5ddd44443696571030136db98e"></a>
NumInputs(2, 3) .NumOutputs(1) .TensorInferenceFunction(<a class="el" href="classcaffe2_1_1ConvPoolOpBase.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Conv2D, <a class="el" href="classcaffe2_1_1ConvOp.html">ConvOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4e40db5ddd44443696571030136db98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e2db24bf5f19e28466d9ae3faa94d10"><td class="memItemLeft" align="right" valign="top"><a id="a0e2db24bf5f19e28466d9ae3faa94d10"></a>
NumInputs(2, 3) .NumOutputs(1) .CostInferenceFunction(<a class="el" href="classcaffe2_1_1OpSchema.html">OpSchema</a>&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Conv3D, <a class="el" href="classcaffe2_1_1ConvOp.html">ConvOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a0e2db24bf5f19e28466d9ae3faa94d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a55e76f6280fa3c180bc1c5575d7031"><td class="memItemLeft" align="right" valign="top"><a id="a3a55e76f6280fa3c180bc1c5575d7031"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (Conv, <a class="el" href="classcaffe2_1_1CudnnConvOp.html">CudnnConvOp</a>)</td></tr>
<tr class="separator:a3a55e76f6280fa3c180bc1c5575d7031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ababe80cf5ad02fd87783df2f3bd68913"><td class="memItemLeft" align="right" valign="top"><a id="ababe80cf5ad02fd87783df2f3bd68913"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (ConvGradient, <a class="el" href="classcaffe2_1_1CudnnConvGradientOp.html">CudnnConvGradientOp</a>)</td></tr>
<tr class="separator:ababe80cf5ad02fd87783df2f3bd68913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef673b86ba934e008ccb3d8ef8fe6b8"><td class="memItemLeft" align="right" valign="top"><a id="abef673b86ba934e008ccb3d8ef8fe6b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (Conv1D, <a class="el" href="classcaffe2_1_1CudnnConvOp.html">CudnnConvOp</a>)</td></tr>
<tr class="separator:abef673b86ba934e008ccb3d8ef8fe6b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf00e30165169fd98a32db8725a60ca"><td class="memItemLeft" align="right" valign="top"><a id="aedf00e30165169fd98a32db8725a60ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (Conv1DGradient, <a class="el" href="classcaffe2_1_1CudnnConvGradientOp.html">CudnnConvGradientOp</a>)</td></tr>
<tr class="separator:aedf00e30165169fd98a32db8725a60ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1008188d46c33ac672d2716970e9b529"><td class="memItemLeft" align="right" valign="top"><a id="a1008188d46c33ac672d2716970e9b529"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (Conv2D, <a class="el" href="classcaffe2_1_1CudnnConvOp.html">CudnnConvOp</a>)</td></tr>
<tr class="separator:a1008188d46c33ac672d2716970e9b529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a65994e157c44fc7c7b2fc88bb67d08"><td class="memItemLeft" align="right" valign="top"><a id="a5a65994e157c44fc7c7b2fc88bb67d08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (Conv2DGradient, <a class="el" href="classcaffe2_1_1CudnnConvGradientOp.html">CudnnConvGradientOp</a>)</td></tr>
<tr class="separator:a5a65994e157c44fc7c7b2fc88bb67d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c17613f95bd532fba0b3e9b8e91fe8"><td class="memItemLeft" align="right" valign="top"><a id="a79c17613f95bd532fba0b3e9b8e91fe8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (Conv3D, <a class="el" href="classcaffe2_1_1CudnnConvOp.html">CudnnConvOp</a>)</td></tr>
<tr class="separator:a79c17613f95bd532fba0b3e9b8e91fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6728f13e1f07639c0a4064b50cc7487"><td class="memItemLeft" align="right" valign="top"><a id="ab6728f13e1f07639c0a4064b50cc7487"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (Conv3DGradient, <a class="el" href="classcaffe2_1_1CudnnConvGradientOp.html">CudnnConvGradientOp</a>)</td></tr>
<tr class="separator:ab6728f13e1f07639c0a4064b50cc7487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f2093f470591d86aec9503bbf58857b"><td class="memItemLeft" align="right" valign="top"><a id="a5f2093f470591d86aec9503bbf58857b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR_WITH_ENGINE</b> (Conv, EIGEN, <a class="el" href="classcaffe2_1_1EigenConvOp.html">EigenConvOp</a>&lt; float &gt;)</td></tr>
<tr class="separator:a5f2093f470591d86aec9503bbf58857b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5981b5c7ff364dbc3a58a3bd24ac81df"><td class="memItemLeft" align="right" valign="top"><a id="a5981b5c7ff364dbc3a58a3bd24ac81df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR_WITH_ENGINE</b> (Conv1D, EIGEN, <a class="el" href="classcaffe2_1_1EigenConvOp.html">EigenConvOp</a>&lt; float &gt;)</td></tr>
<tr class="separator:a5981b5c7ff364dbc3a58a3bd24ac81df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b38b7b795eb17199c291779b54cdda"><td class="memItemLeft" align="right" valign="top"><a id="ad4b38b7b795eb17199c291779b54cdda"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR_WITH_ENGINE</b> (Conv2D, EIGEN, <a class="el" href="classcaffe2_1_1EigenConvOp.html">EigenConvOp</a>&lt; float &gt;)</td></tr>
<tr class="separator:ad4b38b7b795eb17199c291779b54cdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eaa995f1db066c891e9c91639af53ce"><td class="memItemLeft" align="right" valign="top"><a id="a5eaa995f1db066c891e9c91639af53ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR_WITH_ENGINE</b> (Conv3D, EIGEN, <a class="el" href="classcaffe2_1_1EigenConvOp.html">EigenConvOp</a>&lt; float &gt;)</td></tr>
<tr class="separator:a5eaa995f1db066c891e9c91639af53ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0080513a31b41074defde34c59a7631d"><td class="memItemLeft" align="right" valign="top"><a id="a0080513a31b41074defde34c59a7631d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Conv, <a class="el" href="classcaffe2_1_1ConvOp.html">ConvOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a0080513a31b41074defde34c59a7631d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d484f11ab3fc6b654748ee90835d42"><td class="memItemLeft" align="right" valign="top"><a id="aa4d484f11ab3fc6b654748ee90835d42"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (ConvGradient, <a class="el" href="classcaffe2_1_1ConvGradientOp.html">ConvGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aa4d484f11ab3fc6b654748ee90835d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2670912f01d9b13ad0c7f051fb231eaa"><td class="memItemLeft" align="right" valign="top"><a id="a2670912f01d9b13ad0c7f051fb231eaa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Conv1D, <a class="el" href="classcaffe2_1_1ConvOp.html">ConvOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a2670912f01d9b13ad0c7f051fb231eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8b3d9c6aa7dbcd9e4e1778bd7eb761"><td class="memItemLeft" align="right" valign="top"><a id="a2f8b3d9c6aa7dbcd9e4e1778bd7eb761"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Conv1DGradient, <a class="el" href="classcaffe2_1_1ConvGradientOp.html">ConvGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a2f8b3d9c6aa7dbcd9e4e1778bd7eb761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3c0504914ea9f630a02b80e96233c0"><td class="memItemLeft" align="right" valign="top"><a id="a6e3c0504914ea9f630a02b80e96233c0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Conv2D, <a class="el" href="classcaffe2_1_1ConvOp.html">ConvOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a6e3c0504914ea9f630a02b80e96233c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e4417c57afc2b9d325a88e9ce1f47c"><td class="memItemLeft" align="right" valign="top"><a id="ad7e4417c57afc2b9d325a88e9ce1f47c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Conv2DGradient, <a class="el" href="classcaffe2_1_1ConvGradientOp.html">ConvGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ad7e4417c57afc2b9d325a88e9ce1f47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad747122b1d6b00d39fb715796975f6f"><td class="memItemLeft" align="right" valign="top"><a id="aad747122b1d6b00d39fb715796975f6f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Conv3D, <a class="el" href="classcaffe2_1_1ConvOp.html">ConvOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aad747122b1d6b00d39fb715796975f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c75eedba15c075b77730337efc10e59"><td class="memItemLeft" align="right" valign="top"><a id="a3c75eedba15c075b77730337efc10e59"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Conv3DGradient, <a class="el" href="classcaffe2_1_1ConvGradientOp.html">ConvGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a3c75eedba15c075b77730337efc10e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f88a107a6c3915d6363926a599dca0c"><td class="memTemplParams" colspan="2"><a id="a9f88a107a6c3915d6363926a599dca0c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9f88a107a6c3915d6363926a599dca0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createSharedBuffer&lt; CPUContext &gt;</b> (<a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *ws)</td></tr>
<tr class="separator:a9f88a107a6c3915d6363926a599dca0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea0c1e1bcf3b2b2d6c77ecd7f3211720"><td class="memTemplParams" colspan="2"><a id="aea0c1e1bcf3b2b2d6c77ecd7f3211720"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:aea0c1e1bcf3b2b2d6c77ecd7f3211720"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>runWithSharedBuffer</b> (<a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *ws, std::function&lt; void(<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt; *buffer)&gt; f)</td></tr>
<tr class="separator:aea0c1e1bcf3b2b2d6c77ecd7f3211720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bab26d8f00817d54cb0d975ea633123"><td class="memTemplParams" colspan="2">template&lt;typename Context &gt; </td></tr>
<tr class="memitem:a5bab26d8f00817d54cb0d975ea633123"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a5bab26d8f00817d54cb0d975ea633123">createSharedBuffer</a> (<a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *ws)</td></tr>
<tr class="memdesc:a5bab26d8f00817d54cb0d975ea633123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mutex and shared buffer in the workspace.  <a href="#a5bab26d8f00817d54cb0d975ea633123">More...</a><br /></td></tr>
<tr class="separator:a5bab26d8f00817d54cb0d975ea633123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0caaa1d4761b04f91851fb04ec265399"><td class="memTemplParams" colspan="2"><a id="a0caaa1d4761b04f91851fb04ec265399"></a>
template&lt;typename Context &gt; </td></tr>
<tr class="memitem:a0caaa1d4761b04f91851fb04ec265399"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a0caaa1d4761b04f91851fb04ec265399">runWithSharedBuffer</a> (<a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *ws, std::function&lt; void(<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; Context &gt; *buffer)&gt; f)</td></tr>
<tr class="memdesc:a0caaa1d4761b04f91851fb04ec265399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread-safe, can be invoked from RunOnDevice() to serialize access to shared buffer. <br /></td></tr>
<tr class="separator:a0caaa1d4761b04f91851fb04ec265399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498e06540c78d810ee1f4ab906a41bd8"><td class="memTemplParams" colspan="2"><a id="a498e06540c78d810ee1f4ab906a41bd8"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a498e06540c78d810ee1f4ab906a41bd8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createSharedBuffer&lt; CUDAContext &gt;</b> (<a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *ws)</td></tr>
<tr class="separator:a498e06540c78d810ee1f4ab906a41bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f5c23e200a2e32eb29c9aa761f4746"><td class="memTemplParams" colspan="2"><a id="a43f5c23e200a2e32eb29c9aa761f4746"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a43f5c23e200a2e32eb29c9aa761f4746"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>runWithSharedBuffer</b> (<a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *ws, std::function&lt; void(<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt; *buffer)&gt; f)</td></tr>
<tr class="separator:a43f5c23e200a2e32eb29c9aa761f4746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5d3e1f4bf2fcdd3da3e4c9866dd6b5"><td class="memItemLeft" align="right" valign="top"><a id="a6e5d3e1f4bf2fcdd3da3e4c9866dd6b5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ConvTransposeGradient, <a class="el" href="classcaffe2_1_1ConvTransposeGradientOp.html">ConvTransposeGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a6e5d3e1f4bf2fcdd3da3e4c9866dd6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2886c6933fd6befaa73b27927d1c6b8c"><td class="memItemLeft" align="right" valign="top"><a id="a2886c6933fd6befaa73b27927d1c6b8c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ConvTransposeGradient).NumInputs(3).NumOutputs(1</td></tr>
<tr class="separator:a2886c6933fd6befaa73b27927d1c6b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3809c4b5ea9c977ed42d9fbb0b8e704e"><td class="memItemLeft" align="right" valign="top"><a id="a3809c4b5ea9c977ed42d9fbb0b8e704e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ConvTranspose, <a class="el" href="classcaffe2_1_1GetConvTransposeGradient.html">GetConvTransposeGradient</a>)</td></tr>
<tr class="separator:a3809c4b5ea9c977ed42d9fbb0b8e704e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7221ade0eb07cf5a7cce0a034c34e8"><td class="memItemLeft" align="right" valign="top"><a id="a3c7221ade0eb07cf5a7cce0a034c34e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ConvTranspose, <a class="el" href="classcaffe2_1_1ConvTransposeOp.html">ConvTransposeOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3c7221ade0eb07cf5a7cce0a034c34e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4a49774f8642800df19058d32a450c"><td class="memItemLeft" align="right" valign="top"><a id="afa4a49774f8642800df19058d32a450c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (2, 3) .NumOutputs(1) .SetDoc(R&quot;DOC( The transposed convolution consumes an input vector</td></tr>
<tr class="separator:afa4a49774f8642800df19058d32a450c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd81a4d8d358a771423f3ebfb046701"><td class="memItemLeft" align="right" valign="top"><a id="a0fd81a4d8d358a771423f3ebfb046701"></a>
this is done throughout the image data and the output is computed As a side note on the implementation which is why they are separate files DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;X&quot;, &quot;Input data blob from previous layer; has size &quot; &quot;(N x C x H x W), where N is the batch size, C is the number of channels, and&quot; &quot; H and W are the height and width. Note that this is for the NCHW usage. On &quot; &quot;the other hand, the NHWC Op has a different set of dimension constraints.&quot;) .Input(1</td></tr>
<tr class="separator:a0fd81a4d8d358a771423f3ebfb046701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a52acc2a6e4814b467101edb9dfe022"><td class="memItemLeft" align="right" valign="top"><a id="a6a52acc2a6e4814b467101edb9dfe022"></a>
has&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (M x C x kH x kW)</td></tr>
<tr class="separator:a6a52acc2a6e4814b467101edb9dfe022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732bfd2b893a44bd6ee26820f6eb0345"><td class="memItemLeft" align="right" valign="top"><a id="a732bfd2b893a44bd6ee26820f6eb0345"></a>
has where C is the number of and kH and kW are the height and width of the kernel&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (2, &quot;bias&quot;, &quot;The 1D bias blob that is added through the convolution;&quot; &quot;has size (C). Optional, if not passed, will treat it as all 0.&quot;) .Output(0</td></tr>
<tr class="separator:a732bfd2b893a44bd6ee26820f6eb0345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8e8432ee0a969ed41eecea44dd07a3"><td class="memItemLeft" align="right" valign="top"><a id="a1f8e8432ee0a969ed41eecea44dd07a3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (ConvTranspose, <a class="el" href="classcaffe2_1_1CudnnConvTransposeOp.html">CudnnConvTransposeOp</a>&lt; float &gt;)</td></tr>
<tr class="separator:a1f8e8432ee0a969ed41eecea44dd07a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b5c15ee4460f36e2d806f31ad868a19"><td class="memItemLeft" align="right" valign="top"><a id="a0b5c15ee4460f36e2d806f31ad868a19"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (ConvTransposeGradient, <a class="el" href="classcaffe2_1_1CudnnConvTransposeGradientOp.html">CudnnConvTransposeGradientOp</a>&lt; float &gt;)</td></tr>
<tr class="separator:a0b5c15ee4460f36e2d806f31ad868a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467c89d9a81c34c23afc470ad0f46355"><td class="memItemLeft" align="right" valign="top"><a id="a467c89d9a81c34c23afc470ad0f46355"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (ConvTranspose, <a class="el" href="classcaffe2_1_1ConvTransposeOp.html">ConvTransposeOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a467c89d9a81c34c23afc470ad0f46355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9257b79fa1cebcfe21372c7b61c2b182"><td class="memItemLeft" align="right" valign="top"><a id="a9257b79fa1cebcfe21372c7b61c2b182"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (ConvTransposeGradient, <a class="el" href="classcaffe2_1_1ConvTransposeGradientOp.html">ConvTransposeGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a9257b79fa1cebcfe21372c7b61c2b182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7091fca08890f3b0c3cb72e3aac66491"><td class="memItemLeft" align="right" valign="top"><a id="a7091fca08890f3b0c3cb72e3aac66491"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Cos, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1CosCPUFunctor.html">CosCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:a7091fca08890f3b0c3cb72e3aac66491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c860f817f6c9e8ca25d0394e324722"><td class="memItemLeft" align="right" valign="top"><a id="ae7c860f817f6c9e8ca25d0394e324722"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CosGradient, <a class="el" href="classcaffe2_1_1BinaryElementwiseOp.html">BinaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1WithoutBroadcast.html">WithoutBroadcast</a>&lt; <a class="el" href="structcaffe2_1_1CosGradientCPUFunctor.html">CosGradientCPUFunctor</a> &gt;&gt;)</td></tr>
<tr class="separator:ae7c860f817f6c9e8ca25d0394e324722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5ad69932bf57b804104f6d28904019"><td class="memItemLeft" align="right" valign="top"><a id="adf5ad69932bf57b804104f6d28904019"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (CosGradient).NumInputs(2).NumOutputs(1).IdenticalTypeAndShape()</td></tr>
<tr class="separator:adf5ad69932bf57b804104f6d28904019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc548c2c8f9a883536882f1ba0860f2"><td class="memItemLeft" align="right" valign="top"><a id="a5fc548c2c8f9a883536882f1ba0860f2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Cos, <a class="el" href="classcaffe2_1_1GetCosGradient.html">GetCosGradient</a>)</td></tr>
<tr class="separator:a5fc548c2c8f9a883536882f1ba0860f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa7665df55970fa98126428f43a61fd"><td class="memItemLeft" align="right" valign="top"><a id="aefa7665df55970fa98126428f43a61fd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CosineEmbeddingCriterion, <a class="el" href="classcaffe2_1_1CosineEmbeddingCriterionOp.html">CosineEmbeddingCriterionOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aefa7665df55970fa98126428f43a61fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6eb38b712b2fff805f5b7eea6dd4f4f"><td class="memItemLeft" align="right" valign="top"><a id="ac6eb38b712b2fff805f5b7eea6dd4f4f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CosineEmbeddingCriterionGradient, <a class="el" href="classcaffe2_1_1CosineEmbeddingCriterionGradientOp.html">CosineEmbeddingCriterionGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac6eb38b712b2fff805f5b7eea6dd4f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed8fef54afee9a213146e58071ff945"><td class="memItemLeft" align="right" valign="top"><a id="a7ed8fef54afee9a213146e58071ff945"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CreateCounter, <a class="el" href="classcaffe2_1_1CreateCounterOp.html">CreateCounterOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7ed8fef54afee9a213146e58071ff945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ce03ab286c508bef6e2f333f7ba209"><td class="memItemLeft" align="right" valign="top"><a id="a14ce03ab286c508bef6e2f333f7ba209"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ResetCounter, <a class="el" href="classcaffe2_1_1ResetCounterOp.html">ResetCounterOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a14ce03ab286c508bef6e2f333f7ba209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2cc9daa694e95b811d5b931601eb59"><td class="memItemLeft" align="right" valign="top"><a id="a7a2cc9daa694e95b811d5b931601eb59"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CountDown, <a class="el" href="classcaffe2_1_1CountDownOp.html">CountDownOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7a2cc9daa694e95b811d5b931601eb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce152bf1ed15524a042b3be386d9171"><td class="memItemLeft" align="right" valign="top"><a id="a2ce152bf1ed15524a042b3be386d9171"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CheckCounterDone, <a class="el" href="classcaffe2_1_1CheckCounterDoneOp.html">CheckCounterDoneOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a2ce152bf1ed15524a042b3be386d9171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af776edd8c4b941a72a3f1c2f0a7b038f"><td class="memItemLeft" align="right" valign="top"><a id="af776edd8c4b941a72a3f1c2f0a7b038f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CountUp, <a class="el" href="classcaffe2_1_1CountUpOp.html">CountUpOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af776edd8c4b941a72a3f1c2f0a7b038f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eed2de4731cd839dc300a62974cbcde"><td class="memItemLeft" align="right" valign="top"><a id="a7eed2de4731cd839dc300a62974cbcde"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RetrieveCount, <a class="el" href="classcaffe2_1_1RetrieveCountOp.html">RetrieveCountOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7eed2de4731cd839dc300a62974cbcde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e4481234122fbafe76fb2c4a614e71"><td class="memItemLeft" align="right" valign="top"><a id="a06e4481234122fbafe76fb2c4a614e71"></a>
A blob pointing to an instance of a new counter&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;init_count&quot;, &quot;Initial count for the counter, must be &gt;= 0.&quot;)</td></tr>
<tr class="separator:a06e4481234122fbafe76fb2c4a614e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde2227993b2b7ab98bd442d0a0c0cf5"><td class="memItemLeft" align="right" valign="top"><a id="adde2227993b2b7ab98bd442d0a0c0cf5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Resets a count-down counter with initial value specified by the 'init_count'
argument.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:adde2227993b2b7ab98bd442d0a0c0cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb0d2e493bfe3692b6fc9ec51c89443"><td class="memItemLeft" align="right" valign="top"><a id="aafb0d2e493bfe3692b6fc9ec51c89443"></a>
A blob pointing to an instance of a new counter&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;previous_value&quot;, &quot;(optional) Previous value of the counter.&quot;) .Arg(&quot;init_count&quot;</td></tr>
<tr class="separator:aafb0d2e493bfe3692b6fc9ec51c89443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045b0015362f294d90b189d378ee448b"><td class="memItemLeft" align="right" valign="top"><a id="a045b0015362f294d90b189d378ee448b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CreateCounter, <a class="el" href="classcaffe2_1_1CreateCounterOp.html">CreateCounterOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a045b0015362f294d90b189d378ee448b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4aaff7be981c8f50228bf65129fe16"><td class="memItemLeft" align="right" valign="top"><a id="aeb4aaff7be981c8f50228bf65129fe16"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (ResetCounter, <a class="el" href="classcaffe2_1_1ResetCounterOp.html">ResetCounterOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aeb4aaff7be981c8f50228bf65129fe16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092617e34390d060ade14cf0f428b7e4"><td class="memItemLeft" align="right" valign="top"><a id="a092617e34390d060ade14cf0f428b7e4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CountDown, <a class="el" href="classcaffe2_1_1CountDownOp.html">CountDownOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a092617e34390d060ade14cf0f428b7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5414b411f8598bdcf7a5759273f5dbc0"><td class="memItemLeft" align="right" valign="top"><a id="a5414b411f8598bdcf7a5759273f5dbc0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CheckCounterDone, <a class="el" href="classcaffe2_1_1CheckCounterDoneOp.html">CheckCounterDoneOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a5414b411f8598bdcf7a5759273f5dbc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e2919309940df0230167b891aa4460"><td class="memItemLeft" align="right" valign="top"><a id="a67e2919309940df0230167b891aa4460"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CountUp, <a class="el" href="classcaffe2_1_1CountUpOp.html">CountUpOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a67e2919309940df0230167b891aa4460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd301bfab132a9b2529d1e05a6185f5"><td class="memItemLeft" align="right" valign="top"><a id="abfd301bfab132a9b2529d1e05a6185f5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (RetrieveCount, <a class="el" href="classcaffe2_1_1RetrieveCountOp.html">RetrieveCountOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:abfd301bfab132a9b2529d1e05a6185f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af06db80a0517868754937406c34a8544"><td class="memItemLeft" align="right" valign="top"><a id="af06db80a0517868754937406c34a8544"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classcaffe2_1_1detail_1_1WorkspaceStack.html">detail::WorkspaceStack</a>)</td></tr>
<tr class="separator:af06db80a0517868754937406c34a8544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8604e71023fd1d73c9c4940e3ee41b"><td class="memItemLeft" align="right" valign="top"><a id="aca8604e71023fd1d73c9c4940e3ee41b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CreateScope, <a class="el" href="classcaffe2_1_1CreateScopeOp.html">CreateScopeOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aca8604e71023fd1d73c9c4940e3ee41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57ae8ea03d63bc92f1be201ecc25eef"><td class="memItemLeft" align="right" valign="top"><a id="aa57ae8ea03d63bc92f1be201ecc25eef"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (CreateScope)</td></tr>
<tr class="separator:aa57ae8ea03d63bc92f1be201ecc25eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb85c896ba4e9c67180b6a2dd5ab282"><td class="memItemLeft" align="right" valign="top"><a id="aabb85c896ba4e9c67180b6a2dd5ab282"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (CreateScope).NumInputs(0).NumOutputs(1).SetDoc(R&quot;DOC( 'CreateScope' operator initializes and outputs empty scope that is used by Do operator to store local blobs )DOC&quot;)</td></tr>
<tr class="separator:aabb85c896ba4e9c67180b6a2dd5ab282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4c0f2068c0ef86c22c5deb60c8130d"><td class="memItemLeft" align="right" valign="top"><a id="a2a4c0f2068c0ef86c22c5deb60c8130d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (HasScope, <a class="el" href="classcaffe2_1_1HasScopeOp.html">HasScopeOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a2a4c0f2068c0ef86c22c5deb60c8130d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33ddc7882e5c7d177c933870427f0d7"><td class="memItemLeft" align="right" valign="top"><a id="ae33ddc7882e5c7d177c933870427f0d7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (HasScope)</td></tr>
<tr class="separator:ae33ddc7882e5c7d177c933870427f0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ec89b16557060167a914f41aae3b95"><td class="memItemLeft" align="right" valign="top"><a id="ad8ec89b16557060167a914f41aae3b95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (HasScope).NumInputs(1).NumOutputs(1).SetDoc(R&quot;DOC( Checks whether scope blob has any saved scopes left )DOC&quot;)</td></tr>
<tr class="separator:ad8ec89b16557060167a914f41aae3b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c4396fc145639b103c925214fbc6303"><td class="memItemLeft" align="right" valign="top"><a id="a7c4396fc145639b103c925214fbc6303"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LabelCrossEntropy, <a class="el" href="classcaffe2_1_1LabelCrossEntropyOp.html">LabelCrossEntropyOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7c4396fc145639b103c925214fbc6303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312a993638b53afa2e9a3c6d3a0972e6"><td class="memItemLeft" align="right" valign="top"><a id="a312a993638b53afa2e9a3c6d3a0972e6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LabelCrossEntropyGradient, <a class="el" href="classcaffe2_1_1LabelCrossEntropyGradientOp.html">LabelCrossEntropyGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a312a993638b53afa2e9a3c6d3a0972e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fac92325ef05152864e9766045abab"><td class="memItemLeft" align="right" valign="top"><a id="a32fac92325ef05152864e9766045abab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
<a class="el" href="classcaffe2_1_1Operator.html">Operator</a> computes the cross entropy between the input and the label set. In
 practice, it is most commonly used at the end of models, after the SoftMax
 operator and before the <a class="el" href="classcaffe2_1_1AveragedLoss.html">AveragedLoss</a> operator. Note that LabelCrossEntropy
 assumes that the label provided is either a 1D array of size N (batch size), or
 a 2D array of size N x 1 (batch size). Each entry in the label vector indicates
 which is the correct class; as such, each entry must be between 0 and D - 1,
 inclusive, where D is the total number of classes. The formula used is:

                            Y[i] = -log(X[i][j])

 where (i, j) is the classifier's prediction of the jth class (the correct one),
 and i is the batch size. Each log has a lower limit for numerical stability.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:a32fac92325ef05152864e9766045abab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a26ea8edff3d509f0a2ac20534329b"><td class="memItemLeft" align="right" valign="top"><a id="ae1a26ea8edff3d509f0a2ac20534329b"></a>
X is a array of size N x where N is the batch size and D is the number of classes&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;label&quot;, &quot;<a class="el" href="classcaffe2_1_1Blob.html">Blob</a> containing the labels used to compare the input&quot;) .Output(0</td></tr>
<tr class="separator:ae1a26ea8edff3d509f0a2ac20534329b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a042db7e40bc940d4c8621a642a4001"><td class="memItemLeft" align="right" valign="top"><a id="a8a042db7e40bc940d4c8621a642a4001"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (LabelCrossEntropy, <a class="el" href="classcaffe2_1_1GetLabelCrossEntropyGradient.html">GetLabelCrossEntropyGradient</a>)</td></tr>
<tr class="separator:a8a042db7e40bc940d4c8621a642a4001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465467c9f5367cc0dad262ca2185848c"><td class="memItemLeft" align="right" valign="top"><a id="a465467c9f5367cc0dad262ca2185848c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MakeTwoClass, <a class="el" href="classcaffe2_1_1MakeTwoClassOp.html">MakeTwoClassOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a465467c9f5367cc0dad262ca2185848c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafe7fba6fa17a784791c76c60c4a28c"><td class="memItemLeft" align="right" valign="top"><a id="aaafe7fba6fa17a784791c76c60c4a28c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MakeTwoClassGradient, <a class="el" href="classcaffe2_1_1MakeTwoClassGradientOp.html">MakeTwoClassGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aaafe7fba6fa17a784791c76c60c4a28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab292b58d85aeff0ac8d19e47458baaad"><td class="memItemLeft" align="right" valign="top"><a id="ab292b58d85aeff0ac8d19e47458baaad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SigmoidCrossEntropyWithLogits, <a class="el" href="classcaffe2_1_1SigmoidCrossEntropyWithLogitsOp.html">SigmoidCrossEntropyWithLogitsOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab292b58d85aeff0ac8d19e47458baaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd06f57da40b896837de2110f2898e9"><td class="memItemLeft" align="right" valign="top"><a id="a4fd06f57da40b896837de2110f2898e9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SigmoidCrossEntropyWithLogitsGradient, <a class="el" href="classcaffe2_1_1SigmoidCrossEntropyWithLogitsGradientOp.html">SigmoidCrossEntropyWithLogitsGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4fd06f57da40b896837de2110f2898e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0335af892586700897d690af0cf6ffc6"><td class="memItemLeft" align="right" valign="top"><a id="a0335af892586700897d690af0cf6ffc6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (WeightedSigmoidCrossEntropyWithLogits, <a class="el" href="classcaffe2_1_1WeightedSigmoidCrossEntropyWithLogitsOp.html">WeightedSigmoidCrossEntropyWithLogitsOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a0335af892586700897d690af0cf6ffc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceca955ee067384ace9f0c1d1676f3cc"><td class="memItemLeft" align="right" valign="top"><a id="aceca955ee067384ace9f0c1d1676f3cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (WeightedSigmoidCrossEntropyWithLogitsGradient, <a class="el" href="classcaffe2_1_1WeightedSigmoidCrossEntropyWithLogitsGradientOp.html">WeightedSigmoidCrossEntropyWithLogitsGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aceca955ee067384ace9f0c1d1676f3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278002796a245b82d2176c6d3af198dd"><td class="memItemLeft" align="right" valign="top"><a id="a278002796a245b82d2176c6d3af198dd"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (in[0].dims(0))</td></tr>
<tr class="separator:a278002796a245b82d2176c6d3af198dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e47da95b0cd124065dfa39a4aaa991"><td class="memItemLeft" align="right" valign="top"><a id="a30e47da95b0cd124065dfa39a4aaa991"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (2)</td></tr>
<tr class="separator:a30e47da95b0cd124065dfa39a4aaa991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8d33f03ea68a26aa820ad4fa264421"><td class="memItemLeft" align="right" valign="top"><a id="a6f8d33f03ea68a26aa820ad4fa264421"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given a vector of probabilities, this operator transforms this into a 2-column
 matrix with complimentary probabilities for binary classification. In explicit
 terms, given the vector X, the output Y is vstack(1 - X, X).
  )DOC&quot;) .Input(0</td></tr>
<tr class="separator:a6f8d33f03ea68a26aa820ad4fa264421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8583f64824b5aec689c8a7ce637f8c"><td class="memItemLeft" align="right" valign="top"><a id="aab8583f64824b5aec689c8a7ce637f8c"></a>
Input vector of probabilities&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;Y&quot;, &quot;2-column matrix with complimentary probabilities of X for &quot; &quot;binary classification&quot;)</td></tr>
<tr class="separator:aab8583f64824b5aec689c8a7ce637f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee01848054011cf093cc8d5a55c5712"><td class="memItemLeft" align="right" valign="top"><a id="a0ee01848054011cf093cc8d5a55c5712"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given two matrices logits and targets, of same shape,
(batch_size, num_classes), computes the sigmoid cross entropy between the two.
Returns a tensor of shape (batch_size,) of losses for each example.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:a0ee01848054011cf093cc8d5a55c5712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373a828e0a4ce35358a21fdf628dfca2"><td class="memItemLeft" align="right" valign="top"><a id="a373a828e0a4ce35358a21fdf628dfca2"></a>
matrix of logits for each example and class&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;targets&quot;, &quot;matrix of targets, same shape as logits.&quot;) .Output(0</td></tr>
<tr class="separator:a373a828e0a4ce35358a21fdf628dfca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c8ae6a912387b2c6a459cbbdcdaf68"><td class="memItemLeft" align="right" valign="top"><a id="a56c8ae6a912387b2c6a459cbbdcdaf68"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given three matrices: logits, targets, weights, all of the same shape,
(batch_size, num_classes), computes the weighted sigmoid cross entropy between
logits and targets. Specifically, at each position r,c, this computes
weights[r, c] * crossentropy(sigmoid(logits[r, c]), targets[r, c]), and then
averages over each row.
Returns a tensor of shape (batch_size,) of losses for each example.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:a56c8ae6a912387b2c6a459cbbdcdaf68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb4946f0407391e5684093446c279aa"><td class="memItemLeft" align="right" valign="top"><a id="adfb4946f0407391e5684093446c279aa"></a>
matrix of logits for each example and class matrix of same shape as logits&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;xentropy&quot;, &quot;Vector with the total xentropy for each example.&quot;)</td></tr>
<tr class="separator:adfb4946f0407391e5684093446c279aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891d9a20f084eef6b1da5c8099a88ca4"><td class="memItemLeft" align="right" valign="top"><a id="a891d9a20f084eef6b1da5c8099a88ca4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (4) .NumOutputs(1)</td></tr>
<tr class="separator:a891d9a20f084eef6b1da5c8099a88ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a3b8b865de49c0da833bddb86fc6e1"><td class="memItemLeft" align="right" valign="top"><a id="a47a3b8b865de49c0da833bddb86fc6e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (MakeTwoClass, <a class="el" href="structcaffe2_1_1GetMakeTwoClassGradient.html">GetMakeTwoClassGradient</a>)</td></tr>
<tr class="separator:a47a3b8b865de49c0da833bddb86fc6e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e7429af1d9a8a5bc5bf0eb3c9642248"><td class="memItemLeft" align="right" valign="top"><a id="a0e7429af1d9a8a5bc5bf0eb3c9642248"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SigmoidCrossEntropyWithLogits, <a class="el" href="structcaffe2_1_1GetSigmoidCrossEntropyWithLogitsGradient.html">GetSigmoidCrossEntropyWithLogitsGradient</a>)</td></tr>
<tr class="separator:a0e7429af1d9a8a5bc5bf0eb3c9642248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26b537f56129874abbc9a77b8db4662"><td class="memItemLeft" align="right" valign="top"><a id="ae26b537f56129874abbc9a77b8db4662"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (WeightedSigmoidCrossEntropyWithLogits, <a class="el" href="structcaffe2_1_1GetWeightedSigmoidCrossEntropyWithLogitsGradient.html">GetWeightedSigmoidCrossEntropyWithLogitsGradient</a>)</td></tr>
<tr class="separator:ae26b537f56129874abbc9a77b8db4662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af09c375cd2a4f9d14a61ce1935028f47"><td class="memItemLeft" align="right" valign="top"><a id="af09c375cd2a4f9d14a61ce1935028f47"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CrossEntropy, <a class="el" href="classcaffe2_1_1CrossEntropyOp.html">CrossEntropyOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af09c375cd2a4f9d14a61ce1935028f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84c43849ee5c2af009b8f64b665020b"><td class="memItemLeft" align="right" valign="top"><a id="ac84c43849ee5c2af009b8f64b665020b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CrossEntropyGradient, <a class="el" href="classcaffe2_1_1CrossEntropyGradientOp.html">CrossEntropyGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac84c43849ee5c2af009b8f64b665020b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e474c698782ff82370792d8aabe19b"><td class="memItemLeft" align="right" valign="top"><a id="a96e474c698782ff82370792d8aabe19b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
<a class="el" href="classcaffe2_1_1Operator.html">Operator</a> computes the cross entropy between the input and the label set. In
 practice, it is most commonly used at the end of models, after the SoftMax
 operator and before the <a class="el" href="classcaffe2_1_1AveragedLoss.html">AveragedLoss</a> operator. Note that CrossEntropy
 assumes that the soft labels provided is a 2D array of size N x D
 (batch size x number of classes). Each entry in the 2D label corresponds to
 the soft label for the input, where each element represents the correct
 probability of the class being selected. As such, each element must be between
 0 and 1, and all elements in an entry must sum to 1. The formula used is:

                Y[i] = sum_j (label[i][j] * log(X[i][j]))

 where (i, j) is the classifier's prediction of the jth class (the correct one),
 and i is the batch size. Each log has a lower limit for numerical stability.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:a96e474c698782ff82370792d8aabe19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83144fc9b38a5895eaf15458e5ef170a"><td class="memItemLeft" align="right" valign="top"><a id="a83144fc9b38a5895eaf15458e5ef170a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (CrossEntropy, <a class="el" href="classcaffe2_1_1GetCrossEntropyGradient.html">GetCrossEntropyGradient</a>)</td></tr>
<tr class="separator:a83144fc9b38a5895eaf15458e5ef170a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc919c49f725b3492fe44ef3536aa3af"><td class="memItemLeft" align="right" valign="top"><a id="abc919c49f725b3492fe44ef3536aa3af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1dataset__ops_1_1TreeCursor.html">dataset_ops::TreeCursor</a> &gt;)</td></tr>
<tr class="separator:abc919c49f725b3492fe44ef3536aa3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b61e82c723cf3dc8daa4fc5afb9827"><td class="memItemLeft" align="right" valign="top"><a id="a96b61e82c723cf3dc8daa4fc5afb9827"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (dataset_ops::TensorVectorPtr&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a96b61e82c723cf3dc8daa4fc5afb9827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19caef35d3f96aa748efe387890d0985"><td class="memItemLeft" align="right" valign="top"><a id="a19caef35d3f96aa748efe387890d0985"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (dataset_ops::SharedTensorVectorPtr)</td></tr>
<tr class="separator:a19caef35d3f96aa748efe387890d0985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af300ffee8007add914d05020c1a4fb1a"><td class="memItemLeft" align="right" valign="top"><a id="af300ffee8007add914d05020c1a4fb1a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (DeformConvGradient).NumInputs(4</td></tr>
<tr class="separator:af300ffee8007add914d05020c1a4fb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc270ee9705bfa4ee30f052e337f7350"><td class="memItemLeft" align="right" valign="top"><a id="acc270ee9705bfa4ee30f052e337f7350"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumOutputs</b> (2, 4)</td></tr>
<tr class="separator:acc270ee9705bfa4ee30f052e337f7350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759c87f7659eb48d10d55307e0434848"><td class="memItemLeft" align="right" valign="top"><a id="a759c87f7659eb48d10d55307e0434848"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SquaredL2Distance, <a class="el" href="classcaffe2_1_1SquaredL2DistanceOp.html">SquaredL2DistanceOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a759c87f7659eb48d10d55307e0434848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193ee1375b1ba85a1cd7a766ea6ae047"><td class="memItemLeft" align="right" valign="top"><a id="a193ee1375b1ba85a1cd7a766ea6ae047"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SquaredL2DistanceGradient, <a class="el" href="classcaffe2_1_1SquaredL2DistanceGradientOp.html">SquaredL2DistanceGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a193ee1375b1ba85a1cd7a766ea6ae047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cd0f2da968e2784a4db363ed5d794e"><td class="memItemLeft" align="right" valign="top"><a id="a06cd0f2da968e2784a4db363ed5d794e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
  Given two input float tensors X, Y, and produces one output float tensor
  of the L2 difference between X and Y that is computed as ||(X - Y)^2 / 2||.
  )DOC&quot;) .Input(0</td></tr>
<tr class="separator:a06cd0f2da968e2784a4db363ed5d794e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d00856eede77781c1b4a4cb9caea82"><td class="memItemLeft" align="right" valign="top"><a id="a84d00856eede77781c1b4a4cb9caea82"></a>
or input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;Y&quot;, &quot;1D or 2D input tensor (must have the same shape as X)&quot;) .Output(0</td></tr>
<tr class="separator:a84d00856eede77781c1b4a4cb9caea82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9535174dd8f5bea5c9f4d729a323bd04"><td class="memItemLeft" align="right" valign="top"><a id="a9535174dd8f5bea5c9f4d729a323bd04"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (SquaredL2DistanceGradient).NumInputs(3).NumOutputs(2)</td></tr>
<tr class="separator:a9535174dd8f5bea5c9f4d729a323bd04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58166fd9b119bfdcd330b7ca74bc1f0c"><td class="memItemLeft" align="right" valign="top"><a id="a58166fd9b119bfdcd330b7ca74bc1f0c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SquaredL2Distance, <a class="el" href="classcaffe2_1_1GetSquaredL2DistanceGradient.html">GetSquaredL2DistanceGradient</a>)</td></tr>
<tr class="separator:a58166fd9b119bfdcd330b7ca74bc1f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d4093899c29097437b6d788a182f4f"><td class="memItemLeft" align="right" valign="top"><a id="a66d4093899c29097437b6d788a182f4f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (L1Distance, <a class="el" href="classcaffe2_1_1L1DistanceOp.html">L1DistanceOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a66d4093899c29097437b6d788a182f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7868e35ea4a154b4ef0846da048a1a"><td class="memItemLeft" align="right" valign="top"><a id="a9e7868e35ea4a154b4ef0846da048a1a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (L1DistanceGradient, <a class="el" href="classcaffe2_1_1L1DistanceGradientOp.html">L1DistanceGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9e7868e35ea4a154b4ef0846da048a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e45768ce78b2910876342100e2d7a1e"><td class="memItemLeft" align="right" valign="top"><a id="a2e45768ce78b2910876342100e2d7a1e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
  Given two input float tensors X, Y, and produces one output float tensor
  of the L1 difference between X and Y, computed as L1(x,y) = sum over |x-y|
  )DOC&quot;) .Input(0</td></tr>
<tr class="separator:a2e45768ce78b2910876342100e2d7a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dba067dd6ecf88e697a9134cc8f03a"><td class="memItemLeft" align="right" valign="top"><a id="a03dba067dd6ecf88e697a9134cc8f03a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (L1DistanceGradient).NumInputs(3).NumOutputs(2)</td></tr>
<tr class="separator:a03dba067dd6ecf88e697a9134cc8f03a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb2394c679844ae159d8b01ce847c6c"><td class="memItemLeft" align="right" valign="top"><a id="a4eb2394c679844ae159d8b01ce847c6c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (L1Distance, <a class="el" href="classcaffe2_1_1GetL1DistanceGradient.html">GetL1DistanceGradient</a>)</td></tr>
<tr class="separator:a4eb2394c679844ae159d8b01ce847c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adc5be29a915c4fd711df9ec1005176"><td class="memItemLeft" align="right" valign="top"><a id="a4adc5be29a915c4fd711df9ec1005176"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DotProduct, <a class="el" href="classcaffe2_1_1DotProductOp.html">DotProductOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4adc5be29a915c4fd711df9ec1005176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88847c6a3482af154ce49fa4e5b8708"><td class="memItemLeft" align="right" valign="top"><a id="aa88847c6a3482af154ce49fa4e5b8708"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DotProductGradient, <a class="el" href="classcaffe2_1_1DotProductGradientOp.html">DotProductGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa88847c6a3482af154ce49fa4e5b8708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afaeeffbd82b629191c236002942888"><td class="memItemLeft" align="right" valign="top"><a id="a5afaeeffbd82b629191c236002942888"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
  Given two input float tensors X, Y, and produces one output float tensor
  of the dot product between X and Y.
  )DOC&quot;) .Input(0</td></tr>
<tr class="separator:a5afaeeffbd82b629191c236002942888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abb0efe4e8e91bb3f21451535faa3bc"><td class="memItemLeft" align="right" valign="top"><a id="a6abb0efe4e8e91bb3f21451535faa3bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (DotProductGradient).NumInputs(3).NumOutputs(2)</td></tr>
<tr class="separator:a6abb0efe4e8e91bb3f21451535faa3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5192fbaddd9a460e2984464339f9fd"><td class="memItemLeft" align="right" valign="top"><a id="a4d5192fbaddd9a460e2984464339f9fd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (DotProduct, <a class="el" href="classcaffe2_1_1GetDotProductGradient.html">GetDotProductGradient</a>)</td></tr>
<tr class="separator:a4d5192fbaddd9a460e2984464339f9fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea4509a408b06d3e69d2764b4223462"><td class="memItemLeft" align="right" valign="top"><a id="abea4509a408b06d3e69d2764b4223462"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CosineSimilarity, <a class="el" href="classcaffe2_1_1CosineSimilarityOp.html">CosineSimilarityOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:abea4509a408b06d3e69d2764b4223462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5de21b7a7a3425f67a507a140c15c17"><td class="memItemLeft" align="right" valign="top"><a id="ae5de21b7a7a3425f67a507a140c15c17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CosineSimilarityGradient, <a class="el" href="classcaffe2_1_1CosineSimilarityGradientOp.html">CosineSimilarityGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae5de21b7a7a3425f67a507a140c15c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4274796e74313c17c07c97c0c96bb14c"><td class="memItemLeft" align="right" valign="top"><a id="a4274796e74313c17c07c97c0c96bb14c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
  Given two input float tensors X, Y, and produces one output float tensor
  of the cosine similarity between X and Y.
  )DOC&quot;) .Input(0</td></tr>
<tr class="separator:a4274796e74313c17c07c97c0c96bb14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e95453ffd4f09215d3d7b74b3c9ecfe"><td class="memItemLeft" align="right" valign="top"><a id="a8e95453ffd4f09215d3d7b74b3c9ecfe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (CosineSimilarityGradient).NumInputs(3).NumOutputs(2)</td></tr>
<tr class="separator:a8e95453ffd4f09215d3d7b74b3c9ecfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c057b06a1c2bf40ad0ca6b9e0a03ad"><td class="memItemLeft" align="right" valign="top"><a id="a46c057b06a1c2bf40ad0ca6b9e0a03ad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (CosineSimilarity, <a class="el" href="classcaffe2_1_1GetCosineSimilarityGradient.html">GetCosineSimilarityGradient</a>)</td></tr>
<tr class="separator:a46c057b06a1c2bf40ad0ca6b9e0a03ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b1efc8b1c93d426c7a5db470afbe3f"><td class="memItemLeft" align="right" valign="top"><a id="a77b1efc8b1c93d426c7a5db470afbe3f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DotProductWithPadding, <a class="el" href="classcaffe2_1_1DotProductWithPaddingOp.html">DotProductWithPaddingOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a77b1efc8b1c93d426c7a5db470afbe3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e3a56d9650d88c824460e5458bf063"><td class="memItemLeft" align="right" valign="top"><a id="a61e3a56d9650d88c824460e5458bf063"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DotProductWithPaddingGradient, <a class="el" href="classcaffe2_1_1DotProductWithPaddingGradientOp.html">DotProductWithPaddingGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a61e3a56d9650d88c824460e5458bf063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65adc026186d8ef2b70c33a4d1bce490"><td class="memItemLeft" align="right" valign="top"><a id="a65adc026186d8ef2b70c33a4d1bce490"></a>
Y with different shapes and produces one output float tensor of the dot product between X and Y We currently support two kinds of strategies to achieve this Before doing normal dot_product pad the smaller&#160;</td><td class="memItemRight" valign="bottom"><b>tensor</b> (using pad_value) to the same shape as the other one. 2) replicate the smaller tensor to the same shape as the other one. Note the first dimension of X</td></tr>
<tr class="separator:a65adc026186d8ef2b70c33a4d1bce490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b557330a79f32eb821749021d1c8ff2"><td class="memItemLeft" align="right" valign="top"><a id="a6b557330a79f32eb821749021d1c8ff2"></a>
Y with different shapes and produces one output float tensor of the dot product between X and Y We currently support two kinds of strategies to achieve this Before doing normal dot_product pad the smaller Y must be equal Only the second dimension of X or Y can be padded DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;X&quot;, &quot;1D or 2D input tensor&quot;) .Input(1</td></tr>
<tr class="separator:a6b557330a79f32eb821749021d1c8ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdeb34ad9fa269af420939203e71c8b"><td class="memItemLeft" align="right" valign="top"><a id="a2bdeb34ad9fa269af420939203e71c8b"></a>
Y with different shapes and produces one output float tensor of the dot product between X and Y We currently support two kinds of strategies to achieve this Before doing normal dot_product pad the smaller Y must be equal Only the second dimension of X or Y can be padded DOC or input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;Z&quot;, &quot;1D output tensor&quot;) .IdenticalTypeAndShapeOfInputDim(0</td></tr>
<tr class="separator:a2bdeb34ad9fa269af420939203e71c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcb69afbfa78c760bba91679aebea4c"><td class="memItemLeft" align="right" valign="top"><a id="a2bcb69afbfa78c760bba91679aebea4c"></a>
Y with different shapes and produces one output float tensor of the dot product between X and Y We currently support two kinds of strategies to achieve this Before doing normal dot_product pad the smaller Y must be equal Only the second dimension of X or Y can be padded DOC or input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;pad_value&quot;, &quot;the padding value for tensors with smaller dimension&quot;) .Arg(&quot;replicate&quot;</td></tr>
<tr class="separator:a2bcb69afbfa78c760bba91679aebea4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57062b2d63a516028d03c3aa970c564"><td class="memItemLeft" align="right" valign="top"><a id="ab57062b2d63a516028d03c3aa970c564"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (DotProductWithPaddingGradient).NumInputs(3).NumOutputs(2)</td></tr>
<tr class="separator:ab57062b2d63a516028d03c3aa970c564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afece1925a65deee851a9905ba4ef0eda"><td class="memItemLeft" align="right" valign="top"><a id="afece1925a65deee851a9905ba4ef0eda"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (DotProductWithPadding, <a class="el" href="classcaffe2_1_1GetDotProductWithPaddingGradient.html">GetDotProductWithPaddingGradient</a>)</td></tr>
<tr class="separator:afece1925a65deee851a9905ba4ef0eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a120c315e80b7dd994deb27c6de2731f5"><td class="memItemLeft" align="right" valign="top"><a id="a120c315e80b7dd994deb27c6de2731f5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Do, <a class="el" href="classcaffe2_1_1DoOp.html">DoOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a120c315e80b7dd994deb27c6de2731f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e9cf7fe49191b76ba0fa5200363276"><td class="memItemLeft" align="right" valign="top"><a id="a40e9cf7fe49191b76ba0fa5200363276"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
'Do' control operator, executes a subnet in a separate workspace.
Last blobs in the input and output lists should be the same blob created with
CreateScope op. Arguments 'inner_blobs' and 'outer_blobs_idx' provide a mapping
between selected inner blob names and corresponding outer blob indices.
    )DOC&quot;) .Arg(&quot;net&quot;</td></tr>
<tr class="separator:a40e9cf7fe49191b76ba0fa5200363276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c895c40588fdb730c205e86bed5be88"><td class="memItemLeft" align="right" valign="top"><a id="a6c895c40588fdb730c205e86bed5be88"></a>
INT_MAX Subnet with blob bindings&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;inner_blobs&quot;, &quot;List of inner net blob names to bind to outer workspace&quot;) .Arg(&quot;outer_blobs_idx&quot;</td></tr>
<tr class="separator:a6c895c40588fdb730c205e86bed5be88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9918233cb5a585cbc9c9cfd7ecd7975"><td class="memItemLeft" align="right" valign="top"><a id="ab9918233cb5a585cbc9c9cfd7ecd7975"></a>
INT_MAX Subnet with blob bindings Indices of corresponding outer workspace in&#160;</td><td class="memItemRight" valign="bottom"><b>operator outputs</b> (skipping workspace blobs)&quot;) .Arg( &quot;saved_fwd_blobs&quot;</td></tr>
<tr class="separator:ab9918233cb5a585cbc9c9cfd7ecd7975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239d76b60170a616fce1240709cb5a01"><td class="memItemLeft" align="right" valign="top"><a id="a239d76b60170a616fce1240709cb5a01"></a>
INT_MAX Subnet with blob bindings Indices of corresponding outer workspace in List of blobs from the forward Do&#160;</td><td class="memItemRight" valign="bottom"><b>operator workspace needed &quot; &quot;in backward pass, used in gradient Do operator&quot;) .Arg</b> (&quot;reuse_workspace&quot;, &quot;Whether to reuse workspace or create a new one in a given scope&quot;) .AllowInplace([](int in</td></tr>
<tr class="separator:a239d76b60170a616fce1240709cb5a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9aec77b9877ad602837148d5dff1f6"><td class="memItemLeft" align="right" valign="top"><a id="a3c9aec77b9877ad602837148d5dff1f6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Do, <a class="el" href="classcaffe2_1_1DoOp.html">DoOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a3c9aec77b9877ad602837148d5dff1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dff897b9581cf290790faf38553b148"><td class="memItemLeft" align="right" valign="top"><a id="a3dff897b9581cf290790faf38553b148"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Dropout, <a class="el" href="classcaffe2_1_1DropoutOp.html">DropoutOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3dff897b9581cf290790faf38553b148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d67348de5ef8c9e1af86d93b2e6082d"><td class="memItemLeft" align="right" valign="top"><a id="a9d67348de5ef8c9e1af86d93b2e6082d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DropoutGrad, <a class="el" href="classcaffe2_1_1DropoutGradientOp.html">DropoutGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9d67348de5ef8c9e1af86d93b2e6082d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bc968dd07b2b3f8562e3a3cd6e1b69"><td class="memItemLeft" align="right" valign="top"><a id="a37bc968dd07b2b3f8562e3a3cd6e1b69"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>AllowInplace</b> ({{0, 0}}) .TensorInferenceFunction([](const OperatorDef &amp;def</td></tr>
<tr class="separator:a37bc968dd07b2b3f8562e3a3cd6e1b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c64da77f03415ef24ee195f5be6d620"><td class="memItemLeft" align="right" valign="top"><a id="a1c64da77f03415ef24ee195f5be6d620"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (output_mask)</td></tr>
<tr class="separator:a1c64da77f03415ef24ee195f5be6d620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f08a145d2f3f98e655b1cf116ffc1d"><td class="memItemLeft" align="right" valign="top"><a id="aa0f08a145d2f3f98e655b1cf116ffc1d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Dropout takes one input data (<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt;float&gt;) and produces two <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> outputs,
output (<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt;float&gt;) and mask (<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt;bool&gt;). Depending on whether it is in
test mode or not, the output Y will either be a random dropout, or a simple
copy of the input. Note that our implementation of Dropout does scaling in
the training phase, so during testing nothing needs to be done.
)DOC&quot;) .Arg(&quot;ratio&quot;</td></tr>
<tr class="separator:aa0f08a145d2f3f98e655b1cf116ffc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd7033481cf854dc4250f302c6a24b5"><td class="memItemLeft" align="right" valign="top"><a id="a1dd7033481cf854dc4250f302c6a24b5"></a>
default the ratio of random dropout&#160;</td><td class="memItemRight" valign="bottom"><b>ArgIsTest</b> (&quot;(int) if nonzero, run dropout in test mode where &quot; &quot;the output is simply Y = X.&quot;) .Input(0</td></tr>
<tr class="separator:a1dd7033481cf854dc4250f302c6a24b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7270221ad230171ad9b4d1481142683"><td class="memItemLeft" align="right" valign="top"><a id="ae7270221ad230171ad9b4d1481142683"></a>
default the ratio of random dropout The input data as <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;output&quot;, &quot;The output.&quot;) .Output(1</td></tr>
<tr class="separator:ae7270221ad230171ad9b4d1481142683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee809be80b8cc87ce4358d03159b43a"><td class="memItemLeft" align="right" valign="top"><a id="a8ee809be80b8cc87ce4358d03159b43a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Dropout, <a class="el" href="classcaffe2_1_1GetDropoutGradient.html">GetDropoutGradient</a>)</td></tr>
<tr class="separator:a8ee809be80b8cc87ce4358d03159b43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08266a632d16a9c19ce4eec524697fd1"><td class="memItemLeft" align="right" valign="top"><a id="a08266a632d16a9c19ce4eec524697fd1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_FUNCTOR</b> (Add, EIGEN_ADD, <a class="el" href="structcaffe2_1_1TensorTypes.html">NumericTypes</a>, <a class="el" href="structcaffe2_1_1SameTypeAsInput.html">SameTypeAsInput</a>)</td></tr>
<tr class="separator:a08266a632d16a9c19ce4eec524697fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca95477b66cf6b1cf8b137f34762a1b"><td class="memItemLeft" align="right" valign="top"><a id="a4ca95477b66cf6b1cf8b137f34762a1b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_FUNCTOR</b> (Div, EIGEN_DIV, <a class="el" href="structcaffe2_1_1TensorTypes.html">NumericTypes</a>, <a class="el" href="structcaffe2_1_1SameTypeAsInput.html">SameTypeAsInput</a>)</td></tr>
<tr class="separator:a4ca95477b66cf6b1cf8b137f34762a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf1b7759200e47780e2de5f59fe5a34"><td class="memItemLeft" align="right" valign="top"><a id="abcf1b7759200e47780e2de5f59fe5a34"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ElementWiseDivide</b> (<a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &amp;, const int n, float *dXdata, float *dYdata, const float *dZdata, const float *Ydata, const float *Zdata)</td></tr>
<tr class="separator:abcf1b7759200e47780e2de5f59fe5a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462b33b4d71f254adc7d15d2d7c09514"><td class="memItemLeft" align="right" valign="top"><a id="a462b33b4d71f254adc7d15d2d7c09514"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DivGradient, <a class="el" href="classcaffe2_1_1DivGradientOp.html">DivGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a462b33b4d71f254adc7d15d2d7c09514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4696f995a2d3eda5ff8ae4ae89f967c"><td class="memItemLeft" align="right" valign="top"><a id="af4696f995a2d3eda5ff8ae4ae89f967c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ElementwiseLinear, <a class="el" href="classcaffe2_1_1ElementwiseLinearOp.html">ElementwiseLinearOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af4696f995a2d3eda5ff8ae4ae89f967c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825114a76adc85d79bd206213e1c002a"><td class="memItemLeft" align="right" valign="top"><a id="a825114a76adc85d79bd206213e1c002a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ElementwiseLinearGradient, <a class="el" href="classcaffe2_1_1ElementwiseLinearGradientOp.html">ElementwiseLinearGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a825114a76adc85d79bd206213e1c002a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6403d8b36158e391f210532d5073efbd"><td class="memItemLeft" align="right" valign="top"><a id="a6403d8b36158e391f210532d5073efbd"></a>
w of size D and b of size the op computes Y of&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (N X D) where Y_</td></tr>
<tr class="separator:a6403d8b36158e391f210532d5073efbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36cb19298d392bfba498e3ea64f14c3"><td class="memItemLeft" align="right" valign="top"><a id="ab36cb19298d392bfba498e3ea64f14c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ElementwiseLinear, <a class="el" href="structcaffe2_1_1GetElementwiseLinearGradient.html">GetElementwiseLinearGradient</a>)</td></tr>
<tr class="separator:ab36cb19298d392bfba498e3ea64f14c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df433e2a83d5a74d214fc368b119913"><td class="memItemLeft" align="right" valign="top"><a id="a4df433e2a83d5a74d214fc368b119913"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_FUNCTOR</b> (Mul, EIGEN_MUL, <a class="el" href="structcaffe2_1_1TensorTypes.html">NumericTypes</a>, <a class="el" href="structcaffe2_1_1SameTypeAsInput.html">SameTypeAsInput</a>)</td></tr>
<tr class="separator:a4df433e2a83d5a74d214fc368b119913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b38a8404e0a91adb094c1c576cb07ea"><td class="memItemLeft" align="right" valign="top"><a id="a2b38a8404e0a91adb094c1c576cb07ea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NAIVE_FUNCTOR</b> (LT, NAIVE_LT, <a class="el" href="structcaffe2_1_1TensorTypes.html">NumericTypes</a>, <a class="el" href="structcaffe2_1_1FixedType.html">FixedType</a>&lt; bool &gt;)</td></tr>
<tr class="separator:a2b38a8404e0a91adb094c1c576cb07ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1b9e96395352e08546470f6076511b"><td class="memItemLeft" align="right" valign="top"><a id="a2e1b9e96395352e08546470f6076511b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NAIVE_FUNCTOR</b> (LE, NAIVE_LE, <a class="el" href="structcaffe2_1_1TensorTypes.html">NumericTypes</a>, <a class="el" href="structcaffe2_1_1FixedType.html">FixedType</a>&lt; bool &gt;)</td></tr>
<tr class="separator:a2e1b9e96395352e08546470f6076511b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4430967dd5b8a4cf6ec69fdce51f2d11"><td class="memItemLeft" align="right" valign="top"><a id="a4430967dd5b8a4cf6ec69fdce51f2d11"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NAIVE_FUNCTOR</b> (GT, NAIVE_GT, <a class="el" href="structcaffe2_1_1TensorTypes.html">NumericTypes</a>, <a class="el" href="structcaffe2_1_1FixedType.html">FixedType</a>&lt; bool &gt;)</td></tr>
<tr class="separator:a4430967dd5b8a4cf6ec69fdce51f2d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fb4df4003709084e82e33367d6e3e35"><td class="memItemLeft" align="right" valign="top"><a id="a2fb4df4003709084e82e33367d6e3e35"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NAIVE_FUNCTOR</b> (GE, NAIVE_GE, <a class="el" href="structcaffe2_1_1TensorTypes.html">NumericTypes</a>, <a class="el" href="structcaffe2_1_1FixedType.html">FixedType</a>&lt; bool &gt;)</td></tr>
<tr class="separator:a2fb4df4003709084e82e33367d6e3e35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd741b424bd401894b7128d78db79431"><td class="memItemLeft" align="right" valign="top"><a id="abd741b424bd401894b7128d78db79431"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NAIVE_FUNCTOR</b> (EQ, NAIVE_EQ, <a class="el" href="structcaffe2_1_1TensorTypes.html">IntTypes</a>, <a class="el" href="structcaffe2_1_1FixedType.html">FixedType</a>&lt; bool &gt;)</td></tr>
<tr class="separator:abd741b424bd401894b7128d78db79431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9245c10717ae88926a31aa7fe1d2b256"><td class="memItemLeft" align="right" valign="top"><a id="a9245c10717ae88926a31aa7fe1d2b256"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NAIVE_FUNCTOR</b> (And, NAIVE_AND, <a class="el" href="structcaffe2_1_1TensorTypes.html">BoolTypes</a>, <a class="el" href="structcaffe2_1_1FixedType.html">FixedType</a>&lt; bool &gt;)</td></tr>
<tr class="separator:a9245c10717ae88926a31aa7fe1d2b256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae033c619860e02091bb52d14a14c81"><td class="memItemLeft" align="right" valign="top"><a id="a6ae033c619860e02091bb52d14a14c81"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NAIVE_FUNCTOR</b> (Or, NAIVE_OR, <a class="el" href="structcaffe2_1_1TensorTypes.html">BoolTypes</a>, <a class="el" href="structcaffe2_1_1FixedType.html">FixedType</a>&lt; bool &gt;)</td></tr>
<tr class="separator:a6ae033c619860e02091bb52d14a14c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fe1db1548b22bf37d5e7c738d2c7817"><td class="memItemLeft" align="right" valign="top"><a id="a8fe1db1548b22bf37d5e7c738d2c7817"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NAIVE_FUNCTOR</b> (Xor, NAIVE_XOR, <a class="el" href="structcaffe2_1_1TensorTypes.html">BoolTypes</a>, <a class="el" href="structcaffe2_1_1FixedType.html">FixedType</a>&lt; bool &gt;)</td></tr>
<tr class="separator:a8fe1db1548b22bf37d5e7c738d2c7817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d86e3060f692b7242a0a7ba8d2ac4b"><td class="memItemLeft" align="right" valign="top"><a id="a67d86e3060f692b7242a0a7ba8d2ac4b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Not, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">BoolTypes</a>, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1NotFunctor.html">NotFunctor</a> &gt;)</td></tr>
<tr class="separator:a67d86e3060f692b7242a0a7ba8d2ac4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5090bd618e12592070b3ac536c5a052"><td class="memItemLeft" align="right" valign="top"><a id="ad5090bd618e12592070b3ac536c5a052"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SumReduceLike, <a class="el" href="classcaffe2_1_1SumReduceLikeOp.html">SumReduceLikeOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad5090bd618e12592070b3ac536c5a052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc070707141ec0d42d8f9e84505d42b4"><td class="memTemplParams" colspan="2"><a id="acc070707141ec0d42d8f9e84505d42b4"></a>
template&lt;typename Context &gt; </td></tr>
<tr class="memitem:acc070707141ec0d42d8f9e84505d42b4"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; size_t, size_t, size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>calculate_broadcast_sizes</b> (const <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; Context &gt; &amp;A, const <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; Context &gt; &amp;B, int axis)</td></tr>
<tr class="separator:acc070707141ec0d42d8f9e84505d42b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad0d3b54b10f1c66809f96fb596dbf0"><td class="memItemLeft" align="right" valign="top"><a id="a3ad0d3b54b10f1c66809f96fb596dbf0"></a>
std::function&lt; void(<a class="el" href="classcaffe2_1_1OpSchema.html">OpSchema</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MathDocGenerator</b> (const char *name)</td></tr>
<tr class="separator:a3ad0d3b54b10f1c66809f96fb596dbf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29fb4b6f074b9afc2cf3070ebb1fc56"><td class="memItemLeft" align="right" valign="top"><a id="ab29fb4b6f074b9afc2cf3070ebb1fc56"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CostInferenceFunction</b> (PointwiseCostInference&lt; 1 &gt;) .IdenticalTypeAndShapeOfInput(0) .FillUsing(MathDocGenerator(&quot;addition&quot;))</td></tr>
<tr class="separator:ab29fb4b6f074b9afc2cf3070ebb1fc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8002be33493bd612317dc56891e973c"><td class="memItemLeft" align="right" valign="top"><a id="ad8002be33493bd612317dc56891e973c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (DivGradient).NumInputs(3).NumOutputs(2).AllowInplace(</td></tr>
<tr class="separator:ad8002be33493bd612317dc56891e973c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3338f28d9f20274ff81e6356759decd1"><td class="memItemLeft" align="right" valign="top"><a id="a3338f28d9f20274ff81e6356759decd1"></a>
and the dimensions of the second input is the contiguous subset of the dimensions of the first For the following tensor shapes are&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b> (B)</td></tr>
<tr class="separator:a3338f28d9f20274ff81e6356759decd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bf4918b3309dec0d3e0f99e4913e84"><td class="memItemLeft" align="right" valign="top"><a id="ab3bf4918b3309dec0d3e0f99e4913e84"></a>
and the dimensions of the second input is the contiguous subset of the dimensions of the first For the following tensor shapes are i e B is a scalar&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b> (A)</td></tr>
<tr class="separator:ab3bf4918b3309dec0d3e0f99e4913e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d4fcefc7b43ff7e90d369132d32ec5"><td class="memItemLeft" align="right" valign="top"><a id="a50d4fcefc7b43ff7e90d369132d32ec5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_FUNCTOR</b> (Sub, EIGEN_SUB, <a class="el" href="structcaffe2_1_1TensorTypes.html">NumericTypes</a>, <a class="el" href="structcaffe2_1_1SameTypeAsInput.html">SameTypeAsInput</a>)</td></tr>
<tr class="separator:a50d4fcefc7b43ff7e90d369132d32ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b718bd1d99ccaa1b0629a7f1fc6d00"><td class="memItemLeft" align="right" valign="top"><a id="ad9b718bd1d99ccaa1b0629a7f1fc6d00"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Sum, <a class="el" href="classcaffe2_1_1SumOp.html">SumOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad9b718bd1d99ccaa1b0629a7f1fc6d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f9844280ecb777645375224b00c55c"><td class="memItemLeft" align="right" valign="top"><a id="a72f9844280ecb777645375224b00c55c"></a>
in which case the sum will be done in place and results will be accumulated in input0 All inputs and outputs must have the same shape and data type DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;data_0&quot;, &quot;First of the input tensors. Can be inplace.&quot;) .Output(0</td></tr>
<tr class="separator:a72f9844280ecb777645375224b00c55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac035f1485229df6b767b358832c9eaf6"><td class="memItemLeft" align="right" valign="top"><a id="ac035f1485229df6b767b358832c9eaf6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Elu, <a class="el" href="classcaffe2_1_1EluOp.html">EluOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac035f1485229df6b767b358832c9eaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b561e1908f4d07c8a0941188ea8b247"><td class="memItemLeft" align="right" valign="top"><a id="a7b561e1908f4d07c8a0941188ea8b247"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (EluGradient, <a class="el" href="classcaffe2_1_1EluGradientOp.html">EluGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7b561e1908f4d07c8a0941188ea8b247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670261109ee4d18d3d59046319e02f57"><td class="memItemLeft" align="right" valign="top"><a id="a670261109ee4d18d3d59046319e02f57"></a>
is applied to the tensor elementwise DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;X&quot;, &quot;1D input tensor&quot;) .Output(0</td></tr>
<tr class="separator:a670261109ee4d18d3d59046319e02f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a020534a53773fbacf5c7fcb25f01c3"><td class="memItemLeft" align="right" valign="top"><a id="a3a020534a53773fbacf5c7fcb25f01c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
EluGradient takes both Y and dY and uses this to update dX according to the
chain rule and derivatives of the rectified linear function.
)DOC&quot;)</td></tr>
<tr class="separator:a3a020534a53773fbacf5c7fcb25f01c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106f7d276074072026f82fe975e1e121"><td class="memItemLeft" align="right" valign="top"><a id="a106f7d276074072026f82fe975e1e121"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Elu, <a class="el" href="classcaffe2_1_1GetEluGradient.html">GetEluGradient</a>)</td></tr>
<tr class="separator:a106f7d276074072026f82fe975e1e121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35898418acaa09e9592059b9069c46d"><td class="memItemLeft" align="right" valign="top"><a id="ab35898418acaa09e9592059b9069c46d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Exp, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1ExpCPUFunctor.html">ExpCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:ab35898418acaa09e9592059b9069c46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace21a98aaf448ca86e2f57c4467765e6"><td class="memItemLeft" align="right" valign="top"><a id="ace21a98aaf448ca86e2f57c4467765e6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Exp, <a class="el" href="classcaffe2_1_1GetExpGradient.html">GetExpGradient</a>)</td></tr>
<tr class="separator:ace21a98aaf448ca86e2f57c4467765e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a639f59d659fed5f5788ff8d2444070"><td class="memItemLeft" align="right" valign="top"><a id="a9a639f59d659fed5f5788ff8d2444070"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ExpandDims, <a class="el" href="classcaffe2_1_1ExpandDimsOp.html">ExpandDimsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9a639f59d659fed5f5788ff8d2444070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df341a5f4674d17842a1b3e77366edd"><td class="memItemLeft" align="right" valign="top"><a id="a1df341a5f4674d17842a1b3e77366edd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Squeeze, <a class="el" href="classcaffe2_1_1SqueezeOp.html">SqueezeOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1df341a5f4674d17842a1b3e77366edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb73392b8396800a45b7c571d99c9db"><td class="memItemLeft" align="right" valign="top"><a id="abdb73392b8396800a45b7c571d99c9db"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> ([](const OperatorDef &amp;def, const vector&lt; TensorShape &gt; &amp;in) { <a class="el" href="classcaffe2_1_1ArgumentHelper.html">ArgumentHelper</a> helper(def);auto dims=helper.template GetRepeatedArgument&lt; int &gt;(&quot;dims&quot;);auto originalSize=dims.size();CAFFE_ENFORCE(originalSize &gt; 0, &quot;Parameter `dims` must be provided.&quot;);std::sort(dims.begin(), dims.end());dims.erase(std::unique(dims.begin(), dims.end()), dims.end());if(dims.size()&lt; originalSize) { LOG(WARNING)&lt;&lt; &quot;Parameter `dims` has repeated dimensions.&quot;;} CAFFE_ENFORCE(dims.front() &gt;=0, &quot;Dimension ids must be non-negative.&quot;);CAFFE_ENFORCE_GE(in[0].dims_size()+dims.size(), dims.back()+1, &quot;Input needs at least &quot;,(1+dims.back() - dims.size()), &quot; dimensions given `dims`.&quot;);vector&lt; TensorShape &gt; out(1);int cur_pos=0;int idx=0;for(const auto new_dim :dims) { for(int i=cur_pos;i&lt; new_dim;i++) { out[0].add_dims(in[0].dims(idx++));} out[0].add_dims(1);cur_pos=new_dim+1;} for(;idx&lt; in[0].dims_size();idx++) { out[0].add_dims(in[0].dims(idx));} out[0].set_data_type(in[0].data_type());return out;}) .SetDoc(R&quot;DOC( Insert single-dimensional entries to the shape of a tensor. Takes one required argument `dims`</td></tr>
<tr class="separator:abdb73392b8396800a45b7c571d99c9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b27586c43651c1c73785db21657ddfc"><td class="memItemLeft" align="right" valign="top"><a id="a0b27586c43651c1c73785db21657ddfc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Squeeze, <a class="el" href="classcaffe2_1_1SqueezeOp.html">SqueezeOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a0b27586c43651c1c73785db21657ddfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba9712992902de52a0c864a424d4a93"><td class="memItemLeft" align="right" valign="top"><a id="a3ba9712992902de52a0c864a424d4a93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (ExpandDims, <a class="el" href="classcaffe2_1_1ExpandDimsOp.html">ExpandDimsOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a3ba9712992902de52a0c864a424d4a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b6dc5a6a52e2c93b44713b7133578d"><td class="memItemLeft" align="right" valign="top"><a id="aa9b6dc5a6a52e2c93b44713b7133578d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FeedBlob, <a class="el" href="classcaffe2_1_1FeedBlobOp.html">FeedBlobOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa9b6dc5a6a52e2c93b44713b7133578d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8351e03fb859b3632d11f62ad1d8950c"><td class="memItemLeft" align="right" valign="top"><a id="a8351e03fb859b3632d11f62ad1d8950c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (FeedBlob)</td></tr>
<tr class="separator:a8351e03fb859b3632d11f62ad1d8950c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3864ac1108d5093d5ec454a8281eede7"><td class="memItemLeft" align="right" valign="top"><a id="a3864ac1108d5093d5ec454a8281eede7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (0, 0) .NumOutputs(1</td></tr>
<tr class="separator:a3864ac1108d5093d5ec454a8281eede7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a19575f7539fb6c7524daa6b16ca425"><td class="memItemLeft" align="right" valign="top"><a id="a4a19575f7539fb6c7524daa6b16ca425"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
FeedBlobs the content of the blobs. The input and output blobs should be
one-to-one inplace.)DOC&quot;) .Arg(&quot;value&quot;</td></tr>
<tr class="separator:a4a19575f7539fb6c7524daa6b16ca425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f639e28601da3c07ac8e237b3572c3"><td class="memItemLeft" align="right" valign="top"><a id="a27f639e28601da3c07ac8e237b3572c3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (UniformFill, <a class="el" href="classcaffe2_1_1UniformFillOp.html">UniformFillOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a27f639e28601da3c07ac8e237b3572c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1974816c7e4b3740e96cc2f940a90af"><td class="memItemLeft" align="right" valign="top"><a id="aa1974816c7e4b3740e96cc2f940a90af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (UniformIntFill, <a class="el" href="classcaffe2_1_1UniformFillOp.html">UniformFillOp</a>&lt; int, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa1974816c7e4b3740e96cc2f940a90af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac81b63ebab12452f6f8e8d57980dd1f"><td class="memItemLeft" align="right" valign="top"><a id="aac81b63ebab12452f6f8e8d57980dd1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (UniqueUniformFill, <a class="el" href="classcaffe2_1_1UniqueUniformFillOp.html">UniqueUniformFillOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aac81b63ebab12452f6f8e8d57980dd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1e9f65068d0fcb55d3699c00559e46"><td class="memItemLeft" align="right" valign="top"><a id="a9a1e9f65068d0fcb55d3699c00559e46"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ConstantFill, <a class="el" href="classcaffe2_1_1ConstantFillOp.html">ConstantFillOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9a1e9f65068d0fcb55d3699c00559e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210f156a8503d60d2a32394a8656458b"><td class="memItemLeft" align="right" valign="top"><a id="a210f156a8503d60d2a32394a8656458b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DiagonalFill, <a class="el" href="classcaffe2_1_1DiagonalFillOp.html">DiagonalFillOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a210f156a8503d60d2a32394a8656458b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5041564a2c1bb5307576f93e6b2ee2e"><td class="memItemLeft" align="right" valign="top"><a id="af5041564a2c1bb5307576f93e6b2ee2e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GaussianFill, <a class="el" href="classcaffe2_1_1GaussianFillOp.html">GaussianFillOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af5041564a2c1bb5307576f93e6b2ee2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52c5c69d3eff8b8997ddd2d0321db30"><td class="memItemLeft" align="right" valign="top"><a id="af52c5c69d3eff8b8997ddd2d0321db30"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (XavierFill, <a class="el" href="classcaffe2_1_1XavierFillOp.html">XavierFillOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af52c5c69d3eff8b8997ddd2d0321db30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8a118c7c04bd6a44970b938c397c18"><td class="memItemLeft" align="right" valign="top"><a id="afa8a118c7c04bd6a44970b938c397c18"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MSRAFill, <a class="el" href="classcaffe2_1_1MSRAFillOp.html">MSRAFillOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:afa8a118c7c04bd6a44970b938c397c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212da7c76bc28aaf943d4814799b0c83"><td class="memItemLeft" align="right" valign="top"><a id="a212da7c76bc28aaf943d4814799b0c83"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RangeFill, <a class="el" href="classcaffe2_1_1RangeFillOp.html">RangeFillOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a212da7c76bc28aaf943d4814799b0c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a85b6d6e73a4c5ed6acdf7c5d81357f"><td class="memItemLeft" align="right" valign="top"><a id="a7a85b6d6e73a4c5ed6acdf7c5d81357f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsRangeFill, <a class="el" href="classcaffe2_1_1LengthsRangeFillOp.html">LengthsRangeFillOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7a85b6d6e73a4c5ed6acdf7c5d81357f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e3796c39c57f87c0602797f9b6adb0"><td class="memItemLeft" align="right" valign="top"><a id="a47e3796c39c57f87c0602797f9b6adb0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> (FillerTensorInference&lt;&gt;) .SetDoc(R&quot;DOC( The operator fills the elements of the output tensor with a const ant value specified by the 'value' argument. The data type is specified by the 'dtype' argument. The 'dtype' argument must be one of the data types specified in the 'DataType' enum field in the TensorProto message. If the 'dtype' argument is not provided</td></tr>
<tr class="separator:a47e3796c39c57f87c0602797f9b6adb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affef2c8d5e428a73b191483d03642ab2"><td class="memTemplParams" colspan="2"><a id="affef2c8d5e428a73b191483d03642ab2"></a>
template&lt;int VALUE_TYPE = TensorProto_DataType_FLOAT&gt; </td></tr>
<tr class="memitem:affef2c8d5e428a73b191483d03642ab2"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; TensorShape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FillerTensorInference</b> (const OperatorDef &amp;def, const vector&lt; TensorShape &gt; &amp;in)</td></tr>
<tr class="separator:affef2c8d5e428a73b191483d03642ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b470ebd6dde07075fd1869ac2d0e6f"><td class="memItemLeft" align="right" valign="top"><a id="a97b470ebd6dde07075fd1869ac2d0e6f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (LengthsRangeFill, <a class="el" href="classcaffe2_1_1GPUFallbackOp.html">GPUFallbackOp</a>&lt; <a class="el" href="classcaffe2_1_1LengthsRangeFillOp.html">LengthsRangeFillOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;&gt;)</td></tr>
<tr class="separator:a97b470ebd6dde07075fd1869ac2d0e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07a696b96099f051dc3ea125aa64e04"><td class="memItemLeft" align="right" valign="top"><a id="ab07a696b96099f051dc3ea125aa64e04"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Index</b> (integers)&quot;) .Input(1</td></tr>
<tr class="separator:ab07a696b96099f051dc3ea125aa64e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19030a619632f556a5714b382d5e55c"><td class="memItemLeft" align="right" valign="top"><a id="af19030a619632f556a5714b382d5e55c"></a>
Needles query&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;query_indices&quot;, &quot;Indices of the needles in index or 'missing value'&quot;) .Arg(&quot;missing_value&quot;</td></tr>
<tr class="separator:af19030a619632f556a5714b382d5e55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406b9a2f49cc48231ea30d1cf647a9c5"><td class="memItemLeft" align="right" valign="top"><a id="a406b9a2f49cc48231ea30d1cf647a9c5"></a>
Needles query Placeholder for items that are not found&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(Finds elements of second input from first input,
                outputting the last (max) index for each query.
                If query not find, inserts missing_value.
                See IndexGet() for a version that modifies the index when
                values are not found.
            )DOC&quot;)</td></tr>
<tr class="separator:a406b9a2f49cc48231ea30d1cf647a9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1755f5007b5525661e297ac95b85289d"><td class="memItemLeft" align="right" valign="top"><a id="a1755f5007b5525661e297ac95b85289d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Flatten, <a class="el" href="classcaffe2_1_1FlattenOp.html">FlattenOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1755f5007b5525661e297ac95b85289d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04c03a72626c14843c248829f802c50"><td class="memItemLeft" align="right" valign="top"><a id="ab04c03a72626c14843c248829f802c50"></a>
vector&lt; TensorShape &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>out</b> (1)</td></tr>
<tr class="separator:ab04c03a72626c14843c248829f802c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f3e4323513250025fc946892a4b1fc6"><td class="memItemLeft" align="right" valign="top"><a id="a1f3e4323513250025fc946892a4b1fc6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>for</b> (auto d :in[0].dims())</td></tr>
<tr class="separator:a1f3e4323513250025fc946892a4b1fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2aa42a78dbd98b1b5fa034551023585"><td class="memItemLeft" align="right" valign="top"><a id="aa2aa42a78dbd98b1b5fa034551023585"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>set_data_type</b> (in[0].data_type())</td></tr>
<tr class="separator:aa2aa42a78dbd98b1b5fa034551023585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc9398efbdd3a1d463a3fa45cb40822"><td class="memItemLeft" align="right" valign="top"><a id="a5cc9398efbdd3a1d463a3fa45cb40822"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (outer)</td></tr>
<tr class="separator:a5cc9398efbdd3a1d463a3fa45cb40822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d44cd34c5d3a5f045f3c0090649642e"><td class="memItemLeft" align="right" valign="top"><a id="a8d44cd34c5d3a5f045f3c0090649642e"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (inner)</td></tr>
<tr class="separator:a8d44cd34c5d3a5f045f3c0090649642e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fbd17cf6ca491544d9819d2455e20a"><td class="memItemLeft" align="right" valign="top"><a id="a98fbd17cf6ca491544d9819d2455e20a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Flattens the input tensor into a 2D matrix. If input tensor has shape
(d_0, d_1, ... d_n) then the output will have shape
(d_0 X d_1 ... d_(axis-1), d_axis X d_(axis+1) ... X dn)
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:a98fbd17cf6ca491544d9819d2455e20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571a98f7b01b02f05a5ab13601be9a07"><td class="memItemLeft" align="right" valign="top"><a id="a571a98f7b01b02f05a5ab13601be9a07"></a>
A tensor of with input dimensions up to axis flattened to the outer dimension of the output and remaining input dimensions flattened into the inner dimension of the output&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;axis&quot;, &quot;(Default to 1) Indicate up to which input dimensions &quot; &quot;(exclusive) should be flattened to the outer dimension of the output&quot;)</td></tr>
<tr class="separator:a571a98f7b01b02f05a5ab13601be9a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384df3668505f76c85f552b02187ca33"><td class="memItemLeft" align="right" valign="top"><a id="a384df3668505f76c85f552b02187ca33"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Flatten, <a class="el" href="classcaffe2_1_1GetFlattenGradient.html">GetFlattenGradient</a>)</td></tr>
<tr class="separator:a384df3668505f76c85f552b02187ca33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fcd71de627b3a4c418c6ee15896cb72"><td class="memItemLeft" align="right" valign="top"><a id="a2fcd71de627b3a4c418c6ee15896cb72"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FlexibleTopK, <a class="el" href="classcaffe2_1_1FlexibleTopKOp.html">FlexibleTopKOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a2fcd71de627b3a4c418c6ee15896cb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381f774a585fae067302931bb7c00542"><td class="memItemLeft" align="right" valign="top"><a id="a381f774a585fae067302931bb7c00542"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FlexibleTopKGradient, <a class="el" href="classcaffe2_1_1FlexibleTopKGradientOp.html">FlexibleTopKGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a381f774a585fae067302931bb7c00542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace44a6fcfc0ff135335e8fbe29ce87b2"><td class="memItemLeft" align="right" valign="top"><a id="ace44a6fcfc0ff135335e8fbe29ce87b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Free, <a class="el" href="classcaffe2_1_1FreeOp.html">FreeOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ace44a6fcfc0ff135335e8fbe29ce87b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069d91af285b8d6101007750937f5512"><td class="memItemLeft" align="right" valign="top"><a id="a069d91af285b8d6101007750937f5512"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Free)</td></tr>
<tr class="separator:a069d91af285b8d6101007750937f5512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedff45070bc249ad378d727e60ea9f7"><td class="memItemLeft" align="right" valign="top"><a id="adedff45070bc249ad378d727e60ea9f7"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SameNumberOfOutput</b> () .EnforceOneToOneInplace() .SetDoc(R&quot;DOC( Frees the content of the blobs. The input and output blobs should be one-to-one inplace.)DOC&quot;)</td></tr>
<tr class="separator:adedff45070bc249ad378d727e60ea9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f9797224aef8884a1cb233c0ffbe82"><td class="memItemLeft" align="right" valign="top"><a id="ad4f9797224aef8884a1cb233c0ffbe82"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Free, <a class="el" href="classcaffe2_1_1FreeOp.html">FreeOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ad4f9797224aef8884a1cb233c0ffbe82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc120235d53fe0a733a44a98b42ab17"><td class="memItemLeft" align="right" valign="top"><a id="a3dc120235d53fe0a733a44a98b42ab17"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FC, <a class="el" href="classcaffe2_1_1FullyConnectedOp.html">FullyConnectedOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3dc120235d53fe0a733a44a98b42ab17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548c644916d6d2a1aae045a4d8720d7c"><td class="memItemLeft" align="right" valign="top"><a id="a548c644916d6d2a1aae045a4d8720d7c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FCGradient, <a class="el" href="classcaffe2_1_1FullyConnectedGradientOp.html">FullyConnectedGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a548c644916d6d2a1aae045a4d8720d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71d158abf61ab81c2b0c5543a1be3f9"><td class="memItemLeft" align="right" valign="top"><a id="af71d158abf61ab81c2b0c5543a1be3f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FCTransposed, <a class="el" href="classcaffe2_1_1FullyConnectedOp.html">FullyConnectedOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1DefaultEngine.html">DefaultEngine</a>, false &gt;)</td></tr>
<tr class="separator:af71d158abf61ab81c2b0c5543a1be3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcc29c8cb9abc1567af87e71bd9bf24"><td class="memItemLeft" align="right" valign="top"><a id="a7dcc29c8cb9abc1567af87e71bd9bf24"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FCTransposedGradient, <a class="el" href="classcaffe2_1_1FullyConnectedGradientOp.html">FullyConnectedGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1DefaultEngine.html">DefaultEngine</a>, false &gt;)</td></tr>
<tr class="separator:a7dcc29c8cb9abc1567af87e71bd9bf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fd2849ba80cbe030fec3b47959b6d4"><td class="memItemLeft" align="right" valign="top"><a id="a92fd2849ba80cbe030fec3b47959b6d4"></a>
NumInputs(3) .NumOutputs(1) .TensorInferenceFunction(std NumInputs(3) .NumOutputs(1) .TensorInferenceFunction(std&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (FCGradient).NumInputs(3).NumOutputs(2</td></tr>
<tr class="separator:a92fd2849ba80cbe030fec3b47959b6d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d868b7bb06d1711ba171ab35f04de88"><td class="memItemLeft" align="right" valign="top"><a id="a8d868b7bb06d1711ba171ab35f04de88"></a>
NumInputs(3) .NumOutputs(1) .TensorInferenceFunction(std NumInputs(3) .NumOutputs(1) .TensorInferenceFunction(std&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (FCTransposedGradient).NumInputs(3).NumOutputs(2</td></tr>
<tr class="separator:a8d868b7bb06d1711ba171ab35f04de88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44555fbef3acb1dfc26cfdc9037b74be"><td class="memItemLeft" align="right" valign="top"><a id="a44555fbef3acb1dfc26cfdc9037b74be"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (FC, <a class="el" href="classcaffe2_1_1FullyConnectedOp.html">FullyConnectedOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a44555fbef3acb1dfc26cfdc9037b74be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cc15980ac98f61c26ba6772cb26f1a"><td class="memItemLeft" align="right" valign="top"><a id="a21cc15980ac98f61c26ba6772cb26f1a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (FCGradient, <a class="el" href="classcaffe2_1_1FullyConnectedGradientOp.html">FullyConnectedGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a21cc15980ac98f61c26ba6772cb26f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f785a1ae552fd2ae17d62a2820a585d"><td class="memItemLeft" align="right" valign="top"><a id="a7f785a1ae552fd2ae17d62a2820a585d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GivenTensorFill, <a class="el" href="classcaffe2_1_1GivenTensorFillOp.html">GivenTensorFillOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7f785a1ae552fd2ae17d62a2820a585d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a228f3cb8714bb1747b0d7ea286f19c"><td class="memItemLeft" align="right" valign="top"><a id="a6a228f3cb8714bb1747b0d7ea286f19c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GivenTensorDoubleFill, <a class="el" href="classcaffe2_1_1GivenTensorFillOp.html">GivenTensorFillOp</a>&lt; double, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a6a228f3cb8714bb1747b0d7ea286f19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6793798d6aa4a28518481f72b5dffe0e"><td class="memItemLeft" align="right" valign="top"><a id="a6793798d6aa4a28518481f72b5dffe0e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GivenTensorBoolFill, <a class="el" href="classcaffe2_1_1GivenTensorFillOp.html">GivenTensorFillOp</a>&lt; bool, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a6793798d6aa4a28518481f72b5dffe0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3ee829a67c1ff79abe416528c41f30"><td class="memItemLeft" align="right" valign="top"><a id="afe3ee829a67c1ff79abe416528c41f30"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GivenTensorIntFill, <a class="el" href="classcaffe2_1_1GivenTensorFillOp.html">GivenTensorFillOp</a>&lt; int, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:afe3ee829a67c1ff79abe416528c41f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1be5a6969ca8de5d902a53309df0c27"><td class="memItemLeft" align="right" valign="top"><a id="ab1be5a6969ca8de5d902a53309df0c27"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GivenTensorInt64Fill, <a class="el" href="classcaffe2_1_1GivenTensorFillOp.html">GivenTensorFillOp</a>&lt; int64_t, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab1be5a6969ca8de5d902a53309df0c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c1bf149a69798586ca44a0f7a11d39"><td class="memItemLeft" align="right" valign="top"><a id="a25c1bf149a69798586ca44a0f7a11d39"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GivenTensorStringFill, <a class="el" href="classcaffe2_1_1GivenTensorFillOp.html">GivenTensorFillOp</a>&lt; std::string, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a25c1bf149a69798586ca44a0f7a11d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b7a04b92c4d0c7e688cbd5d9b92453"><td class="memItemLeft" align="right" valign="top"><a id="a27b7a04b92c4d0c7e688cbd5d9b92453"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (GivenTensorFill)</td></tr>
<tr class="separator:a27b7a04b92c4d0c7e688cbd5d9b92453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776f57c3c36d1ca80e440a9731910326"><td class="memItemLeft" align="right" valign="top"><a id="a776f57c3c36d1ca80e440a9731910326"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (GivenTensorDoubleFill)</td></tr>
<tr class="separator:a776f57c3c36d1ca80e440a9731910326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16de4c54a6bcb97507e49a946bedd6f8"><td class="memItemLeft" align="right" valign="top"><a id="a16de4c54a6bcb97507e49a946bedd6f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (GivenTensorBoolFill)</td></tr>
<tr class="separator:a16de4c54a6bcb97507e49a946bedd6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4f5291476fc8ac4db53c1b88e506b2"><td class="memItemLeft" align="right" valign="top"><a id="a7d4f5291476fc8ac4db53c1b88e506b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (GivenTensorIntFill)</td></tr>
<tr class="separator:a7d4f5291476fc8ac4db53c1b88e506b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4182e9d6ba8afaf3e24478479e6350de"><td class="memItemLeft" align="right" valign="top"><a id="a4182e9d6ba8afaf3e24478479e6350de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (GivenTensorInt64Fill)</td></tr>
<tr class="separator:a4182e9d6ba8afaf3e24478479e6350de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09357b5c1748c66e24ce0b4495e02c9e"><td class="memItemLeft" align="right" valign="top"><a id="a09357b5c1748c66e24ce0b4495e02c9e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (GivenTensorStringFill)</td></tr>
<tr class="separator:a09357b5c1748c66e24ce0b4495e02c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9668223da47f615a327c5e3b55aecb9"><td class="memItemLeft" align="right" valign="top"><a id="aa9668223da47f615a327c5e3b55aecb9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> (FillerTensorInference&lt; TensorProto_DataType_DOUBLE &gt;)</td></tr>
<tr class="separator:aa9668223da47f615a327c5e3b55aecb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1127010c8b79ef887f0e8fa003eb783f"><td class="memItemLeft" align="right" valign="top"><a id="a1127010c8b79ef887f0e8fa003eb783f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> (FillerTensorInference&lt; TensorProto_DataType_BOOL &gt;)</td></tr>
<tr class="separator:a1127010c8b79ef887f0e8fa003eb783f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d10328de65da48df227378e54aef56e"><td class="memItemLeft" align="right" valign="top"><a id="a7d10328de65da48df227378e54aef56e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> (FillerTensorInference&lt; TensorProto_DataType_INT32 &gt;)</td></tr>
<tr class="separator:a7d10328de65da48df227378e54aef56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642e0d4281da343cab8fa2117c56b7b7"><td class="memItemLeft" align="right" valign="top"><a id="a642e0d4281da343cab8fa2117c56b7b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> (FillerTensorInference&lt; TensorProto_DataType_INT64 &gt;)</td></tr>
<tr class="separator:a642e0d4281da343cab8fa2117c56b7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e6de0a31359f52a5468e209d1af3bb"><td class="memItemLeft" align="right" valign="top"><a id="a90e6de0a31359f52a5468e209d1af3bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> (FillerTensorInference&lt; TensorProto_DataType_STRING &gt;)</td></tr>
<tr class="separator:a90e6de0a31359f52a5468e209d1af3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1441fb45c62829835f5df2c664f9b5"><td class="memItemLeft" align="right" valign="top"><a id="a7b1441fb45c62829835f5df2c664f9b5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GRUUnit, <a class="el" href="classcaffe2_1_1GRUUnitOp.html">GRUUnitOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7b1441fb45c62829835f5df2c664f9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275ad44c1cbd4a64ee957dfd6ff9fa52"><td class="memItemLeft" align="right" valign="top"><a id="a275ad44c1cbd4a64ee957dfd6ff9fa52"></a>
in a sequence length aware fashion given&#160;</td><td class="memItemRight" valign="bottom"><b>the</b> (fused) inputs X(TxNxD)</td></tr>
<tr class="separator:a275ad44c1cbd4a64ee957dfd6ff9fa52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a959bdd2f18bcf6ed779e4edb688429c7"><td class="memItemLeft" align="right" valign="top"><a id="a959bdd2f18bcf6ed779e4edb688429c7"></a>
in a sequence length aware fashion given the previous hidden&#160;</td><td class="memItemRight" valign="bottom"><b>state</b> (NxD)</td></tr>
<tr class="separator:a959bdd2f18bcf6ed779e4edb688429c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5785a0265bb5a49fe563576a5856bffb"><td class="memItemLeft" align="right" valign="top"><a id="a5785a0265bb5a49fe563576a5856bffb"></a>
in a sequence length aware fashion given the previous hidden and the sequence&#160;</td><td class="memItemRight" valign="bottom"><b>lengths</b> (N)</td></tr>
<tr class="separator:a5785a0265bb5a49fe563576a5856bffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bded13860e75746552c5f62698996f3"><td class="memItemLeft" align="right" valign="top"><a id="a0bded13860e75746552c5f62698996f3"></a>
in a sequence length aware fashion given the previous hidden and the sequence computes the GRU avoiding computation if the input is&#160;</td><td class="memItemRight" valign="bottom"><b>invalid</b> (as in, the value at X[t][n] &gt;=seqLengths[n].) DOC&quot;) .Arg( &quot;drop_states&quot;</td></tr>
<tr class="separator:a0bded13860e75746552c5f62698996f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1540f96c0f1191b33e06ed9c58e07757"><td class="memItemLeft" align="right" valign="top"><a id="a1540f96c0f1191b33e06ed9c58e07757"></a>
in a sequence length aware fashion given the previous hidden and the sequence computes the GRU avoiding computation if the input is Bool to determine if hidden state is zeroes or passed along for timesteps past the given sequence_length&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;hidden_prev&quot;, &quot;The previous GRU hidden state.&quot;) .Input(1</td></tr>
<tr class="separator:a1540f96c0f1191b33e06ed9c58e07757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb15e2f2ee83e4fb7cae7933d5b36d92"><td class="memItemLeft" align="right" valign="top"><a id="aeb15e2f2ee83e4fb7cae7933d5b36d92"></a>
in a sequence length aware fashion given the previous hidden and the sequence computes the GRU avoiding computation if the input is Bool to determine if hidden state is zeroes or passed along for timesteps past the given sequence_length Unactivated gate outputs from and output pre activation&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (2, &quot;seq_lengths&quot;, &quot;Array of sequence lengths.  &quot; &quot;len(seq_lengths) should equal batch size N.&quot;) .Input(3</td></tr>
<tr class="separator:aeb15e2f2ee83e4fb7cae7933d5b36d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb078c72c4b00827f243a02de2aeba1"><td class="memItemLeft" align="right" valign="top"><a id="aabb078c72c4b00827f243a02de2aeba1"></a>
in a sequence length aware fashion given the previous hidden and the sequence computes the GRU avoiding computation if the input is Bool to determine if hidden state is zeroes or passed along for timesteps past the given sequence_length Unactivated gate outputs from and output pre activation The timestep for this operation&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;hidden&quot;, &quot;The new GRU hidden state calculated by this op.&quot;)</td></tr>
<tr class="separator:aabb078c72c4b00827f243a02de2aeba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65219a73c9faa974635939b186318b75"><td class="memItemLeft" align="right" valign="top"><a id="a65219a73c9faa974635939b186318b75"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GRUUnitGradient, <a class="el" href="classcaffe2_1_1GRUUnitGradientOp.html">GRUUnitGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a65219a73c9faa974635939b186318b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940641a0ecfad46d8e0af6b43114377a"><td class="memItemLeft" align="right" valign="top"><a id="a940641a0ecfad46d8e0af6b43114377a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (GRUUnitGradient).NumInputs(6).NumOutputs(2)</td></tr>
<tr class="separator:a940641a0ecfad46d8e0af6b43114377a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ded52bdd945fab308b19d3d7eb1c42"><td class="memItemLeft" align="right" valign="top"><a id="a67ded52bdd945fab308b19d3d7eb1c42"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (GRUUnit, <a class="el" href="classcaffe2_1_1GetGRUUnitGradient.html">GetGRUUnitGradient</a>)</td></tr>
<tr class="separator:a67ded52bdd945fab308b19d3d7eb1c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e1b3d007135b6e2591f5e23e11e1a5"><td class="memItemLeft" align="right" valign="top"><a id="a20e1b3d007135b6e2591f5e23e11e1a5"></a>
out&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (X)</td></tr>
<tr class="separator:a20e1b3d007135b6e2591f5e23e11e1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba527b99c7e1b69a8258cf418920c0d4"><td class="memItemLeft" align="right" valign="top"><a id="aba527b99c7e1b69a8258cf418920c0d4"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>set_data_type</b> (TensorProto_DataType_FLOAT16)</td></tr>
<tr class="separator:aba527b99c7e1b69a8258cf418920c0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1bd2ffab8464109c668b45df6591f8"><td class="memItemLeft" align="right" valign="top"><a id="aae1bd2ffab8464109c668b45df6591f8"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>set_data_type</b> (TensorProto_DataType_FLOAT)</td></tr>
<tr class="separator:aae1bd2ffab8464109c668b45df6591f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83848e533973ab66e61cea8e7359059"><td class="memItemLeft" align="right" valign="top"><a id="ad83848e533973ab66e61cea8e7359059"></a>
The value for the elements of the output tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;shape&quot;, &quot;The shape of the output tensor.&quot;) .Output(0</td></tr>
<tr class="separator:ad83848e533973ab66e61cea8e7359059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a36696199136eaf34faac441f46efca"><td class="memItemLeft" align="right" valign="top"><a id="a3a36696199136eaf34faac441f46efca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (FloatToHalf, <a class="el" href="classcaffe2_1_1GetFloatToHalfGradient.html">GetFloatToHalfGradient</a>)</td></tr>
<tr class="separator:a3a36696199136eaf34faac441f46efca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81004f1ab8baad6daa1fe974ee060f6"><td class="memItemLeft" align="right" valign="top"><a id="aa81004f1ab8baad6daa1fe974ee060f6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (HalfToFloat, <a class="el" href="classcaffe2_1_1GetHalfToFloatGradient.html">GetHalfToFloatGradient</a>)</td></tr>
<tr class="separator:aa81004f1ab8baad6daa1fe974ee060f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e3494b799b136a2787912c5c8c200d"><td class="memItemLeft" align="right" valign="top"><a id="a45e3494b799b136a2787912c5c8c200d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (Float16ConstantFill)</td></tr>
<tr class="separator:a45e3494b799b136a2787912c5c8c200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e52c366909d9e9723388425b3bf7b72"><td class="memItemLeft" align="right" valign="top"><a id="a8e52c366909d9e9723388425b3bf7b72"></a>
std::vector&lt; TensorShape &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Float16FillerTensorInference</b> (const OperatorDef &amp;def, const vector&lt; TensorShape &gt; &amp;in)</td></tr>
<tr class="separator:a8e52c366909d9e9723388425b3bf7b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c28ce5d8a0bae091163f9342c38542"><td class="memItemLeft" align="right" valign="top"><a id="a28c28ce5d8a0bae091163f9342c38542"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (If, <a class="el" href="classcaffe2_1_1IfOp.html">IfOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a28c28ce5d8a0bae091163f9342c38542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f536c996dce261a6e3bf4a68af1989"><td class="memItemLeft" align="right" valign="top"><a id="a99f536c996dce261a6e3bf4a68af1989"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
'If' control operator, first input is a scalar boolean blob that stores condition
value. Accepts 'then_net' (required) and 'else_net' (optional) arguments for 'then' and
'else' subnets respectively. Subnets are executed in the same workspace as 'If'.
    )DOC&quot;) .Arg(&quot;then_net&quot;</td></tr>
<tr class="separator:a99f536c996dce261a6e3bf4a68af1989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c4c0538ac88c7c55117dfdc4f20d50"><td class="memItemLeft" align="right" valign="top"><a id="ad2c4c0538ac88c7c55117dfdc4f20d50"></a>
INT_MAX Net executed when condition is true&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;else_net&quot;, &quot;Net executed when condition is false (optional)&quot;) .Input(0</td></tr>
<tr class="separator:ad2c4c0538ac88c7c55117dfdc4f20d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6352042b54633d14be9dc36a06738ecb"><td class="memItemLeft" align="right" valign="top"><a id="a6352042b54633d14be9dc36a06738ecb"></a>
INT_MAX Net executed when condition is true Scalar boolean condition&#160;</td><td class="memItemRight" valign="bottom"><b>AllowInplace</b> ([](int in, int out) -&gt; bool { return true;})</td></tr>
<tr class="separator:a6352042b54633d14be9dc36a06738ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b5ff154ad3fd3019cb05de7283925d"><td class="memItemLeft" align="right" valign="top"><a id="a84b5ff154ad3fd3019cb05de7283925d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (If, <a class="el" href="classcaffe2_1_1IfOp.html">IfOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a84b5ff154ad3fd3019cb05de7283925d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113cc01301d21f478188b3f0e3c6f4ac"><td class="memItemLeft" align="right" valign="top"><a id="a113cc01301d21f478188b3f0e3c6f4ac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Im2Col, <a class="el" href="classcaffe2_1_1Im2ColOp.html">Im2ColOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a113cc01301d21f478188b3f0e3c6f4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca353312069267046d35ab8c4f4e97d"><td class="memItemLeft" align="right" valign="top"><a id="a7ca353312069267046d35ab8c4f4e97d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Col2Im, <a class="el" href="classcaffe2_1_1Col2ImOp.html">Col2ImOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7ca353312069267046d35ab8c4f4e97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135134482622f6a9688744822b69c691"><td class="memItemLeft" align="right" valign="top"><a id="a135134482622f6a9688744822b69c691"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Im2Col, <a class="el" href="classcaffe2_1_1GetIm2ColGradient.html">GetIm2ColGradient</a>)</td></tr>
<tr class="separator:a135134482622f6a9688744822b69c691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b102883b9a724576888fd933fdafca"><td class="memItemLeft" align="right" valign="top"><a id="a50b102883b9a724576888fd933fdafca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Col2Im, <a class="el" href="classcaffe2_1_1GetCol2ImGradient.html">GetCol2ImGradient</a>)</td></tr>
<tr class="separator:a50b102883b9a724576888fd933fdafca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f2e4aa5de48764929b5f3893550af7"><td class="memItemLeft" align="right" valign="top"><a id="ad2f2e4aa5de48764929b5f3893550af7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>switch</b> (order)</td></tr>
<tr class="separator:ad2f2e4aa5de48764929b5f3893550af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa282b23c9194e9f55b8c0a2d1791049e"><td class="memItemLeft" align="right" valign="top"><a id="aa282b23c9194e9f55b8c0a2d1791049e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_ENFORCE</b> (H &gt;=dkernel_h)</td></tr>
<tr class="separator:aa282b23c9194e9f55b8c0a2d1791049e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94afdbc207e805298189c5d2c8136241"><td class="memItemLeft" align="right" valign="top"><a id="a94afdbc207e805298189c5d2c8136241"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_ENFORCE</b> (W &gt;=dkernel_w)</td></tr>
<tr class="separator:a94afdbc207e805298189c5d2c8136241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e552cdbf46f0c3fffe3daa0d6c0116"><td class="memItemLeft" align="right" valign="top"><a id="af0e552cdbf46f0c3fffe3daa0d6c0116"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;X&quot;, &quot;4-tensor in NCHW or NHWC.&quot;) .Output(0</td></tr>
<tr class="separator:af0e552cdbf46f0c3fffe3daa0d6c0116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c75a39c612a14c09ac8802acf988be"><td class="memItemLeft" align="right" valign="top"><a id="a30c75a39c612a14c09ac8802acf988be"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (Col2Im).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a30c75a39c612a14c09ac8802acf988be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192b899b8c03924960fa28167a035b53"><td class="memItemLeft" align="right" valign="top"><a id="a192b899b8c03924960fa28167a035b53"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Im2Col, <a class="el" href="classcaffe2_1_1Im2ColOp.html">Im2ColOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a192b899b8c03924960fa28167a035b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0e66a1d9d8b0b02508c9e1919676d7"><td class="memItemLeft" align="right" valign="top"><a id="a9f0e66a1d9d8b0b02508c9e1919676d7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Col2Im, <a class="el" href="classcaffe2_1_1Col2ImOp.html">Col2ImOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a9f0e66a1d9d8b0b02508c9e1919676d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbadabea450b6aaf36301ddc2c56458"><td class="memItemLeft" align="right" valign="top"><a id="a1bbadabea450b6aaf36301ddc2c56458"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (IntIndexCreate, <a class="el" href="classcaffe2_1_1IndexCreateOp.html">IndexCreateOp</a>&lt; int32_t &gt;)</td></tr>
<tr class="separator:a1bbadabea450b6aaf36301ddc2c56458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77f5f565be1a53b7165de223af1d7d77"><td class="memItemLeft" align="right" valign="top"><a id="a77f5f565be1a53b7165de223af1d7d77"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LongIndexCreate, <a class="el" href="classcaffe2_1_1IndexCreateOp.html">IndexCreateOp</a>&lt; int64_t &gt;)</td></tr>
<tr class="separator:a77f5f565be1a53b7165de223af1d7d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3334f788f88b77115926011ee2a9d65"><td class="memItemLeft" align="right" valign="top"><a id="af3334f788f88b77115926011ee2a9d65"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (StringIndexCreate, <a class="el" href="classcaffe2_1_1IndexCreateOp.html">IndexCreateOp</a>&lt; std::string &gt;)</td></tr>
<tr class="separator:af3334f788f88b77115926011ee2a9d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b1c1b091ac2f07f1a447e86200813f"><td class="memItemLeft" align="right" valign="top"><a id="aa3b1c1b091ac2f07f1a447e86200813f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (IndexGet, <a class="el" href="classcaffe2_1_1IndexGetOp.html">IndexGetOp</a>)</td></tr>
<tr class="separator:aa3b1c1b091ac2f07f1a447e86200813f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b20d47b4f18396c328b6630866612e"><td class="memItemLeft" align="right" valign="top"><a id="ad8b20d47b4f18396c328b6630866612e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (IndexLoad, <a class="el" href="classcaffe2_1_1IndexLoadOp.html">IndexLoadOp</a>)</td></tr>
<tr class="separator:ad8b20d47b4f18396c328b6630866612e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a826a240fc30821040510877689d2f9e5"><td class="memItemLeft" align="right" valign="top"><a id="a826a240fc30821040510877689d2f9e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (IndexStore, <a class="el" href="classcaffe2_1_1IndexStoreOp.html">IndexStoreOp</a>)</td></tr>
<tr class="separator:a826a240fc30821040510877689d2f9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524999b8c59758427ba16492de3e9c8d"><td class="memItemLeft" align="right" valign="top"><a id="a524999b8c59758427ba16492de3e9c8d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (IndexFreeze, <a class="el" href="classcaffe2_1_1IndexFreezeOp.html">IndexFreezeOp</a>)</td></tr>
<tr class="separator:a524999b8c59758427ba16492de3e9c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed210c9226ce7a92cd93a8d8c71bc011"><td class="memItemLeft" align="right" valign="top"><a id="aed210c9226ce7a92cd93a8d8c71bc011"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (IndexSize, <a class="el" href="classcaffe2_1_1IndexSizeOp.html">IndexSizeOp</a>)</td></tr>
<tr class="separator:aed210c9226ce7a92cd93a8d8c71bc011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd16a095479a29d0fbccd604274d138a"><td class="memItemLeft" align="right" valign="top"><a id="afd16a095479a29d0fbccd604274d138a"></a>
Max number of including the zero entry&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;handler&quot;, &quot;Pointer to an <a class="el" href="structcaffe2_1_1Index.html">Index</a> instance.&quot;)</td></tr>
<tr class="separator:afd16a095479a29d0fbccd604274d138a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27f518beb1be67269550ab8f7c1a4cb"><td class="memItemLeft" align="right" valign="top"><a id="aa27f518beb1be67269550ab8f7c1a4cb"></a>
Max number of including the zero entry&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;handle&quot;, &quot;Pointer to an <a class="el" href="structcaffe2_1_1Index.html">Index</a> instance.&quot;)</td></tr>
<tr class="separator:aa27f518beb1be67269550ab8f7c1a4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681c61b01d9ab0de5e988d9559c94335"><td class="memItemLeft" align="right" valign="top"><a id="a681c61b01d9ab0de5e988d9559c94335"></a>
return an Int tensor of same shape containing the indices for each of the keys If the index is unknown entries are given index new entries are added into the index If an insert is necessary but max_elements has been fail DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;handle&quot;, &quot;Pointer to an <a class="el" href="structcaffe2_1_1Index.html">Index</a> instance.&quot;) .Input(1</td></tr>
<tr class="separator:a681c61b01d9ab0de5e988d9559c94335"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c50cc4e51fd8c20b2d367b45193122f"><td class="memItemLeft" align="right" valign="top"><a id="a0c50cc4e51fd8c20b2d367b45193122f"></a>
return an Int tensor of same shape containing the indices for each of the keys If the index is unknown entries are given index new entries are added into the index If an insert is necessary but max_elements has been fail DOC <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> of keys to be looked up&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;indices&quot;, &quot;Indices for each of the keys.&quot;)</td></tr>
<tr class="separator:a0c50cc4e51fd8c20b2d367b45193122f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad256e93f8c3da60ba21419a2bede66b6"><td class="memItemLeft" align="right" valign="top"><a id="ad256e93f8c3da60ba21419a2bede66b6"></a>
disallowing creation of new index entries Should not be called concurrently with IndexGet DOC The input handle&#160;</td><td class="memItemRight" valign="bottom"><b>EnforceInplace</b> ({{0, 0}})</td></tr>
<tr class="separator:ad256e93f8c3da60ba21419a2bede66b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfe9d288f31735c78ac30c07c2dbd18"><td class="memItemLeft" align="right" valign="top"><a id="a8bfe9d288f31735c78ac30c07c2dbd18"></a>
Pointer to an <a class="el" href="structcaffe2_1_1Index.html">Index</a> instance&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;items&quot;, &quot;1-D tensor with elements starting with index 1.&quot;) .Output(0</td></tr>
<tr class="separator:a8bfe9d288f31735c78ac30c07c2dbd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c401047f143621aa14d5b0873cea9b"><td class="memItemLeft" align="right" valign="top"><a id="a43c401047f143621aa14d5b0873cea9b"></a>
Pointer to an <a class="el" href="structcaffe2_1_1Index.html">Index</a> instance&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;items&quot;, &quot;Scalar int64 tensor with number of entries.&quot;)</td></tr>
<tr class="separator:a43c401047f143621aa14d5b0873cea9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f281293d10a867072b740077d058270"><td class="memItemLeft" align="right" valign="top"><a id="a0f281293d10a867072b740077d058270"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (<a class="el" href="classcaffe2_1_1IndexGetOp.html">IndexGetOp</a>)</td></tr>
<tr class="separator:a0f281293d10a867072b740077d058270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18aef91c7d93e6997aa19e28d3246fbf"><td class="memItemLeft" align="right" valign="top"><a id="a18aef91c7d93e6997aa19e28d3246fbf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (IntIndexCreate)</td></tr>
<tr class="separator:a18aef91c7d93e6997aa19e28d3246fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e94b1d33c7c70b44de59c6276ba264d"><td class="memItemLeft" align="right" valign="top"><a id="a8e94b1d33c7c70b44de59c6276ba264d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (LongIndexCreate)</td></tr>
<tr class="separator:a8e94b1d33c7c70b44de59c6276ba264d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab929f3d0e43c56b474afc25a53141a26"><td class="memItemLeft" align="right" valign="top"><a id="ab929f3d0e43c56b474afc25a53141a26"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (StringIndexCreate)</td></tr>
<tr class="separator:ab929f3d0e43c56b474afc25a53141a26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690f6626f025edb1699495d2aa157112"><td class="memItemLeft" align="right" valign="top"><a id="a690f6626f025edb1699495d2aa157112"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (IndexFreeze)</td></tr>
<tr class="separator:a690f6626f025edb1699495d2aa157112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d7bffcc3c74b78c3c3fc67b42d76df"><td class="memItemLeft" align="right" valign="top"><a id="a62d7bffcc3c74b78c3c3fc67b42d76df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (IndexLoad)</td></tr>
<tr class="separator:a62d7bffcc3c74b78c3c3fc67b42d76df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f2e92a711580482a684080e4c08922"><td class="memItemLeft" align="right" valign="top"><a id="a36f2e92a711580482a684080e4c08922"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (IndexStore)</td></tr>
<tr class="separator:a36f2e92a711580482a684080e4c08922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f15843d09e06554084a8116b544d8e5"><td class="memItemLeft" align="right" valign="top"><a id="a2f15843d09e06554084a8116b544d8e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (IndexSize)</td></tr>
<tr class="separator:a2f15843d09e06554084a8116b544d8e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2431e6b523ecc2eb8aced116bac416d1"><td class="memItemLeft" align="right" valign="top"><a id="a2431e6b523ecc2eb8aced116bac416d1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::unique_ptr&lt; <a class="el" href="structcaffe2_1_1IndexBase.html">caffe2::IndexBase</a> &gt;)</td></tr>
<tr class="separator:a2431e6b523ecc2eb8aced116bac416d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498534efc64526508676a9fa17b443bd"><td class="memItemLeft" align="right" valign="top"><a id="a498534efc64526508676a9fa17b443bd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_BLOB_SERIALIZER</b> ((<a class="el" href="classcaffe2_1_1TypeMeta.html#a0b050c4a9e4e5b2f9e099b0f2a6db019">TypeMeta::Id</a>&lt; std::unique_ptr&lt; <a class="el" href="structcaffe2_1_1IndexBase.html">caffe2::IndexBase</a> &gt;&gt;()), <a class="el" href="classcaffe2_1_1IndexSerializer.html">IndexSerializer</a>)</td></tr>
<tr class="separator:a498534efc64526508676a9fa17b443bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6bfcb6492d0e7044d8b2461f108e6c"><td class="memItemLeft" align="right" valign="top"><a id="a0b6bfcb6492d0e7044d8b2461f108e6c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_BLOB_DESERIALIZER</b> (std::unique_ptr&lt; <a class="el" href="structcaffe2_1_1IndexBase.html">caffe2::IndexBase</a> &gt;, <a class="el" href="classcaffe2_1_1IndexDeserializer.html">IndexDeserializer</a>)</td></tr>
<tr class="separator:a0b6bfcb6492d0e7044d8b2461f108e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2f4ceb2b6a85106b4378bee04a8b5c"><td class="memItemLeft" align="right" valign="top"><a id="a9e2f4ceb2b6a85106b4378bee04a8b5c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (InstanceNormGradient, <a class="el" href="classcaffe2_1_1InstanceNormGradientOp.html">InstanceNormGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9e2f4ceb2b6a85106b4378bee04a8b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c347803669d9cf2910272708ab0907"><td class="memItemLeft" align="right" valign="top"><a id="ac3c347803669d9cf2910272708ab0907"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (InstanceNormGradient).NumInputs(4</td></tr>
<tr class="separator:ac3c347803669d9cf2910272708ab0907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612b4e4d17f9e8d6c40579ec84b60e3b"><td class="memItemLeft" align="right" valign="top"><a id="a612b4e4d17f9e8d6c40579ec84b60e3b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumOutputs</b> (3)</td></tr>
<tr class="separator:a612b4e4d17f9e8d6c40579ec84b60e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81aee449bf149a09a82ec31f4882a63"><td class="memItemLeft" align="right" valign="top"><a id="af81aee449bf149a09a82ec31f4882a63"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (InstanceNorm, <a class="el" href="classcaffe2_1_1GetInstanceNormGradient.html">GetInstanceNormGradient</a>)</td></tr>
<tr class="separator:af81aee449bf149a09a82ec31f4882a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0af483cee269a5f5ff6b50caff6943"><td class="memItemLeft" align="right" valign="top"><a id="aef0af483cee269a5f5ff6b50caff6943"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (InstanceNorm, <a class="el" href="classcaffe2_1_1InstanceNormOp.html">InstanceNormOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aef0af483cee269a5f5ff6b50caff6943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327c089dfb7d86f6ea01447865c945cf"><td class="memItemLeft" align="right" valign="top"><a id="a327c089dfb7d86f6ea01447865c945cf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LayerNorm, <a class="el" href="classcaffe2_1_1LayerNormOp.html">LayerNormOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a327c089dfb7d86f6ea01447865c945cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8a78f0c564ee8f85feb8334b45944d"><td class="memItemLeft" align="right" valign="top"><a id="a0a8a78f0c564ee8f85feb8334b45944d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LayerNormGradient).NumInputs(5).NumOutputs(1)</td></tr>
<tr class="separator:a0a8a78f0c564ee8f85feb8334b45944d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e01bb0ae44a6c2b47a44852cc72ff2"><td class="memItemLeft" align="right" valign="top"><a id="aa6e01bb0ae44a6c2b47a44852cc72ff2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LayerNormGradient, <a class="el" href="classcaffe2_1_1LayerNormGradientOp.html">LayerNormGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa6e01bb0ae44a6c2b47a44852cc72ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8528c57a6e4c9f15081661271e9411"><td class="memItemLeft" align="right" valign="top"><a id="aea8528c57a6e4c9f15081661271e9411"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (LayerNorm, GetLayerNormGradient)</td></tr>
<tr class="separator:aea8528c57a6e4c9f15081661271e9411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b031020b594a1fc2472f642593ff33"><td class="memItemLeft" align="right" valign="top"><a id="a85b031020b594a1fc2472f642593ff33"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>input_dims</b> (input_dims_long.begin(), input_dims_long.end())</td></tr>
<tr class="separator:a85b031020b594a1fc2472f642593ff33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361340ae951d832bd229b551db6d686c"><td class="memItemLeft" align="right" valign="top"><a id="a361340ae951d832bd229b551db6d686c"></a>
<a class="el" href="classcaffe2_1_1ArgumentHelper.html">ArgumentHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><b>helper</b> (def)</td></tr>
<tr class="separator:a361340ae951d832bd229b551db6d686c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b896aa28455a7f33ba3d7f55d0b7e00"><td class="memItemLeft" align="right" valign="top"><a id="a3b896aa28455a7f33ba3d7f55d0b7e00"></a>
std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>stat_dims</b> (input_dims.begin(), input_dims.begin()+canonical_axis)</td></tr>
<tr class="separator:a3b896aa28455a7f33ba3d7f55d0b7e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe470c342523160213450ac5708d0041"><td class="memItemLeft" align="right" valign="top"><a id="afe470c342523160213450ac5708d0041"></a>
stat_dims&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (1)</td></tr>
<tr class="separator:afe470c342523160213450ac5708d0041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa376170f8f43acd894762000ccd13698"><td class="memItemLeft" align="right" valign="top"><a id="aa376170f8f43acd894762000ccd13698"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Computes layer normalization as described in https://arxiv.org/pdf/1607.06450.pdf.
Given an input vector x \ [a_0, a_1, ...,a_{k-1}, a_k, ..., a_{n-1}],
this op treats dimensions a_k through a_{n-1} as feature vectors. For each
feature vector, the op contains the mean and standard deviation. Then,
it returns the normalized values (with restdev_mapct to the feature vector).

Note that this op does not contain the scale an bias terms described in the
paper. Simply follow this op with an FC op to add those. Concretely, this op
implements:

h = \ac{1}{\gma}(a - \)
where \ = \ac{1}{H}\m_{i=1}^{H} a_i
and \gma = \rt{\ac{1}{H}\m_{i=1}^{H}(a_i - \)^2}
where H is the number of hidden units (i.e. product of dimensions from 'axis'
to the end.)
)DOC&quot;) .Arg(&quot;axis&quot;</td></tr>
<tr class="separator:aa376170f8f43acd894762000ccd13698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135b84b5aaf9efdc0e338a903d1e779e"><td class="memItemLeft" align="right" valign="top"><a id="a135b84b5aaf9efdc0e338a903d1e779e"></a>
Describes axis of the inputs Defaults to one because the axis most likely describes the batch size&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;epsilon&quot;, &quot;(float) default to 0.001. Small value to be added to the stdev when&quot; &quot; dividing out by that value. This prevents division by zero.&quot;) .Input(0</td></tr>
<tr class="separator:a135b84b5aaf9efdc0e338a903d1e779e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14aebba12a87650f7dc978ccd555b50a"><td class="memItemLeft" align="right" valign="top"><a id="a14aebba12a87650f7dc978ccd555b50a"></a>
Describes axis of the inputs Defaults to one because the axis most likely describes the batch size Input tensor which layer normalization will be applied to&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;output&quot;, &quot;Normalized values&quot;) .Output(1</td></tr>
<tr class="separator:a14aebba12a87650f7dc978ccd555b50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0661ebdc5f627d7f8dfad2593a3db595"><td class="memItemLeft" align="right" valign="top"><a id="a0661ebdc5f627d7f8dfad2593a3db595"></a>
Describes axis of the inputs Defaults to one because the axis most likely describes the batch size Input tensor which layer normalization will be applied to Mean values for each feature vector&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (2, &quot;stddev&quot;, &quot;Standard deviations for each feature vector&quot;)</td></tr>
<tr class="separator:a0661ebdc5f627d7f8dfad2593a3db595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2263206a567cd499e2088b447264c4cb"><td class="memItemLeft" align="right" valign="top"><a id="a2263206a567cd499e2088b447264c4cb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LeakyRelu, <a class="el" href="classcaffe2_1_1LeakyReluOp.html">LeakyReluOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a2263206a567cd499e2088b447264c4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411c5b13234bf990c1555a10fb09b95d"><td class="memItemLeft" align="right" valign="top"><a id="a411c5b13234bf990c1555a10fb09b95d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LeakyReluGradient, <a class="el" href="classcaffe2_1_1LeakyReluGradientOp.html">LeakyReluGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a411c5b13234bf990c1555a10fb09b95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d53aba3f2a6785639f64ab67c1ad943"><td class="memItemLeft" align="right" valign="top"><a id="a8d53aba3f2a6785639f64ab67c1ad943"></a>
Coefficient of leakage&#160;</td><td class="memItemRight" valign="bottom"><b>AllowInplace</b> ({{0, 0}}) .CostInferenceFunction(PointwiseCostInference&lt; 2 &gt;) .IdenticalTypeAndShape() .SetDoc(R&quot;DOC( LeakyRelu takes input data (<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt;T&gt;) and an argument alpha</td></tr>
<tr class="separator:a8d53aba3f2a6785639f64ab67c1ad943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5eb187026a0f5b7923d0a09048e1d1"><td class="memItemLeft" align="right" valign="top"><a id="a1c5eb187026a0f5b7923d0a09048e1d1"></a>
Coefficient of leakage and produces one output&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; T &gt;) where the function `f(x)</td></tr>
<tr class="separator:a1c5eb187026a0f5b7923d0a09048e1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac10014595bb232f01b33171e68ba351a"><td class="memItemLeft" align="right" valign="top"><a id="ac10014595bb232f01b33171e68ba351a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;alpha&quot;, &quot;Coefficient of leakage&quot;)</td></tr>
<tr class="separator:ac10014595bb232f01b33171e68ba351a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae6b082c1a7064c4fc73157bc41643f"><td class="memItemLeft" align="right" valign="top"><a id="a1ae6b082c1a7064c4fc73157bc41643f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (LeakyRelu, <a class="el" href="classcaffe2_1_1GetLeakyReluGradient.html">GetLeakyReluGradient</a>)</td></tr>
<tr class="separator:a1ae6b082c1a7064c4fc73157bc41643f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798a8776e3c600a7c4fb72e0d75078bd"><td class="memItemLeft" align="right" valign="top"><a id="a798a8776e3c600a7c4fb72e0d75078bd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR_STR</b> (&quot;SparseLengthsSum&quot;, CPUSparseLengthsReductionOp&lt; float, <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float, float16 &gt;, 0, 0 &gt;)</td></tr>
<tr class="separator:a798a8776e3c600a7c4fb72e0d75078bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b29b394b27bc0898b8e7d08b66132d"><td class="memItemLeft" align="right" valign="top"><a id="ac0b29b394b27bc0898b8e7d08b66132d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR_STR</b> (&quot;SparseLengthsWeightedSum&quot;, CPUSparseLengthsReductionOp&lt; float, <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float, float16 &gt;, 1, 0 &gt;)</td></tr>
<tr class="separator:ac0b29b394b27bc0898b8e7d08b66132d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf19f82c38a0ef58c19964ab068c857"><td class="memItemLeft" align="right" valign="top"><a id="abcf19f82c38a0ef58c19964ab068c857"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR_STR</b> (&quot;SparseLengthsMean&quot;, CPUSparseLengthsReductionOp&lt; float, <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float, float16 &gt;, 0, 1 &gt;)</td></tr>
<tr class="separator:abcf19f82c38a0ef58c19964ab068c857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafe488e6db7646a9d15aec155a0fc04"><td class="memItemLeft" align="right" valign="top"><a id="afafe488e6db7646a9d15aec155a0fc04"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Rowwise8BitQuantizedToFloat, <a class="el" href="classcaffe2_1_1Rowwise8BitQuantizedToFloatOp.html">Rowwise8BitQuantizedToFloatOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:afafe488e6db7646a9d15aec155a0fc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a75b30a0c88ed4f390bf2e445d68311"><td class="memItemLeft" align="right" valign="top"><a id="a1a75b30a0c88ed4f390bf2e445d68311"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FloatToRowwiseQuantized8Bits, <a class="el" href="classcaffe2_1_1FloatToRowwiseQuantized8BitsOp.html">FloatToRowwiseQuantized8BitsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1a75b30a0c88ed4f390bf2e445d68311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e9bc5b0516a81f46642c5c36d55f4c9"><td class="memItemLeft" align="right" valign="top"><a id="a8e9bc5b0516a81f46642c5c36d55f4c9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseLengthsSum8BitsRowwise, <a class="el" href="classcaffe2_1_1SparseLengths8BitsRowwiseOp.html">SparseLengths8BitsRowwiseOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a8e9bc5b0516a81f46642c5c36d55f4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a52395c5f3f9c00284b61da06cadc8"><td class="memItemLeft" align="right" valign="top"><a id="ab5a52395c5f3f9c00284b61da06cadc8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseLengthsWeightedSum8BitsRowwise, <a class="el" href="classcaffe2_1_1SparseLengths8BitsRowwiseOp.html">SparseLengths8BitsRowwiseOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, 1 &gt;)</td></tr>
<tr class="separator:ab5a52395c5f3f9c00284b61da06cadc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5ca5d3b1682fd375392731ad2ebfae"><td class="memItemLeft" align="right" valign="top"><a id="a4e5ca5d3b1682fd375392731ad2ebfae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseLengthsMean8BitsRowwise, <a class="el" href="classcaffe2_1_1SparseLengths8BitsRowwiseOp.html">SparseLengths8BitsRowwiseOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, 0, 1 &gt;)</td></tr>
<tr class="separator:a4e5ca5d3b1682fd375392731ad2ebfae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906c1b465e20295abe7d0a644ba260f4"><td class="memItemLeft" align="right" valign="top"><a id="a906c1b465e20295abe7d0a644ba260f4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseLengthsWeightedMean8BitsRowwise, <a class="el" href="classcaffe2_1_1SparseLengths8BitsRowwiseOp.html">SparseLengths8BitsRowwiseOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, 1, 1 &gt;)</td></tr>
<tr class="separator:a906c1b465e20295abe7d0a644ba260f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53309262cf244ee421972e1b5c45a1f9"><td class="memItemLeft" align="right" valign="top"><a id="a53309262cf244ee421972e1b5c45a1f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (5) .NumOutputs(1) .SetDoc(R&quot;DOC(Variation of SparseLengthsWeightedSum operator</td></tr>
<tr class="separator:a53309262cf244ee421972e1b5c45a1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a4c21d978b7a522f0b1dbbaba01b73"><td class="memItemLeft" align="right" valign="top"><a id="a53a4c21d978b7a522f0b1dbbaba01b73"></a>
reshape it into matrix of&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (m_1, m_2 x... x m_n) and apply row-wise quantization. After this</td></tr>
<tr class="separator:a53a4c21d978b7a522f0b1dbbaba01b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f43185518d07a4972af6391036524f"><td class="memItemLeft" align="right" valign="top"><a id="a30f43185518d07a4972af6391036524f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (Rowwise8BitQuantizedToFloat)</td></tr>
<tr class="separator:a30f43185518d07a4972af6391036524f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab955b674bc3eef5b4e11be15854f4a58"><td class="memItemLeft" align="right" valign="top"><a id="ab955b674bc3eef5b4e11be15854f4a58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (FloatToRowwiseQuantized8Bits)</td></tr>
<tr class="separator:ab955b674bc3eef5b4e11be15854f4a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31761fa6a21e4722cad8b5b8336433f0"><td class="memItemLeft" align="right" valign="top"><a id="a31761fa6a21e4722cad8b5b8336433f0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (SparseLengthsSum8BitsRowwise)</td></tr>
<tr class="separator:a31761fa6a21e4722cad8b5b8336433f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6e17cd7f773983c7ff8958cfbe1a6e"><td class="memItemLeft" align="right" valign="top"><a id="acd6e17cd7f773983c7ff8958cfbe1a6e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (SparseLengthsWeightedSum8BitsRowwise)</td></tr>
<tr class="separator:acd6e17cd7f773983c7ff8958cfbe1a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28abebee9dcb7db4b73ea9a334981e2"><td class="memItemLeft" align="right" valign="top"><a id="af28abebee9dcb7db4b73ea9a334981e2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (SparseLengthsMean8BitsRowwise)</td></tr>
<tr class="separator:af28abebee9dcb7db4b73ea9a334981e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae338e633b6c9b6d53aa17d141c2173d1"><td class="memItemLeft" align="right" valign="top"><a id="ae338e633b6c9b6d53aa17d141c2173d1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (SparseLengthsWeightedMean8BitsRowwise)</td></tr>
<tr class="separator:ae338e633b6c9b6d53aa17d141c2173d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ba780c03088ffdf5e3d08f6d274a4e"><td class="memItemLeft" align="right" valign="top"><a id="a38ba780c03088ffdf5e3d08f6d274a4e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsTile, <a class="el" href="classcaffe2_1_1LengthsTileOp.html">LengthsTileOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a38ba780c03088ffdf5e3d08f6d274a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd3db8301af4ab684ea15332b24e8f0"><td class="memItemLeft" align="right" valign="top"><a id="a6cd3db8301af4ab684ea15332b24e8f0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (LengthsTile, <a class="el" href="classcaffe2_1_1LengthsTileOp.html">LengthsTileOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a6cd3db8301af4ab684ea15332b24e8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1706e4dfb2e27ede3b5f7690d961ad2d"><td class="memItemLeft" align="right" valign="top"><a id="a1706e4dfb2e27ede3b5f7690d961ad2d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsTopK, <a class="el" href="classcaffe2_1_1LengthsTopKOp.html">LengthsTopKOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1706e4dfb2e27ede3b5f7690d961ad2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a580d523aaa232eb0d30a9e9c1d0ae8"><td class="memItemLeft" align="right" valign="top"><a id="a9a580d523aaa232eb0d30a9e9c1d0ae8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsTopKGradient, <a class="el" href="classcaffe2_1_1LengthsTopKGradientOp.html">LengthsTopKGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9a580d523aaa232eb0d30a9e9c1d0ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8205ae3aa52c6b60a675ff3869584a"><td class="memItemLeft" align="right" valign="top"><a id="a0d8205ae3aa52c6b60a675ff3869584a"></a>
where segments are defined by their and concatenate them in an output tensor of the output value will be padded and the corresponding output indices will be padded by DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;DATA&quot;, &quot;<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> of rank 1. First dimension must be equal to the sum of &quot; &quot;lengths&quot;) .Input(1</td></tr>
<tr class="separator:a0d8205ae3aa52c6b60a675ff3869584a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ceb785876d40f46958fd92aa5819306"><td class="memItemLeft" align="right" valign="top"><a id="a6ceb785876d40f46958fd92aa5819306"></a>
where segments are defined by their and concatenate them in an output tensor of the output value will be padded and the corresponding output indices will be padded by DOC <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> of int32 lengths of rank&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;TopKValue&quot;, &quot;Output top k elements for each segment, with&quot; &quot;shape=(SIZE(lengths), k)&quot;) .Output(1</td></tr>
<tr class="separator:a6ceb785876d40f46958fd92aa5819306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad78174ad03435dd091bfd21027da398"><td class="memItemLeft" align="right" valign="top"><a id="aad78174ad03435dd091bfd21027da398"></a>
where segments are defined by their and concatenate them in an output tensor of the output value will be padded and the corresponding output indices will be padded by DOC <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> of int32 lengths of rank Output indices in DATA corresponding to value in TopKValue&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;k&quot;, &quot;the number of top values to return for each segment, if the number &quot; &quot;of values is smaller than k, the values would be padded with 0 and &quot; &quot;indices would be padded with -1.&quot;)</td></tr>
<tr class="separator:aad78174ad03435dd091bfd21027da398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9882aad183ec1a93cbdef02f529bdbb4"><td class="memItemLeft" align="right" valign="top"><a id="a9882aad183ec1a93cbdef02f529bdbb4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LengthsTopKGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a9882aad183ec1a93cbdef02f529bdbb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a103f939c0cd701c1548e4d7a8ca1b9"><td class="memItemLeft" align="right" valign="top"><a id="a3a103f939c0cd701c1548e4d7a8ca1b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (LengthsTopK, GetLengthsTopKGradient)</td></tr>
<tr class="separator:a3a103f939c0cd701c1548e4d7a8ca1b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9327141f225d709f7ffc9c4049768167"><td class="memItemLeft" align="right" valign="top"><a id="a9327141f225d709f7ffc9c4049768167"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DBExists, <a class="el" href="classcaffe2_1_1DBExistsOp.html">DBExistsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9327141f225d709f7ffc9c4049768167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a3c43568d2c93a45f3cf3313bfa02f"><td class="memItemLeft" align="right" valign="top"><a id="a83a3c43568d2c93a45f3cf3313bfa02f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Load, <a class="el" href="classcaffe2_1_1LoadOp.html">LoadOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a83a3c43568d2c93a45f3cf3313bfa02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4857a64f8d05730bf604eb9b6f789da8"><td class="memItemLeft" align="right" valign="top"><a id="a4857a64f8d05730bf604eb9b6f789da8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Save, <a class="el" href="classcaffe2_1_1SaveOp.html">SaveOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4857a64f8d05730bf604eb9b6f789da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89777888c5fe5010a5db2e9fa335fae6"><td class="memItemLeft" align="right" valign="top"><a id="a89777888c5fe5010a5db2e9fa335fae6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Checkpoint, <a class="el" href="classcaffe2_1_1CheckpointOp.html">CheckpointOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a89777888c5fe5010a5db2e9fa335fae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34354f11cf682249cc1ce24a8114cd1e"><td class="memItemLeft" align="right" valign="top"><a id="a34354f11cf682249cc1ce24a8114cd1e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Snapshot, <a class="el" href="classcaffe2_1_1CheckpointOp.html">CheckpointOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a34354f11cf682249cc1ce24a8114cd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea06a0a123c63ac63edf021ec2e1d4e4"><td class="memItemLeft" align="right" valign="top"><a id="aea06a0a123c63ac63edf021ec2e1d4e4"></a>
A scalar bool <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;absolute_path&quot;, &quot;(int, default 0) if set, use the db path directly and do not prepend &quot; &quot;the current root folder of the workspace.&quot;) .Arg(&quot;db_name&quot;</td></tr>
<tr class="separator:aea06a0a123c63ac63edf021ec2e1d4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64000d6aeae17c860de3d9d7134ff95d"><td class="memItemLeft" align="right" valign="top"><a id="a64000d6aeae17c860de3d9d7134ff95d"></a>
A scalar bool <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> string the path to the db to load&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;db_type&quot;, &quot;(string) the type of the db.&quot;)</td></tr>
<tr class="separator:a64000d6aeae17c860de3d9d7134ff95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5190ab68a09d7c721ca5bf353e4a62d4"><td class="memItemLeft" align="right" valign="top"><a id="a5190ab68a09d7c721ca5bf353e4a62d4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (0, INT_MAX) .NumOutputs(0</td></tr>
<tr class="separator:a5190ab68a09d7c721ca5bf353e4a62d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9554438a0f174b7bfdc602d72a6338b1"><td class="memItemLeft" align="right" valign="top"><a id="a9554438a0f174b7bfdc602d72a6338b1"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
The Load operator loads a set of serialized blobs from a db or multiple dbs. It
takes [0, infinity) number of inputs and [0, infinity) number of outputs, using
the db keys to match the db entries with the outputs.

If at least one input is passed, then it is assumed that that input blobs are a
set of DBReaders to load from. Otherwise the db or dbs argument is used to load
blobs from one single db or multiple dbs respectively. db_type argument is used
to specify the type of the input db/dbs.
)DOC&quot;) .Arg(&quot;absolute_path&quot;</td></tr>
<tr class="separator:a9554438a0f174b7bfdc602d72a6338b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482abafee14df7f84b9a4317caf89ac1"><td class="memItemLeft" align="right" valign="top"><a id="a482abafee14df7f84b9a4317caf89ac1"></a>
INT_MAX default if use the db path directly and do not prepend the current root folder of the workspace&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;add_prefix&quot;, &quot;(string, default=\) blobs will be prefixed with this when loading.&quot; &quot;Useful for avoiding collisions with blobs existing in the workspace.&quot; &quot;The output blob names specified to this op should include this prefix.&quot;) .Arg(&quot;strip_prefix&quot;</td></tr>
<tr class="separator:a482abafee14df7f84b9a4317caf89ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298cb6a684b9294563f9d48eeb4da5ad"><td class="memTemplParams" colspan="2"><a id="a298cb6a684b9294563f9d48eeb4da5ad"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a298cb6a684b9294563f9d48eeb4da5ad"><td class="memTemplItemLeft" align="right" valign="top">string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>FormatString</b> (const string &amp;pattern, Ts... values)</td></tr>
<tr class="separator:a298cb6a684b9294563f9d48eeb4da5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8186606e8b24d29010b076a7c9ccc9"><td class="memItemLeft" align="right" valign="top"><a id="aab8186606e8b24d29010b076a7c9ccc9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Load, <a class="el" href="classcaffe2_1_1LoadOp.html">LoadOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aab8186606e8b24d29010b076a7c9ccc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af101d9b19521d084f15edd39e20c43e8"><td class="memItemLeft" align="right" valign="top"><a id="af101d9b19521d084f15edd39e20c43e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Save, <a class="el" href="classcaffe2_1_1SaveOp.html">SaveOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:af101d9b19521d084f15edd39e20c43e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8145f81bb04342575425becdd999e2f3"><td class="memItemLeft" align="right" valign="top"><a id="a8145f81bb04342575425becdd999e2f3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Checkpoint, <a class="el" href="classcaffe2_1_1CheckpointOp.html">CheckpointOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a8145f81bb04342575425becdd999e2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7702dd289068377c4356b52ee90b74ec"><td class="memItemLeft" align="right" valign="top"><a id="a7702dd289068377c4356b52ee90b74ec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LRN, <a class="el" href="classcaffe2_1_1LRNOp.html">LRNOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7702dd289068377c4356b52ee90b74ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dbd0b26aaca2fac07d5191c2ffb419"><td class="memItemLeft" align="right" valign="top"><a id="a05dbd0b26aaca2fac07d5191c2ffb419"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LRNGradient, <a class="el" href="classcaffe2_1_1LRNGradientOp.html">LRNGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a05dbd0b26aaca2fac07d5191c2ffb419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e642c413569153b1122d6e5acbefea"><td class="memItemLeft" align="right" valign="top"><a id="a86e642c413569153b1122d6e5acbefea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LRN).NumInputs(1).NumOutputs(1</td></tr>
<tr class="separator:a86e642c413569153b1122d6e5acbefea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887777439f2aa62e31317e81d3ebf359"><td class="memItemLeft" align="right" valign="top"><a id="a887777439f2aa62e31317e81d3ebf359"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LRNGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a887777439f2aa62e31317e81d3ebf359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c499f29f00ec4a299b806f50d19b83"><td class="memItemLeft" align="right" valign="top"><a id="af3c499f29f00ec4a299b806f50d19b83"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (LRN, <a class="el" href="classcaffe2_1_1GetLRNGradient.html">GetLRNGradient</a>)</td></tr>
<tr class="separator:af3c499f29f00ec4a299b806f50d19b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d9fdf95c6a6174779262572e85ae15"><td class="memItemLeft" align="right" valign="top"><a id="a33d9fdf95c6a6174779262572e85ae15"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Log, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1LogCPUFunctor.html">LogCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:a33d9fdf95c6a6174779262572e85ae15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f7b405b7c8bab8fb79c8174334e6b7"><td class="memItemLeft" align="right" valign="top"><a id="a58f7b405b7c8bab8fb79c8174334e6b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Log, <a class="el" href="classcaffe2_1_1GetLogGradient.html">GetLogGradient</a>)</td></tr>
<tr class="separator:a58f7b405b7c8bab8fb79c8174334e6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250ed5092331240ad4d9dafee72589e5"><td class="memItemLeft" align="right" valign="top"><a id="a250ed5092331240ad4d9dafee72589e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Logit, <a class="el" href="classcaffe2_1_1UnaryElementwiseWithArgsOp.html">UnaryElementwiseWithArgsOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1LogitCPUFunctor.html">LogitCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:a250ed5092331240ad4d9dafee72589e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f92115b6b354c26c521c337d50f02d"><td class="memItemLeft" align="right" valign="top"><a id="ae7f92115b6b354c26c521c337d50f02d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LogitGradient, <a class="el" href="classcaffe2_1_1LogitGradientOp.html">LogitGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae7f92115b6b354c26c521c337d50f02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6a546b2bb8f24d41dc111c6b57f08d"><td class="memItemLeft" align="right" valign="top"><a id="a9b6a546b2bb8f24d41dc111c6b57f08d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (<a class="el" href="classcaffe2_1_1AveragedLoss.html">AveragedLoss</a>, <a class="el" href="classcaffe2_1_1AveragedLoss.html">AveragedLoss</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9b6a546b2bb8f24d41dc111c6b57f08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e97ffdbe98d84cba77c1e2ea9bd950"><td class="memItemLeft" align="right" valign="top"><a id="a75e97ffdbe98d84cba77c1e2ea9bd950"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (<a class="el" href="classcaffe2_1_1AveragedLossGradient.html">AveragedLossGradient</a>, <a class="el" href="classcaffe2_1_1AveragedLossGradient.html">AveragedLossGradient</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a75e97ffdbe98d84cba77c1e2ea9bd950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44131466951f0c7f19ca61bbd332e921"><td class="memItemLeft" align="right" valign="top"><a id="a44131466951f0c7f19ca61bbd332e921"></a>
NumInputs(1) .NumOutputs(1) .ScalarType(TensorProto&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (<a class="el" href="classcaffe2_1_1AveragedLossGradient.html">AveragedLossGradient</a>).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a44131466951f0c7f19ca61bbd332e921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70fd91f38572036a41ec4bec609a830"><td class="memItemLeft" align="right" valign="top"><a id="ae70fd91f38572036a41ec4bec609a830"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (<a class="el" href="classcaffe2_1_1AveragedLoss.html">AveragedLoss</a>, <a class="el" href="classcaffe2_1_1GetAveragedLossGradient.html">GetAveragedLossGradient</a>)</td></tr>
<tr class="separator:ae70fd91f38572036a41ec4bec609a830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16eea3b2df140dd6963ab3f3a69df3ff"><td class="memItemLeft" align="right" valign="top"><a id="a16eea3b2df140dd6963ab3f3a69df3ff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (<a class="el" href="classcaffe2_1_1LpPool.html">LpPool</a>, <a class="el" href="classcaffe2_1_1PoolOp.html">PoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1LpPool.html">LpPool</a> &gt;)</td></tr>
<tr class="separator:a16eea3b2df140dd6963ab3f3a69df3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c17fe3eeb5785b7dde994ceea34ecab"><td class="memItemLeft" align="right" valign="top"><a id="a7c17fe3eeb5785b7dde994ceea34ecab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LpPoolGradient, <a class="el" href="classcaffe2_1_1PoolGradientOp.html">PoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1LpPool.html">LpPool</a> &gt;)</td></tr>
<tr class="separator:a7c17fe3eeb5785b7dde994ceea34ecab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67dc82f98dc8bdba510eabac0b05218"><td class="memItemLeft" align="right" valign="top"><a id="ae67dc82f98dc8bdba510eabac0b05218"></a>
stride and pad lengths defined by the <a class="el" href="classcaffe2_1_1ConvPoolOpBase.html">ConvPoolOpBase</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator. L-p pooling consisting of taking the L-p norm of a subset of the input tensor according to the kernel size and downsampling the data into the output blob Y for further processing.) DOC&quot;) .Input</b> (0, &quot;X&quot;, &quot;Input data tensor from the previous operator; dimensions &quot; &quot;depend on whether the NCHW or NHWC operators are being used. For example, &quot; &quot;in the former, the input has size (N x C x H x W), where N is the batch &quot; &quot;size, C is the number of channels, and H and W are the height and the width &quot; &quot;of the data. The corresponding permutation of dimensions is used in the &quot; &quot;latter case. &quot;) .Output(0</td></tr>
<tr class="separator:ae67dc82f98dc8bdba510eabac0b05218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab436155bdeca962ec444820f3aa30b7d"><td class="memItemLeft" align="right" valign="top"><a id="ab436155bdeca962ec444820f3aa30b7d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LpPoolGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:ab436155bdeca962ec444820f3aa30b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41bcbb51139cc41b96eaae6c31182a5"><td class="memItemLeft" align="right" valign="top"><a id="ae41bcbb51139cc41b96eaae6c31182a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (<a class="el" href="classcaffe2_1_1LpPool.html">LpPool</a>, <a class="el" href="classcaffe2_1_1GetPoolGradient.html">GetPoolGradient</a>)</td></tr>
<tr class="separator:ae41bcbb51139cc41b96eaae6c31182a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4233cbd96ab2aa3f1dac368f5af4776a"><td class="memItemLeft" align="right" valign="top"><a id="a4233cbd96ab2aa3f1dac368f5af4776a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LSTMUnit, <a class="el" href="classcaffe2_1_1LSTMUnitOp.html">LSTMUnitOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4233cbd96ab2aa3f1dac368f5af4776a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae556702783a95dfa3475ae030ec0fa82"><td class="memItemLeft" align="right" valign="top"><a id="ae556702783a95dfa3475ae030ec0fa82"></a>
in a sequence length aware fashion given the previous cell and the sequence computes the LSTM avoiding computation if the input is&#160;</td><td class="memItemRight" valign="bottom"><b>invalid</b> (as in, the value at X{t][n] &gt;=seqLengths[n].) DOC&quot;) .Arg(&quot;forget_bias&quot;</td></tr>
<tr class="separator:ae556702783a95dfa3475ae030ec0fa82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d1a5de72aa682f38ea6ba570466b89"><td class="memItemLeft" align="right" valign="top"><a id="ab4d1a5de72aa682f38ea6ba570466b89"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LSTMUnitGradient, <a class="el" href="classcaffe2_1_1LSTMUnitGradientOp.html">LSTMUnitGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab4d1a5de72aa682f38ea6ba570466b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab69c0a2f50b59adab4f44cda7815464c"><td class="memItemLeft" align="right" valign="top"><a id="ab69c0a2f50b59adab4f44cda7815464c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LSTMUnitGradient).NumInputs(9).NumOutputs(3)</td></tr>
<tr class="separator:ab69c0a2f50b59adab4f44cda7815464c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077ac830f10218a734569cd51deb4410"><td class="memItemLeft" align="right" valign="top"><a id="a077ac830f10218a734569cd51deb4410"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (LSTMUnit, <a class="el" href="classcaffe2_1_1GetLSTMUnitGradient.html">GetLSTMUnitGradient</a>)</td></tr>
<tr class="separator:a077ac830f10218a734569cd51deb4410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935a0791880f503ec8ee08fa44991230"><td class="memItemLeft" align="right" valign="top"><a id="a935a0791880f503ec8ee08fa44991230"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (MapType64To64)</td></tr>
<tr class="separator:a935a0791880f503ec8ee08fa44991230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3a404643b4e355cd537ac2b294511e"><td class="memItemLeft" align="right" valign="top"><a id="a6d3a404643b4e355cd537ac2b294511e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MarginRankingCriterion, <a class="el" href="classcaffe2_1_1MarginRankingCriterionOp.html">MarginRankingCriterionOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a6d3a404643b4e355cd537ac2b294511e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb68f6a378891063c08d234a8677c18"><td class="memItemLeft" align="right" valign="top"><a id="a1fb68f6a378891063c08d234a8677c18"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MarginRankingCriterionGradient, <a class="el" href="classcaffe2_1_1MarginRankingCriterionGradientOp.html">MarginRankingCriterionGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1fb68f6a378891063c08d234a8677c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221530d69644f1bd4394db1c33e53908"><td class="memItemLeft" align="right" valign="top"><a id="a221530d69644f1bd4394db1c33e53908"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>X2</b> (<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; float &gt;)</td></tr>
<tr class="separator:a221530d69644f1bd4394db1c33e53908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e52233068529b83316f48ac31d09be"><td class="memItemLeft" align="right" valign="top"><a id="af9e52233068529b83316f48ac31d09be"></a>
and label&#160;</td><td class="memItemRight" valign="bottom"><b>Y</b> (<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; int &gt;) to produce the loss(<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; float &gt;) where the loss function</td></tr>
<tr class="separator:af9e52233068529b83316f48ac31d09be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c96e20a3a753848fc97b32479cf08fc"><td class="memItemLeft" align="right" valign="top"><a id="a1c96e20a3a753848fc97b32479cf08fc"></a>
and label&#160;</td><td class="memItemRight" valign="bottom"><b>loss</b> (X1, X2, Y)</td></tr>
<tr class="separator:a1c96e20a3a753848fc97b32479cf08fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a741fa9b09cc187138f4a426ab86917"><td class="memItemLeft" align="right" valign="top"><a id="a9a741fa9b09cc187138f4a426ab86917"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Sqr, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1SqrCPUFunctor.html">SqrCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:a9a741fa9b09cc187138f4a426ab86917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb85ed3dcc313ac804f663e98adb2a81"><td class="memItemLeft" align="right" valign="top"><a id="adb85ed3dcc313ac804f663e98adb2a81"></a>
Input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;output&quot;, &quot;Squared elements of the input&quot;)</td></tr>
<tr class="separator:adb85ed3dcc313ac804f663e98adb2a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fcb2d245e7e6b81d316fa21f29d9c2"><td class="memItemLeft" align="right" valign="top"><a id="a24fcb2d245e7e6b81d316fa21f29d9c2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Sqr, <a class="el" href="classcaffe2_1_1GetSqrGradient.html">GetSqrGradient</a>)</td></tr>
<tr class="separator:a24fcb2d245e7e6b81d316fa21f29d9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7db41b70dd41a1fcfa5939c9116f5b"><td class="memItemLeft" align="right" valign="top"><a id="a6a7db41b70dd41a1fcfa5939c9116f5b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Sign, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1SignCPUFunctor.html">SignCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:a6a7db41b70dd41a1fcfa5939c9116f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71862c888d76ce10dd13ba7f842c8662"><td class="memItemLeft" align="right" valign="top"><a id="a71862c888d76ce10dd13ba7f842c8662"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MatMul, <a class="el" href="classcaffe2_1_1MatMulOp.html">MatMulOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a71862c888d76ce10dd13ba7f842c8662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7f2f8b84b4b110130403e258a953e1"><td class="memItemLeft" align="right" valign="top"><a id="aea7f2f8b84b4b110130403e258a953e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (2, 3) .NumOutputs(1) .TensorInferenceFunction([](const OperatorDef &amp;def</td></tr>
<tr class="separator:aea7f2f8b84b4b110130403e258a953e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4798b759aa7e727e9dba79fa8442be63"><td class="memItemLeft" align="right" valign="top"><a id="a4798b759aa7e727e9dba79fa8442be63"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (trans_a)</td></tr>
<tr class="separator:a4798b759aa7e727e9dba79fa8442be63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a56694d062fe35e23b4e0066303e67b"><td class="memItemLeft" align="right" valign="top"><a id="a0a56694d062fe35e23b4e0066303e67b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (trans_b)</td></tr>
<tr class="separator:a0a56694d062fe35e23b4e0066303e67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802ebf379af3fc6d0a7a0546550717ee"><td class="memItemLeft" align="right" valign="top"><a id="a802ebf379af3fc6d0a7a0546550717ee"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (M)</td></tr>
<tr class="separator:a802ebf379af3fc6d0a7a0546550717ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2021ee2afe42aa981c2e83b89b685d4"><td class="memItemLeft" align="right" valign="top"><a id="ac2021ee2afe42aa981c2e83b89b685d4"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (N)</td></tr>
<tr class="separator:ac2021ee2afe42aa981c2e83b89b685d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cc8c00f0feb088e9031ce36f2b0afe"><td class="memItemLeft" align="right" valign="top"><a id="ac6cc8c00f0feb088e9031ce36f2b0afe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Matrix multiplication Y = A * B, where A has size (M x K), B has size (K x N),
and Y will have a size (M x N).
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:ac6cc8c00f0feb088e9031ce36f2b0afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e53f15e11f648a2eb242160aa87d54"><td class="memItemLeft" align="right" valign="top"><a id="a63e53f15e11f648a2eb242160aa87d54"></a>
matrix of&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (M x K)&quot;) .Input(1</td></tr>
<tr class="separator:a63e53f15e11f648a2eb242160aa87d54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cc5552a591d1184cdb922fd126081b"><td class="memItemLeft" align="right" valign="top"><a id="af1cc5552a591d1184cdb922fd126081b"></a>
matrix of matrix of&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (K x N)&quot;) .Output(0</td></tr>
<tr class="separator:af1cc5552a591d1184cdb922fd126081b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af158984e80c38a4728d2e5b6a0ae6af7"><td class="memItemLeft" align="right" valign="top"><a id="af158984e80c38a4728d2e5b6a0ae6af7"></a>
matrix of matrix of matrix of Exclusive axis that divides the first and second dimension of matrix default to&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;axis_b&quot;, &quot;Exclusive axis that divides the first and second dimension \f matrix B, default to 1&quot;) .Arg(&quot;trans_a&quot;</td></tr>
<tr class="separator:af158984e80c38a4728d2e5b6a0ae6af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452acecd416b0c04009c4590da881cd1"><td class="memItemLeft" align="right" valign="top"><a id="a452acecd416b0c04009c4590da881cd1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (MatMul, <a class="el" href="classcaffe2_1_1GetMatMulGradient.html">GetMatMulGradient</a>)</td></tr>
<tr class="separator:a452acecd416b0c04009c4590da881cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ab02d720682a23fd6585d9b0ac6194"><td class="memItemLeft" align="right" valign="top"><a id="ad3ab02d720682a23fd6585d9b0ac6194"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (MatMul, <a class="el" href="classcaffe2_1_1MatMulOp.html">MatMulOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ad3ab02d720682a23fd6585d9b0ac6194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b700ff5275b79e6ee47b1c9d533e1b"><td class="memItemLeft" align="right" valign="top"><a id="a42b700ff5275b79e6ee47b1c9d533e1b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MaxGradient, <a class="el" href="classcaffe2_1_1MaxGradientOp.html">MaxGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a42b700ff5275b79e6ee47b1c9d533e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a3d39eed02e48d9f7f4be7f6b0771e"><td class="memItemLeft" align="right" valign="top"><a id="a55a3d39eed02e48d9f7f4be7f6b0771e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MinGradient, <a class="el" href="classcaffe2_1_1MinGradientOp.html">MinGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a55a3d39eed02e48d9f7f4be7f6b0771e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1f67d0b6b7956e78665e29187905aa"><td class="memItemLeft" align="right" valign="top"><a id="a0c1f67d0b6b7956e78665e29187905aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (MaxGradient).NumInputs(3</td></tr>
<tr class="separator:a0c1f67d0b6b7956e78665e29187905aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a43f44a3cd087418865a013a312ee7"><td class="memItemLeft" align="right" valign="top"><a id="a15a43f44a3cd087418865a013a312ee7"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>NumOutputs</b> (1, INT_MAX)</td></tr>
<tr class="separator:a15a43f44a3cd087418865a013a312ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f31a858fc0d60a2b0d78c52d121ff5"><td class="memItemLeft" align="right" valign="top"><a id="a74f31a858fc0d60a2b0d78c52d121ff5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (MinGradient).NumInputs(3</td></tr>
<tr class="separator:a74f31a858fc0d60a2b0d78c52d121ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c226db9d74ed03cb6b85db10f4519c4"><td class="memItemLeft" align="right" valign="top"><a id="a9c226db9d74ed03cb6b85db10f4519c4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Max, <a class="el" href="classcaffe2_1_1GetMaxGradient.html">GetMaxGradient</a>)</td></tr>
<tr class="separator:a9c226db9d74ed03cb6b85db10f4519c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d532ada2a3b864a2b6183c87f507861"><td class="memItemLeft" align="right" valign="top"><a id="a7d532ada2a3b864a2b6183c87f507861"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Min, <a class="el" href="classcaffe2_1_1GetMinGradient.html">GetMinGradient</a>)</td></tr>
<tr class="separator:a7d532ada2a3b864a2b6183c87f507861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc233420d643a3a47c38bea14d6f90a"><td class="memItemLeft" align="right" valign="top"><a id="aebc233420d643a3a47c38bea14d6f90a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Max, <a class="el" href="classcaffe2_1_1MaxOp.html">MaxOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aebc233420d643a3a47c38bea14d6f90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc565a8b3aff1ff2ea7e134c2a744f8a"><td class="memItemLeft" align="right" valign="top"><a id="acc565a8b3aff1ff2ea7e134c2a744f8a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Min, <a class="el" href="classcaffe2_1_1MinOp.html">MinOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:acc565a8b3aff1ff2ea7e134c2a744f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2d7a212453ba8d8438deb975ba0bb5"><td class="memItemLeft" align="right" valign="top"><a id="a6d2d7a212453ba8d8438deb975ba0bb5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
  Element-wise max of each of the input tensors. The first input tensor can be
  used in-place as the output tensor, in which case the max will be done in
  place and results will be accumulated in input0. All inputs and outputs must
  have the same shape and data type.
  )DOC&quot;) .Input(0</td></tr>
<tr class="separator:a6d2d7a212453ba8d8438deb975ba0bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c3da89a99ac3ca5c29cce585e4f526"><td class="memItemLeft" align="right" valign="top"><a id="aa7c3da89a99ac3ca5c29cce585e4f526"></a>
First of the input tensors Can be inplace&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;max&quot;, &quot;Output tensor. Same dimension as inputs.&quot;)</td></tr>
<tr class="separator:aa7c3da89a99ac3ca5c29cce585e4f526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6dbe8c111db0505bd25941b91ccba88"><td class="memItemLeft" align="right" valign="top"><a id="af6dbe8c111db0505bd25941b91ccba88"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Element-wise min of each of the input tensors. The first input tensor can be
used in-place as the output tensor, in which case the min will be done in
place and results will be accumulated in input0. All inputs and outputs must
have the same shape and data type.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:af6dbe8c111db0505bd25941b91ccba88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3867b07ceda06238210479cc0f0172bb"><td class="memItemLeft" align="right" valign="top"><a id="a3867b07ceda06238210479cc0f0172bb"></a>
First of the input tensors Can be inplace&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;min&quot;, &quot;Output tensor. Same dimension as inputs.&quot;)</td></tr>
<tr class="separator:a3867b07ceda06238210479cc0f0172bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73741e5100acaea710d5a2f66a282df"><td class="memItemLeft" align="right" valign="top"><a id="ae73741e5100acaea710d5a2f66a282df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MultiClassAccuracy, <a class="el" href="classcaffe2_1_1MultiClassAccuracyOp.html">MultiClassAccuracyOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae73741e5100acaea710d5a2f66a282df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20eedd9ce2782614ac7980ca8221e4a3"><td class="memItemLeft" align="right" valign="top"><a id="a20eedd9ce2782614ac7980ca8221e4a3"></a>
D float&#160;</td><td class="memItemRight" valign="bottom"><b>tensor</b> (N, D,) of predicted scores of each class for &quot; &quot;each data. N is the number of instances</td></tr>
<tr class="separator:a20eedd9ce2782614ac7980ca8221e4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90445af1653e4167be37059ba197a9c7"><td class="memItemLeft" align="right" valign="top"><a id="a90445af1653e4167be37059ba197a9c7"></a>
D float i batch size D is number of possible classes labels&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;labels&quot;, &quot;1-D int tensor (N,) of labels for each instance.&quot;) .Output(0</td></tr>
<tr class="separator:a90445af1653e4167be37059ba197a9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94a6d9d06487b2ec126771f6dc774f6"><td class="memItemLeft" align="right" valign="top"><a id="ad94a6d9d06487b2ec126771f6dc774f6"></a>
D float i batch size D is number of possible classes labels D float&#160;</td><td class="memItemRight" valign="bottom"><b>tensor</b> (D,) of accuracy for each class. If a class has no &quot; &quot;instance in the batch</td></tr>
<tr class="separator:ad94a6d9d06487b2ec126771f6dc774f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1d4def1175b27f59ec6dfb00534b57"><td class="memItemLeft" align="right" valign="top"><a id="a5d1d4def1175b27f59ec6dfb00534b57"></a>
D float i batch size D is number of possible classes labels D float its accuracy score is set to zero&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1, &quot;amounts&quot;, &quot;1-D int tensor (D,) of number of instances for each class in the batch.&quot;)</td></tr>
<tr class="separator:a5d1d4def1175b27f59ec6dfb00534b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc2bd7525f78337eed917c64c744995"><td class="memItemLeft" align="right" valign="top"><a id="a9fc2bd7525f78337eed917c64c744995"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (MultiClassAccuracy)</td></tr>
<tr class="separator:a9fc2bd7525f78337eed917c64c744995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a74d9ce08d54b01200e60d08738f416"><td class="memItemLeft" align="right" valign="top"><a id="a7a74d9ce08d54b01200e60d08738f416"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (NegateGradient, <a class="el" href="classcaffe2_1_1NegateGradientOp.html">NegateGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7a74d9ce08d54b01200e60d08738f416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9cb19a98c4c4ddf0c80642ab606caae"><td class="memItemLeft" align="right" valign="top"><a id="aa9cb19a98c4c4ddf0c80642ab606caae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
    NegagteGradient operator in forward pass simply copies input to the
    output, and in backward pass, flips the sign of the output gradient
  )DOC&quot;)</td></tr>
<tr class="separator:aa9cb19a98c4c4ddf0c80642ab606caae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308242536221240cfb3c23408915176e"><td class="memItemLeft" align="right" valign="top"><a id="a308242536221240cfb3c23408915176e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (NegateGradient, <a class="el" href="structcaffe2_1_1GetNegateGradientGradient.html">GetNegateGradientGradient</a>)</td></tr>
<tr class="separator:a308242536221240cfb3c23408915176e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa6c52a69d194a2098b41acb41f67a33"><td class="memItemLeft" align="right" valign="top"><a id="aaa6c52a69d194a2098b41acb41f67a33"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Negative, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float, double, int, long &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1NegativeCPUFunctor.html">NegativeCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:aaa6c52a69d194a2098b41acb41f67a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a6244ee25b015c3c62b5acc0b0bda6"><td class="memItemLeft" align="right" valign="top"><a id="a88a6244ee25b015c3c62b5acc0b0bda6"></a>
input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;Y&quot;, &quot;1D input tensor&quot;)</td></tr>
<tr class="separator:a88a6244ee25b015c3c62b5acc0b0bda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac173195453631efd6a218de8a6bb416a"><td class="memItemLeft" align="right" valign="top"><a id="ac173195453631efd6a218de8a6bb416a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Negative, <a class="el" href="classcaffe2_1_1GetNegativeGradient.html">GetNegativeGradient</a>)</td></tr>
<tr class="separator:ac173195453631efd6a218de8a6bb416a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bda0e37849040ded81e611019e5b21"><td class="memItemLeft" align="right" valign="top"><a id="ac7bda0e37849040ded81e611019e5b21"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (NormalizeL1, <a class="el" href="classcaffe2_1_1NormalizeL1Op.html">NormalizeL1Op</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac7bda0e37849040ded81e611019e5b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3db549283cbd541a4ec93700fe2d316"><td class="memItemLeft" align="right" valign="top"><a id="ad3db549283cbd541a4ec93700fe2d316"></a>
axis to normalize&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
  Given a matrix, apply L1-normalization along the specified axis.
  )DOC&quot;)</td></tr>
<tr class="separator:ad3db549283cbd541a4ec93700fe2d316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd9d79e49c3a5064c3ee6f99033f3cf"><td class="memItemLeft" align="right" valign="top"><a id="a7bd9d79e49c3a5064c3ee6f99033f3cf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Normalize, <a class="el" href="classcaffe2_1_1NormalizeOp.html">NormalizeOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7bd9d79e49c3a5064c3ee6f99033f3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d37bb36e98390392ff51588de0342e"><td class="memItemLeft" align="right" valign="top"><a id="a56d37bb36e98390392ff51588de0342e"></a>
axis to normalize&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given a matrix, apply L2-normalization along the specified dimension.
)DOC&quot;) .IdenticalTypeAndShape()</td></tr>
<tr class="separator:a56d37bb36e98390392ff51588de0342e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552fc0720d25da3121d3bfbda2c398dd"><td class="memItemLeft" align="right" valign="top"><a id="a552fc0720d25da3121d3bfbda2c398dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (NormalizeGradient, <a class="el" href="classcaffe2_1_1NormalizeGradientOp.html">NormalizeGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a552fc0720d25da3121d3bfbda2c398dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadc0f1046ef0f5ef46728f3fe5d5621"><td class="memItemLeft" align="right" valign="top"><a id="aeadc0f1046ef0f5ef46728f3fe5d5621"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Normalize, <a class="el" href="classcaffe2_1_1GetNormalizeGradient.html">GetNormalizeGradient</a>)</td></tr>
<tr class="separator:aeadc0f1046ef0f5ef46728f3fe5d5621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e0c977e2e446394bd48ca32da569f8"><td class="memItemLeft" align="right" valign="top"><a id="aa6e0c977e2e446394bd48ca32da569f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BatchBucketOneHot, <a class="el" href="classcaffe2_1_1BatchBucketOneHotOp.html">BatchBucketOneHotOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa6e0c977e2e446394bd48ca32da569f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5581ceb6d55bc4b925d4a76f6abed791"><td class="memItemLeft" align="right" valign="top"><a id="a5581ceb6d55bc4b925d4a76f6abed791"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BatchOneHot, <a class="el" href="classcaffe2_1_1BatchOneHotOp.html">BatchOneHotOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a5581ceb6d55bc4b925d4a76f6abed791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b518ed406ae2a637c91866b35b949a"><td class="memItemLeft" align="right" valign="top"><a id="af2b518ed406ae2a637c91866b35b949a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (OneHot, <a class="el" href="classcaffe2_1_1OneHotOp.html">OneHotOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af2b518ed406ae2a637c91866b35b949a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87576f4d67a3c7ce8a0c13a06a869231"><td class="memItemLeft" align="right" valign="top"><a id="a87576f4d67a3c7ce8a0c13a06a869231"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SegmentOneHot, <a class="el" href="classcaffe2_1_1SegmentOneHotOp.html">SegmentOneHotOp</a>)</td></tr>
<tr class="separator:a87576f4d67a3c7ce8a0c13a06a869231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92947fc7103428f88eb5f1462c6c1c88"><td class="memItemLeft" align="right" valign="top"><a id="a92947fc7103428f88eb5f1462c6c1c88"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (NHWC2NCHW, <a class="el" href="classcaffe2_1_1NHWC2NCHWOp.html">NHWC2NCHWOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a92947fc7103428f88eb5f1462c6c1c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b43075b2d68e8b1b43712e35b9e6ac"><td class="memItemLeft" align="right" valign="top"><a id="a08b43075b2d68e8b1b43712e35b9e6ac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (NCHW2NHWC, <a class="el" href="classcaffe2_1_1NCHW2NHWCOp.html">NCHW2NHWCOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a08b43075b2d68e8b1b43712e35b9e6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5bb29a6a84d03b75bd36da6a80e38f0"><td class="memItemLeft" align="right" valign="top"><a id="ac5bb29a6a84d03b75bd36da6a80e38f0"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (in[0].dims(3))</td></tr>
<tr class="separator:ac5bb29a6a84d03b75bd36da6a80e38f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3906a56bf1823905ea60c8a63bda92ca"><td class="memItemLeft" align="right" valign="top"><a id="a3906a56bf1823905ea60c8a63bda92ca"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (in[0].dims(1))</td></tr>
<tr class="separator:a3906a56bf1823905ea60c8a63bda92ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eeaa79a67fecbd0ad33c2d03e1a5fd0"><td class="memItemLeft" align="right" valign="top"><a id="a6eeaa79a67fecbd0ad33c2d03e1a5fd0"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (in[0].dims(2))</td></tr>
<tr class="separator:a6eeaa79a67fecbd0ad33c2d03e1a5fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57288856def65d05c8ceb461a982e98e"><td class="memItemLeft" align="right" valign="top"><a id="a57288856def65d05c8ceb461a982e98e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
The operator switches the order of data in a tensor from NHWC- sample index N,
height H, width H and channels C, to the NCHW order.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:a57288856def65d05c8ceb461a982e98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efe0bd0d6040a6dd2b132aef027620e"><td class="memItemLeft" align="right" valign="top"><a id="a2efe0bd0d6040a6dd2b132aef027620e"></a>
The input&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> (<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; float &gt;) in the NHWC order.&quot;) .Output( 0</td></tr>
<tr class="separator:a2efe0bd0d6040a6dd2b132aef027620e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3256eb7c57617589fd013881ad709f4"><td class="memItemLeft" align="right" valign="top"><a id="ab3256eb7c57617589fd013881ad709f4"></a>
The input The output&#160;</td><td class="memItemRight" valign="bottom"><b>tensor</b> (<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; float &gt;) in the NCHW order.&quot;)</td></tr>
<tr class="separator:ab3256eb7c57617589fd013881ad709f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3fce8999c57682cb8b224b00d2f555"><td class="memItemLeft" align="right" valign="top"><a id="a2c3fce8999c57682cb8b224b00d2f555"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (NCHW2NHWC).NumInputs(1).NumOutputs(1) .SetDoc(R&quot;DOC( The operator switches the order of data in a tensor from NCHW- sample index N</td></tr>
<tr class="separator:a2c3fce8999c57682cb8b224b00d2f555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a308c9b286618b97491fd19ebd08d28c3"><td class="memItemLeft" align="right" valign="top"><a id="a308c9b286618b97491fd19ebd08d28c3"></a>
channels height H and width to the NHWC order DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;data&quot;, &quot;The input data (<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt;float&gt;) in the NCHW order.&quot;) .Output(0</td></tr>
<tr class="separator:a308c9b286618b97491fd19ebd08d28c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46ec495208cca7f46a3a7cf2fe65c74"><td class="memItemLeft" align="right" valign="top"><a id="aa46ec495208cca7f46a3a7cf2fe65c74"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (NHWC2NCHW, <a class="el" href="classcaffe2_1_1GetNHWC2NCHWGradient.html">GetNHWC2NCHWGradient</a>)</td></tr>
<tr class="separator:aa46ec495208cca7f46a3a7cf2fe65c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6473f8847c5a73688ae867f99668fb04"><td class="memItemLeft" align="right" valign="top"><a id="a6473f8847c5a73688ae867f99668fb04"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (NCHW2NHWC, <a class="el" href="classcaffe2_1_1GetNCHW2NHWCGradient.html">GetNCHW2NHWCGradient</a>)</td></tr>
<tr class="separator:a6473f8847c5a73688ae867f99668fb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f6874cc7bae3a02ea9fe8496b0d840"><td class="memItemLeft" align="right" valign="top"><a id="a76f6874cc7bae3a02ea9fe8496b0d840"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (PackSegments, <a class="el" href="classcaffe2_1_1PackSegmentsOp.html">PackSegmentsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a76f6874cc7bae3a02ea9fe8496b0d840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af875c2b05a6e7c2c3a5f81b8efe3178f"><td class="memItemLeft" align="right" valign="top"><a id="af875c2b05a6e7c2c3a5f81b8efe3178f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (UnpackSegments, <a class="el" href="classcaffe2_1_1UnpackSegmentsOp.html">UnpackSegmentsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af875c2b05a6e7c2c3a5f81b8efe3178f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c43031d6f7210a26a3dacf053b1e27"><td class="memItemLeft" align="right" valign="top"><a id="ab8c43031d6f7210a26a3dacf053b1e27"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (&quot;Map N dim tensor to N+1 dim based on length blob. Sequences that \   are shorter than the longest sequence are padded with zeros.&quot;) .Input(0</td></tr>
<tr class="separator:ab8c43031d6f7210a26a3dacf053b1e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dd2296780ea6d591b588bed022cd14"><td class="memItemLeft" align="right" valign="top"><a id="a82dd2296780ea6d591b588bed022cd14"></a>
d int long tensor contains the length in each of the output&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;tensor&quot;, &quot;N dim Tensor.&quot;) .Output(0</td></tr>
<tr class="separator:a82dd2296780ea6d591b588bed022cd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfc46a1c3f583346191918e4e2292a1"><td class="memItemLeft" align="right" valign="top"><a id="a9bfc46a1c3f583346191918e4e2292a1"></a>
d int long tensor contains the length in each of the output N dim <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> where&#160;</td><td class="memItemRight" valign="bottom"><b>dim</b> (1) is the max length&quot; &quot;</td></tr>
<tr class="separator:a9bfc46a1c3f583346191918e4e2292a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0090655e96781383f208c797375a048f"><td class="memItemLeft" align="right" valign="top"><a id="a0090655e96781383f208c797375a048f"></a>
d int long tensor contains the length in each of the output N dim <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> where&#160;</td><td class="memItemRight" valign="bottom"><b>dim</b> (0) is the batch size.&quot;) .Output( 1</td></tr>
<tr class="separator:a0090655e96781383f208c797375a048f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe909ead8ba947d9f0fa78a6953b9223"><td class="memItemLeft" align="right" valign="top"><a id="afe909ead8ba947d9f0fa78a6953b9223"></a>
d int long tensor contains the length in each of the output N dim <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> where dim boolean false where packed_tensor is true otherwise&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;pad_minf&quot;, &quot;Padding number in the packed segments. Use true to pad \   -infinity, otherwise pad zeros&quot;) .Arg(&quot;return_presence_mask&quot;</td></tr>
<tr class="separator:afe909ead8ba947d9f0fa78a6953b9223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5243b4510c75aacd0ae1669384506c"><td class="memItemLeft" align="right" valign="top"><a id="a9f5243b4510c75aacd0ae1669384506c"></a>
d int long tensor contains the length in each of the input&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;tensor&quot;, &quot;N+1 dim Tensor.&quot;) .Output(0</td></tr>
<tr class="separator:a9f5243b4510c75aacd0ae1669384506c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdfabeddd0d829f0988af5af2da65c9"><td class="memItemLeft" align="right" valign="top"><a id="a9cdfabeddd0d829f0988af5af2da65c9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (PackSegments, <a class="el" href="classcaffe2_1_1GetPackSegmentsGradient.html">GetPackSegmentsGradient</a>)</td></tr>
<tr class="separator:a9cdfabeddd0d829f0988af5af2da65c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb4b8eaf7a8b51e5332b0dc8ceadaff"><td class="memItemLeft" align="right" valign="top"><a id="aceb4b8eaf7a8b51e5332b0dc8ceadaff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (UnpackSegments, <a class="el" href="classcaffe2_1_1GetUnpackSegmentsGradient.html">GetUnpackSegmentsGradient</a>)</td></tr>
<tr class="separator:aceb4b8eaf7a8b51e5332b0dc8ceadaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2af09f03e9d2413d9e2c860a3da048c"><td class="memItemLeft" align="right" valign="top"><a id="ad2af09f03e9d2413d9e2c860a3da048c"></a>
PadMode&#160;</td><td class="memItemRight" valign="bottom"><b>StringToPadMode</b> (const string &amp;mode)</td></tr>
<tr class="separator:ad2af09f03e9d2413d9e2c860a3da048c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15517e7b5a1a5ebd97ed7196fb69f94f"><td class="memItemLeft" align="right" valign="top"><a id="a15517e7b5a1a5ebd97ed7196fb69f94f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (PadImage, <a class="el" href="classcaffe2_1_1PadImageOp.html">PadImageOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a15517e7b5a1a5ebd97ed7196fb69f94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98fa75125dd0cc980d653687d4e17af"><td class="memItemLeft" align="right" valign="top"><a id="ab98fa75125dd0cc980d653687d4e17af"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (PadImageGradient, <a class="el" href="classcaffe2_1_1PadImageGradientOp.html">PadImageGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab98fa75125dd0cc980d653687d4e17af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415661bff9d1451a69c42e4ce8de413a"><td class="memItemLeft" align="right" valign="top"><a id="a415661bff9d1451a69c42e4ce8de413a"></a>
<a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> ::PadTensorInference&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
PadImage pads values around the boundary of an image according to the pad
values and stride sizes defined by the <a class="el" href="classcaffe2_1_1ConvPoolOpBase.html">ConvPoolOpBase</a> operator.
  )DOC&quot;) .Input(0</td></tr>
<tr class="separator:a415661bff9d1451a69c42e4ce8de413a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f84b5447012247667b8f1414bee805"><td class="memItemLeft" align="right" valign="top"><a id="a04f84b5447012247667b8f1414bee805"></a>
dimensions depend on whether the NCHW or NHWC operators are being used For in the the input has&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (N x C x H x W)</td></tr>
<tr class="separator:a04f84b5447012247667b8f1414bee805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230c174d9ebff6e0dc2e12d800e64648"><td class="memItemLeft" align="right" valign="top"><a id="a230c174d9ebff6e0dc2e12d800e64648"></a>
dimensions depend on whether the NCHW or NHWC operators are being used For in the the input has where N is the batch C is the number of and H and W are the height and the width of the data The corresponding permutation of dimensions is used in the latter case&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;Y&quot;, &quot;Output data tensor from padding the H and W dimensions on &quot; &quot;the tensor. Dimensions will vary based on various pad and stride &quot; &quot;sizes.&quot;)</td></tr>
<tr class="separator:a230c174d9ebff6e0dc2e12d800e64648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4bbdc47bd15e76f7a6d1b0c84c6dfc"><td class="memItemLeft" align="right" valign="top"><a id="aaa4bbdc47bd15e76f7a6d1b0c84c6dfc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (PadImageGradient).NumInputs(1).NumOutputs(1)</td></tr>
<tr class="separator:aaa4bbdc47bd15e76f7a6d1b0c84c6dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabfd45bcf5afac18be7162dfa9d0ac3"><td class="memItemLeft" align="right" valign="top"><a id="afabfd45bcf5afac18be7162dfa9d0ac3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (PadImage, <a class="el" href="classcaffe2_1_1GetPadImageGradient.html">GetPadImageGradient</a>)</td></tr>
<tr class="separator:afabfd45bcf5afac18be7162dfa9d0ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4cdcbfd982aeba7cdf0893b2f1f5a1"><td class="memItemLeft" align="right" valign="top"><a id="a3b4cdcbfd982aeba7cdf0893b2f1f5a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Perplexity, <a class="el" href="classcaffe2_1_1PerplexityOp.html">PerplexityOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3b4cdcbfd982aeba7cdf0893b2f1f5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbf2553d788e4248a02ab583d9c495c"><td class="memItemLeft" align="right" valign="top"><a id="a6fbf2553d788e4248a02ab583d9c495c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (Perplexity).NumInputs(1).NumOutputs(1) .SetDoc(R&quot;DOC( Perplexity calculates how well a probability distribution predicts a sample. Perplexity takes a 1-D tensor containing a batch of probabilities. Each value in the tensor belongs to a different sample and represents the probability of the model predicting the true label for that sample. The operator returns a single (float) perplexity value for the batch. )DOC&quot;) .Input(0</td></tr>
<tr class="separator:a6fbf2553d788e4248a02ab583d9c495c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9838da92c57dcc270051c5b3a243e407"><td class="memItemLeft" align="right" valign="top"><a id="a9838da92c57dcc270051c5b3a243e407"></a>
The input data as <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> It contains a batch of true label or target probabilities&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;output&quot;, &quot;The output- a single (float) perplexity value for the &quot; &quot;batch&quot;)</td></tr>
<tr class="separator:a9838da92c57dcc270051c5b3a243e407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d654419d43877e9d2478f97c220819"><td class="memItemLeft" align="right" valign="top"><a id="a63d654419d43877e9d2478f97c220819"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Perplexity)</td></tr>
<tr class="separator:a63d654419d43877e9d2478f97c220819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc450c1226f6ce99e5e46134b2442379"><td class="memItemLeft" align="right" valign="top"><a id="adc450c1226f6ce99e5e46134b2442379"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (PiecewiseLinearTransform, <a class="el" href="classcaffe2_1_1PiecewiseLinearTransformOp.html">PiecewiseLinearTransformOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:adc450c1226f6ce99e5e46134b2442379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bce1d30c9700da6bd6d4ad9ec8c3db"><td class="memItemLeft" align="right" valign="top"><a id="a61bce1d30c9700da6bd6d4ad9ec8c3db"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (1, 4) .NumOutputs(1) .SetDoc(R&quot;DOC( PiecewiseLinearTransform takes inputs -- predictions</td></tr>
<tr class="separator:a61bce1d30c9700da6bd6d4ad9ec8c3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132380591116ed2ac218a3ad71a05f58"><td class="memItemLeft" align="right" valign="top"><a id="a132380591116ed2ac218a3ad71a05f58"></a>
a D or D slopes and intercepts The output tensor has the same shape of input predictions and contains the predictions transformed by the piecewise linear functions Each column of predictions has its own piecewise linear transformation functions Therefore the size of piecewise function parameters are pieces x except for binary predictions where only the positive prediction needs them Note that in each low bound is excluded while high bound is included Also the piecewise linear function must be continuous Notes If the input is binary&#160;</td><td class="memItemRight" valign="bottom"><b>predictions</b> (Nx2 or Nx1 tensor)</td></tr>
<tr class="separator:a132380591116ed2ac218a3ad71a05f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e22fb3100cad3feedff575a0e6685b3"><td class="memItemLeft" align="right" valign="top"><a id="a0e22fb3100cad3feedff575a0e6685b3"></a>
a D or D slopes and intercepts The output tensor has the same shape of input predictions and contains the predictions transformed by the piecewise linear functions Each column of predictions has its own piecewise linear transformation functions Therefore the size of piecewise function parameters are pieces x except for binary predictions where only the positive prediction needs them Note that in each low bound is excluded while high bound is included Also the piecewise linear function must be continuous Notes If the input is binary set the binary arg to true so that one group of piecewise linear functions is&#160;</td><td class="memItemRight" valign="bottom"><b>needed</b> (see details below). - The transform parameters(bounds</td></tr>
<tr class="separator:a0e22fb3100cad3feedff575a0e6685b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b4bd3e9deb78d4a15698b92d6e0601"><td class="memItemLeft" align="right" valign="top"><a id="af1b4bd3e9deb78d4a15698b92d6e0601"></a>
a D or D slopes and intercepts The output tensor has the same shape of input predictions and contains the predictions transformed by the piecewise linear functions Each column of predictions has its own piecewise linear transformation functions Therefore the size of piecewise function parameters are pieces x except for binary predictions where only the positive prediction needs them Note that in each low bound is excluded while high bound is included Also the piecewise linear function must be continuous Notes If the input is binary set the binary arg to true so that one group of piecewise linear functions is intercepts can be passed either through args or through input blobs If we have multiple groups of piecewise linear each group has the same number of pieces If a prediction is out of the it is capped to the smallest or largest bound DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;bounds&quot;, &quot;1-D vector of size (prediction_dimensions x (pieces+1)) contain the &quot; &quot;upper bounds of each piece of linear function. One special case is &quot; &quot;the first bound is the lower bound of whole piecewise function and we &quot; &quot;treat it the same as the left most functions. (bounds, slopes, &quot; &quot;intercepts) can be passed through either arg or input blobs.&quot;) .Arg(&quot;slopes&quot;</td></tr>
<tr class="separator:af1b4bd3e9deb78d4a15698b92d6e0601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6c3e03721517f64bb3ad9c70c23b06"><td class="memItemLeft" align="right" valign="top"><a id="aec6c3e03721517f64bb3ad9c70c23b06"></a>
a D or D slopes and intercepts The output tensor has the same shape of input predictions and contains the predictions transformed by the piecewise linear functions Each column of predictions has its own piecewise linear transformation functions Therefore the size of piecewise function parameters are pieces x except for binary predictions where only the positive prediction needs them Note that in each low bound is excluded while high bound is included Also the piecewise linear function must be continuous Notes If the input is binary set the binary arg to true so that one group of piecewise linear functions is intercepts can be passed either through args or through input blobs If we have multiple groups of piecewise linear each group has the same number of pieces If a prediction is out of the it is capped to the smallest or largest bound DOC D vector of&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (prediction_dimensions x pieces) containing the &quot; &quot;slopes of linear function&quot;) .Arg( &quot;intercepts&quot;</td></tr>
<tr class="separator:aec6c3e03721517f64bb3ad9c70c23b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a983138aaa83cd635063465388149d8"><td class="memItemLeft" align="right" valign="top"><a id="a3a983138aaa83cd635063465388149d8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AveragePoolGradient, <a class="el" href="classcaffe2_1_1PoolGradientOp.html">PoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, AveragePool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a3a983138aaa83cd635063465388149d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588e2194022fa086582f7482cf90be08"><td class="memItemLeft" align="right" valign="top"><a id="a588e2194022fa086582f7482cf90be08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (AveragePoolGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a588e2194022fa086582f7482cf90be08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7185b96dc45dc5dd140b5d64d2e408"><td class="memItemLeft" align="right" valign="top"><a id="a6c7185b96dc45dc5dd140b5d64d2e408"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AveragePool1DGradient, <a class="el" href="classcaffe2_1_1PoolGradientOp.html">PoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, AveragePool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a6c7185b96dc45dc5dd140b5d64d2e408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f77a2198a9ab1eb4502ef3d16c2f40"><td class="memItemLeft" align="right" valign="top"><a id="ae7f77a2198a9ab1eb4502ef3d16c2f40"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (AveragePool1DGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:ae7f77a2198a9ab1eb4502ef3d16c2f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f9334327b6fd9b880d6d1a2e1beee1"><td class="memItemLeft" align="right" valign="top"><a id="ab4f9334327b6fd9b880d6d1a2e1beee1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AveragePool2DGradient, <a class="el" href="classcaffe2_1_1PoolGradientOp.html">PoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, AveragePool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:ab4f9334327b6fd9b880d6d1a2e1beee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2168d639116e0d1649c1ef157cb2418f"><td class="memItemLeft" align="right" valign="top"><a id="a2168d639116e0d1649c1ef157cb2418f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (AveragePool2DGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a2168d639116e0d1649c1ef157cb2418f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbd55e370a5e4b40b6e7df890daed1b"><td class="memItemLeft" align="right" valign="top"><a id="a8dbd55e370a5e4b40b6e7df890daed1b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AveragePool3DGradient, <a class="el" href="classcaffe2_1_1PoolGradientOp.html">PoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, AveragePool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a8dbd55e370a5e4b40b6e7df890daed1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ea9ef7f8abe4a1e39be24269257ccb"><td class="memItemLeft" align="right" valign="top"><a id="ab0ea9ef7f8abe4a1e39be24269257ccb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (AveragePool3DGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:ab0ea9ef7f8abe4a1e39be24269257ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d7b769f27f271bba0d44ff38679992"><td class="memItemLeft" align="right" valign="top"><a id="af6d7b769f27f271bba0d44ff38679992"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MaxPoolGradient, <a class="el" href="classcaffe2_1_1PoolGradientOp.html">PoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, MaxPool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:af6d7b769f27f271bba0d44ff38679992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51c26b383feb3ebd03cf5e4e8ab379d"><td class="memItemLeft" align="right" valign="top"><a id="af51c26b383feb3ebd03cf5e4e8ab379d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (MaxPoolGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:af51c26b383feb3ebd03cf5e4e8ab379d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8032c63297df7b003b5a11eae1e967"><td class="memItemLeft" align="right" valign="top"><a id="a5a8032c63297df7b003b5a11eae1e967"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MaxPool1DGradient, <a class="el" href="classcaffe2_1_1PoolGradientOp.html">PoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, MaxPool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a5a8032c63297df7b003b5a11eae1e967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67bf8ecae4818d45fc794429c8e34b93"><td class="memItemLeft" align="right" valign="top"><a id="a67bf8ecae4818d45fc794429c8e34b93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (MaxPool1DGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a67bf8ecae4818d45fc794429c8e34b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188d2effb6608170f07c960555aca060"><td class="memItemLeft" align="right" valign="top"><a id="a188d2effb6608170f07c960555aca060"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MaxPool2DGradient, <a class="el" href="classcaffe2_1_1PoolGradientOp.html">PoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, MaxPool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a188d2effb6608170f07c960555aca060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdef69d939d16f9337ca4cf1f106bbb"><td class="memItemLeft" align="right" valign="top"><a id="a1bdef69d939d16f9337ca4cf1f106bbb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (MaxPool2DGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a1bdef69d939d16f9337ca4cf1f106bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dfc54e93574ce6b5e9a45911f18c85"><td class="memItemLeft" align="right" valign="top"><a id="a05dfc54e93574ce6b5e9a45911f18c85"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MaxPool3DGradient, <a class="el" href="classcaffe2_1_1PoolGradientOp.html">PoolGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, MaxPool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a05dfc54e93574ce6b5e9a45911f18c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93ac8a4382768cc2511c81344854d02"><td class="memItemLeft" align="right" valign="top"><a id="ae93ac8a4382768cc2511c81344854d02"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (MaxPool3DGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:ae93ac8a4382768cc2511c81344854d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4226d56a6213572c7988e55cd1f6de"><td class="memItemLeft" align="right" valign="top"><a id="adc4226d56a6213572c7988e55cd1f6de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (AveragePool, <a class="el" href="classcaffe2_1_1GetPoolGradient.html">GetPoolGradient</a>)</td></tr>
<tr class="separator:adc4226d56a6213572c7988e55cd1f6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97aae647d6c84627cc840be61fdf823b"><td class="memItemLeft" align="right" valign="top"><a id="a97aae647d6c84627cc840be61fdf823b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (AveragePool1D, <a class="el" href="classcaffe2_1_1GetPoolGradient.html">GetPoolGradient</a>)</td></tr>
<tr class="separator:a97aae647d6c84627cc840be61fdf823b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a554f3ca4d4714256f3c373af1e11f"><td class="memItemLeft" align="right" valign="top"><a id="af1a554f3ca4d4714256f3c373af1e11f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (AveragePool2D, <a class="el" href="classcaffe2_1_1GetPoolGradient.html">GetPoolGradient</a>)</td></tr>
<tr class="separator:af1a554f3ca4d4714256f3c373af1e11f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bb76fffa78fd438c0fe1af0e0176d6"><td class="memItemLeft" align="right" valign="top"><a id="ab5bb76fffa78fd438c0fe1af0e0176d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (AveragePool3D, <a class="el" href="classcaffe2_1_1GetPoolGradient.html">GetPoolGradient</a>)</td></tr>
<tr class="separator:ab5bb76fffa78fd438c0fe1af0e0176d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e163b376d2fb7de32f7da191e3ab229"><td class="memItemLeft" align="right" valign="top"><a id="a7e163b376d2fb7de32f7da191e3ab229"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (MaxPool, <a class="el" href="classcaffe2_1_1GetPoolGradient.html">GetPoolGradient</a>)</td></tr>
<tr class="separator:a7e163b376d2fb7de32f7da191e3ab229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fc4a60c9bf1d52880be12e2ecc2509"><td class="memItemLeft" align="right" valign="top"><a id="a17fc4a60c9bf1d52880be12e2ecc2509"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (MaxPool1D, <a class="el" href="classcaffe2_1_1GetPoolGradient.html">GetPoolGradient</a>)</td></tr>
<tr class="separator:a17fc4a60c9bf1d52880be12e2ecc2509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a1aaa9d4ff6886c2071b36f7b73841"><td class="memItemLeft" align="right" valign="top"><a id="ac0a1aaa9d4ff6886c2071b36f7b73841"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (MaxPool2D, <a class="el" href="classcaffe2_1_1GetPoolGradient.html">GetPoolGradient</a>)</td></tr>
<tr class="separator:ac0a1aaa9d4ff6886c2071b36f7b73841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10c955e7d5d7c2869698bdcc7e0a141"><td class="memItemLeft" align="right" valign="top"><a id="af10c955e7d5d7c2869698bdcc7e0a141"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (MaxPool3D, <a class="el" href="classcaffe2_1_1GetPoolGradient.html">GetPoolGradient</a>)</td></tr>
<tr class="separator:af10c955e7d5d7c2869698bdcc7e0a141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c465b386eeb12caabd612a2f3da9b81"><td class="memItemLeft" align="right" valign="top"><a id="a1c465b386eeb12caabd612a2f3da9b81"></a>
std::function&lt; void(<a class="el" href="classcaffe2_1_1OpSchema.html">OpSchema</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AveragePoolDocGenerator</b> (const char *dim)</td></tr>
<tr class="separator:a1c465b386eeb12caabd612a2f3da9b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5813eb9fe43aa4c9ba4d319da95805ef"><td class="memItemLeft" align="right" valign="top"><a id="a5813eb9fe43aa4c9ba4d319da95805ef"></a>
std::function&lt; void(<a class="el" href="classcaffe2_1_1OpSchema.html">OpSchema</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MaxPoolDocGenerator</b> (const char *dim)</td></tr>
<tr class="separator:a5813eb9fe43aa4c9ba4d319da95805ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d95c52309f93f7c03ebf623d536ab3"><td class="memItemLeft" align="right" valign="top"><a id="a74d95c52309f93f7c03ebf623d536ab3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AveragePool, <a class="el" href="classcaffe2_1_1PoolOp.html">PoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, AveragePool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a74d95c52309f93f7c03ebf623d536ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf295f707082e03bf3f3ec7e60c300c6"><td class="memItemLeft" align="right" valign="top"><a id="abf295f707082e03bf3f3ec7e60c300c6"></a>
NumInputs(1) .NumOutputs(1) .TensorInferenceFunction(<a class="el" href="classcaffe2_1_1ConvPoolOpBase.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AveragePool1D, <a class="el" href="classcaffe2_1_1PoolOp.html">PoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, AveragePool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:abf295f707082e03bf3f3ec7e60c300c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f82f8490a15449b06589d117667204"><td class="memItemLeft" align="right" valign="top"><a id="ae3f82f8490a15449b06589d117667204"></a>
NumInputs(1) .NumOutputs(1) .TensorInferenceFunction(<a class="el" href="classcaffe2_1_1ConvPoolOpBase.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AveragePool2D, <a class="el" href="classcaffe2_1_1PoolOp.html">PoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, AveragePool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:ae3f82f8490a15449b06589d117667204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840b031f6ed43efb3a89eb8b3acae011"><td class="memItemLeft" align="right" valign="top"><a id="a840b031f6ed43efb3a89eb8b3acae011"></a>
NumInputs(1) .NumOutputs(1) .TensorInferenceFunction(<a class="el" href="classcaffe2_1_1ConvPoolOpBase.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AveragePool3D, <a class="el" href="classcaffe2_1_1PoolOp.html">PoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, AveragePool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a840b031f6ed43efb3a89eb8b3acae011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0675b41cf8043e1eb4aeb3df482555"><td class="memItemLeft" align="right" valign="top"><a id="abf0675b41cf8043e1eb4aeb3df482555"></a>
NumInputs(1) .NumOutputs(1) .TensorInferenceFunction(<a class="el" href="classcaffe2_1_1ConvPoolOpBase.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MaxPool, <a class="el" href="classcaffe2_1_1PoolOp.html">PoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, MaxPool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:abf0675b41cf8043e1eb4aeb3df482555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3678b83690eb2b0586d64bdf90d51496"><td class="memItemLeft" align="right" valign="top"><a id="a3678b83690eb2b0586d64bdf90d51496"></a>
NumInputs(1) .NumOutputs(1) .TensorInferenceFunction(<a class="el" href="classcaffe2_1_1ConvPoolOpBase.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MaxPool1D, <a class="el" href="classcaffe2_1_1PoolOp.html">PoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, MaxPool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a3678b83690eb2b0586d64bdf90d51496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987fc729f84d0fa2cf1f18dd4e7e5c6f"><td class="memItemLeft" align="right" valign="top"><a id="a987fc729f84d0fa2cf1f18dd4e7e5c6f"></a>
NumInputs(1) .NumOutputs(1) .TensorInferenceFunction(<a class="el" href="classcaffe2_1_1ConvPoolOpBase.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MaxPool2D, <a class="el" href="classcaffe2_1_1PoolOp.html">PoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, MaxPool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a987fc729f84d0fa2cf1f18dd4e7e5c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9998dcc0fdc07b2afa293b1d8911f43c"><td class="memItemLeft" align="right" valign="top"><a id="a9998dcc0fdc07b2afa293b1d8911f43c"></a>
NumInputs(1) .NumOutputs(1) .TensorInferenceFunction(<a class="el" href="classcaffe2_1_1ConvPoolOpBase.html">ConvPoolOpBase</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MaxPool3D, <a class="el" href="classcaffe2_1_1PoolOp.html">PoolOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, MaxPool&lt; float &gt;&gt;)</td></tr>
<tr class="separator:a9998dcc0fdc07b2afa293b1d8911f43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae519015529c49ba9edba9b9afcf109a6"><td class="memItemLeft" align="right" valign="top"><a id="ae519015529c49ba9edba9b9afcf109a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (PRelu, <a class="el" href="classcaffe2_1_1PReluOp.html">PReluOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae519015529c49ba9edba9b9afcf109a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3599f81fae89f3efaa9155d9b764dd"><td class="memItemLeft" align="right" valign="top"><a id="a9c3599f81fae89f3efaa9155d9b764dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (PReluGradient, <a class="el" href="classcaffe2_1_1PReluGradientOp.html">PReluGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9c3599f81fae89f3efaa9155d9b764dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d1d9282174179e72e3b4618e19503a"><td class="memItemLeft" align="right" valign="top"><a id="a99d1d9282174179e72e3b4618e19503a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (PReluGradient).NumInputs(4).NumOutputs(2).SetDoc(R&quot;DOC( PReluGradient takes both Y and dY and uses this to update dX and dW according to the chain rule and derivatives of the rectified linear function. )DOC&quot;)</td></tr>
<tr class="separator:a99d1d9282174179e72e3b4618e19503a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086afa020de70cef3cba3e02c291d870"><td class="memItemLeft" align="right" valign="top"><a id="a086afa020de70cef3cba3e02c291d870"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (PRelu, <a class="el" href="classcaffe2_1_1GetPReluGradient.html">GetPReluGradient</a>)</td></tr>
<tr class="separator:a086afa020de70cef3cba3e02c291d870"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172cf6c8bb4ccdab15e468b80388fc38"><td class="memItemLeft" align="right" valign="top"><a id="a172cf6c8bb4ccdab15e468b80388fc38"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (PrependDim, <a class="el" href="classcaffe2_1_1PrependDimOp.html">PrependDimOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a172cf6c8bb4ccdab15e468b80388fc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7888791d15ee3ce8aa591ef922e8e05b"><td class="memItemLeft" align="right" valign="top"><a id="a7888791d15ee3ce8aa591ef922e8e05b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MergeDim, <a class="el" href="classcaffe2_1_1MergeDimOp.html">MergeDimOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7888791d15ee3ce8aa591ef922e8e05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230e03fb7e0b4cc3055eadbe6afec130"><td class="memItemLeft" align="right" valign="top"><a id="a230e03fb7e0b4cc3055eadbe6afec130"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Reshape the tensor by prepending a dimension of fixed size and dividing the
size of the next dimension by that amount.
)DOC&quot;) .Arg(&quot;dim_size&quot;</td></tr>
<tr class="separator:a230e03fb7e0b4cc3055eadbe6afec130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1441da4b785c24e4ae77da89ce0ea93b"><td class="memItemLeft" align="right" valign="top"><a id="a1441da4b785c24e4ae77da89ce0ea93b"></a>
Size of the dimension to prepend&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;data&quot;, &quot;An input tensor.&quot;) .Output(0</td></tr>
<tr class="separator:a1441da4b785c24e4ae77da89ce0ea93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad334634051d3accbfa3eeca2b41b9e74"><td class="memItemLeft" align="right" valign="top"><a id="ad334634051d3accbfa3eeca2b41b9e74"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Merge first two dimensions in a single dimension with size dim(0) * dim(1).
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:ad334634051d3accbfa3eeca2b41b9e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9450cde3672ffb5791f27879edff4e95"><td class="memItemLeft" align="right" valign="top"><a id="a9450cde3672ffb5791f27879edff4e95"></a>
An input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;reshaped&quot;, &quot;Reshaped tensor.&quot;)</td></tr>
<tr class="separator:a9450cde3672ffb5791f27879edff4e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36531a3054c60c1b16fc40150b08aae"><td class="memItemLeft" align="right" valign="top"><a id="ac36531a3054c60c1b16fc40150b08aae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (PrependDim, <a class="el" href="classcaffe2_1_1GetPrependDimGradient.html">GetPrependDimGradient</a>)</td></tr>
<tr class="separator:ac36531a3054c60c1b16fc40150b08aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3258a81ad064d50d0deda05b001a002"><td class="memItemLeft" align="right" valign="top"><a id="ad3258a81ad064d50d0deda05b001a002"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (PrependDim, <a class="el" href="classcaffe2_1_1PrependDimOp.html">PrependDimOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ad3258a81ad064d50d0deda05b001a002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc671ac6dd953c08ba8a1020b119753b"><td class="memItemLeft" align="right" valign="top"><a id="adc671ac6dd953c08ba8a1020b119753b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (MergeDim, <a class="el" href="classcaffe2_1_1MergeDimOp.html">MergeDimOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:adc671ac6dd953c08ba8a1020b119753b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f06fe45c8edaeaf575855649fe12d3"><td class="memItemLeft" align="right" valign="top"><a id="a58f06fe45c8edaeaf575855649fe12d3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (QuantDecode, <a class="el" href="classcaffe2_1_1QuantDecodeOp.html">QuantDecodeOp</a>&lt; QuantDecodeRunTy::RUN_ALWAYS &gt;)</td></tr>
<tr class="separator:a58f06fe45c8edaeaf575855649fe12d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487dd141d82f2fda0f17f52d1631c955"><td class="memItemLeft" align="right" valign="top"><a id="a487dd141d82f2fda0f17f52d1631c955"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (QuantDecodeGradient, <a class="el" href="classcaffe2_1_1QuantDecodeGradientOp.html">QuantDecodeGradientOp</a>)</td></tr>
<tr class="separator:a487dd141d82f2fda0f17f52d1631c955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f18da68fe856b465261495e1c3d156"><td class="memItemLeft" align="right" valign="top"><a id="ad9f18da68fe856b465261495e1c3d156"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RecurrentNetworkBlobFetcher, <a class="el" href="classcaffe2_1_1RecurrentNetworkBlobFetcherOp.html">RecurrentNetworkBlobFetcherOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad9f18da68fe856b465261495e1c3d156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326cda6db3863fe13e5bdd6599ac0f16"><td class="memItemLeft" align="right" valign="top"><a id="a326cda6db3863fe13e5bdd6599ac0f16"></a>
Prefix string to prepend extracted blobs&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;ScratchWorkspaceBlob&quot;, &quot;Name of scratch workspace blob returned by recurrent network.&quot;) .Output(0</td></tr>
<tr class="separator:a326cda6db3863fe13e5bdd6599ac0f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9839977af794578804bb99724f69db55"><td class="memItemLeft" align="right" valign="top"><a id="a9839977af794578804bb99724f69db55"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (RecurrentNetworkBlobFetcher)</td></tr>
<tr class="separator:a9839977af794578804bb99724f69db55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd07e42c9acb1494e637f6b6489d842b"><td class="memItemLeft" align="right" valign="top"><a id="afd07e42c9acb1494e637f6b6489d842b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (RecurrentNetworkBlobFetcher, <a class="el" href="classcaffe2_1_1RecurrentNetworkBlobFetcherOp.html">RecurrentNetworkBlobFetcherOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:afd07e42c9acb1494e637f6b6489d842b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af626e8bd4defd97004472e4618071467"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af626e8bd4defd97004472e4618071467"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1RecurrentNetworkExecutorBase.html">RecurrentNetworkExecutorBase</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#af626e8bd4defd97004472e4618071467">createRNNExecutor&lt; CPUContext &gt;</a> (const NetDef &amp;step_net_def, std::map&lt; string, string &gt; &amp;recurrent_input_map, std::string timestep_blob, <a class="el" href="classcaffe2_1_1ArgumentHelper.html">ArgumentHelper</a> rnn_args)</td></tr>
<tr class="memdesc:af626e8bd4defd97004472e4618071467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of RecurrentNetworkExecutor that uses thread pool for multithreaded execution of RNNs.  <a href="#af626e8bd4defd97004472e4618071467">More...</a><br /></td></tr>
<tr class="separator:af626e8bd4defd97004472e4618071467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41508631ed84d5827070d1d204621b45"><td class="memTemplParams" colspan="2"><a id="a41508631ed84d5827070d1d204621b45"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:a41508631ed84d5827070d1d204621b45"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1RecurrentNetworkExecutorBase.html">RecurrentNetworkExecutorBase</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createRNNExecutor</b> (const NetDef &amp;step_net_def, std::map&lt; string, string &gt; &amp;recurrent_input_map, std::string timestep_blob, <a class="el" href="classcaffe2_1_1ArgumentHelper.html">ArgumentHelper</a> rnn_args)</td></tr>
<tr class="separator:a41508631ed84d5827070d1d204621b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea3a6c453620aaf4bc05db9979b8f2b"><td class="memTemplParams" colspan="2"><a id="a5ea3a6c453620aaf4bc05db9979b8f2b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5ea3a6c453620aaf4bc05db9979b8f2b"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1RecurrentNetworkExecutorBase.html">RecurrentNetworkExecutorBase</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>createRNNExecutor&lt; CUDAContext &gt;</b> (const NetDef &amp;step_net_def, std::map&lt; string, string &gt; &amp;recurrent_input_map, std::string timestep_blob, <a class="el" href="classcaffe2_1_1ArgumentHelper.html">ArgumentHelper</a> arg_helper)</td></tr>
<tr class="separator:a5ea3a6c453620aaf4bc05db9979b8f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2440d0d739a8ff7780ca788a0e9c6fd"><td class="memItemLeft" align="right" valign="top"><a id="ad2440d0d739a8ff7780ca788a0e9c6fd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="structcaffe2_1_1detail_1_1ScratchWorkspaces.html">detail::ScratchWorkspaces</a>)</td></tr>
<tr class="separator:ad2440d0d739a8ff7780ca788a0e9c6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4e5e322c97dfc904b690f67b3a7ed4"><td class="memItemLeft" align="right" valign="top"><a id="a1e4e5e322c97dfc904b690f67b3a7ed4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RecurrentNetwork, <a class="el" href="classcaffe2_1_1RecurrentNetworkOp.html">RecurrentNetworkOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1e4e5e322c97dfc904b690f67b3a7ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c8be74b3ef50fa44738d909a9cece6"><td class="memItemLeft" align="right" valign="top"><a id="a46c8be74b3ef50fa44738d909a9cece6"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(

Run the input network in a recurrent fashion. This can be used to
implement fairly general recurrent neural networks (RNNs).

The operator proceeds as follows.

- First, initialized the states from the input recurrent states
- For each timestep T, apply the links (that map offsets from input/output
  tensors into the inputs/outputs for the `step` network)
- Finally, alias the recurrent states to the specified output blobs.

This is a fairly special-case meta-operator, and so the implementation
is somewhat complex. It trades of generality (and frankly usability)
against performance and control (compared to e.g. TF
dynamic_rnn, Theano scan, etc).

See the usage examples for a flavor of how to use it.

)DOC&quot;)</td></tr>
<tr class="separator:a46c8be74b3ef50fa44738d909a9cece6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3072d167ef5ca0c7db265ef083e6a5a"><td class="memItemLeft" align="right" valign="top"><a id="af3072d167ef5ca0c7db265ef083e6a5a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RecurrentNetworkGradient, <a class="el" href="classcaffe2_1_1RecurrentNetworkGradientOp.html">RecurrentNetworkGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af3072d167ef5ca0c7db265ef083e6a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1ac23d3f7602f3d04576798ec8736b"><td class="memItemLeft" align="right" valign="top"><a id="a7b1ac23d3f7602f3d04576798ec8736b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (RecurrentNetworkGradient)</td></tr>
<tr class="separator:a7b1ac23d3f7602f3d04576798ec8736b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e7a17169132702eab06cd99f41083c"><td class="memItemLeft" align="right" valign="top"><a id="a60e7a17169132702eab06cd99f41083c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (rnn_internal_accumulate_gradient_input, <a class="el" href="classcaffe2_1_1AccumulateInputGradientOp.html">AccumulateInputGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a60e7a17169132702eab06cd99f41083c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6501ce4f95b2d1767e8687dc79eb3a"><td class="memItemLeft" align="right" valign="top"><a id="ade6501ce4f95b2d1767e8687dc79eb3a"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>EnforceInplace</b> ({{2, 0}}) .Private() .SetDoc(&quot;--internal--&quot;)</td></tr>
<tr class="separator:ade6501ce4f95b2d1767e8687dc79eb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3b03cb18e129bd217ab2a049529add"><td class="memItemLeft" align="right" valign="top"><a id="a5a3b03cb18e129bd217ab2a049529add"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (rnn_internal_apply_link, <a class="el" href="classcaffe2_1_1RNNApplyLinkOp.html">RNNApplyLinkOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a5a3b03cb18e129bd217ab2a049529add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb1acc558b3c490b22552b907ed6b11"><td class="memItemLeft" align="right" valign="top"><a id="a7fb1acc558b3c490b22552b907ed6b11"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Private</b> () .SetDoc(&quot;--internal--&quot;)</td></tr>
<tr class="separator:a7fb1acc558b3c490b22552b907ed6b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3ca4e0250dfc68055be3726ad3322b"><td class="memItemLeft" align="right" valign="top"><a id="a9f3ca4e0250dfc68055be3726ad3322b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (RecurrentNetwork, <a class="el" href="structcaffe2_1_1GetRecurrentNetworkGradient.html">GetRecurrentNetworkGradient</a>)</td></tr>
<tr class="separator:a9f3ca4e0250dfc68055be3726ad3322b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912783262e703e193dcd0a6961569055"><td class="memItemLeft" align="right" valign="top"><a id="a912783262e703e193dcd0a6961569055"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (Recurrent, <a class="el" href="classcaffe2_1_1RecurrentOp.html">RecurrentOp</a>&lt; float &gt;)</td></tr>
<tr class="separator:a912783262e703e193dcd0a6961569055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9009f0878a4ce0b5c4278150e3e1c639"><td class="memItemLeft" align="right" valign="top"><a id="a9009f0878a4ce0b5c4278150e3e1c639"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (Recurrent).NumInputs(4).NumOutputs(5).SetDoc(R&quot;DOC( Recurrent wraps the CuDNN R5 RNN implementation. See the CuDNN R5 documentation for more information. In general</td></tr>
<tr class="separator:a9009f0878a4ce0b5c4278150e3e1c639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad641a8ec93c63bf32de0f552aeec1c87"><td class="memItemLeft" align="right" valign="top"><a id="ad641a8ec93c63bf32de0f552aeec1c87"></a>
the implementation takes an&#160;</td><td class="memItemRight" valign="bottom"><b>input</b> (TxNxD) tensor</td></tr>
<tr class="separator:ad641a8ec93c63bf32de0f552aeec1c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49f4bd63db29f2344f61892e922a5f8"><td class="memItemLeft" align="right" valign="top"><a id="aa49f4bd63db29f2344f61892e922a5f8"></a>
the implementation takes an the hidden state&#160;</td><td class="memItemRight" valign="bottom"><b>input</b> (NxD)</td></tr>
<tr class="separator:aa49f4bd63db29f2344f61892e922a5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefe80b6c684e1a14afd7eeafc0a35317"><td class="memItemLeft" align="right" valign="top"><a id="aefe80b6c684e1a14afd7eeafc0a35317"></a>
the implementation takes an the hidden state the cell and a weight&#160;</td><td class="memItemRight" valign="bottom"><b>tensor</b> (effectively an opaque blob, where the size and layout is dictated by CuDNN). The outputs are the output(again</td></tr>
<tr class="separator:aefe80b6c684e1a14afd7eeafc0a35317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0938735bcbcf8193d727e2d4be1db3fc"><td class="memItemLeft" align="right" valign="top"><a id="a0938735bcbcf8193d727e2d4be1db3fc"></a>
the implementation takes an the hidden state the cell and a weight the final hidden cell&#160;</td><td class="memItemRight" valign="bottom"><b>states</b> (NxD). These can be reset(at sequence boundaries across minibatches) by multiplying by zero. The CuDNN arguments(hidden_size</td></tr>
<tr class="separator:a0938735bcbcf8193d727e2d4be1db3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43040ba9ca5c850af8a6bfae5ba33446"><td class="memItemLeft" align="right" valign="top"><a id="a43040ba9ca5c850af8a6bfae5ba33446"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (RecurrentGradient, <a class="el" href="classcaffe2_1_1RecurrentGradientOp.html">RecurrentGradientOp</a>&lt; float &gt;)</td></tr>
<tr class="separator:a43040ba9ca5c850af8a6bfae5ba33446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1083d7b7ad9956c9ee1873fd614a6ac"><td class="memItemLeft" align="right" valign="top"><a id="ab1083d7b7ad9956c9ee1873fd614a6ac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (7) .NumOutputs(6) .AllowInplace(</td></tr>
<tr class="separator:ab1083d7b7ad9956c9ee1873fd614a6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad63b4e71b179d2b7110046d646a4913b"><td class="memItemLeft" align="right" valign="top"><a id="ad63b4e71b179d2b7110046d646a4913b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (RecurrentParamSet, <a class="el" href="classcaffe2_1_1RecurrentParamAccessOp.html">RecurrentParamAccessOp</a>&lt; float, SET_PARAM &gt;)</td></tr>
<tr class="separator:ad63b4e71b179d2b7110046d646a4913b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e15a1098b58ad8b58e0eca3f950d65d"><td class="memItemLeft" align="right" valign="top"><a id="a1e15a1098b58ad8b58e0eca3f950d65d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (&quot;Set individual parameters of a recurrent net.&quot;) .Arg(&quot;param_type&quot;</td></tr>
<tr class="separator:a1e15a1098b58ad8b58e0eca3f950d65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4880ffa2f59f7eb432d0ff0d581e9508"><td class="memItemLeft" align="right" valign="top"><a id="a4880ffa2f59f7eb432d0ff0d581e9508"></a>
R&#160;</td><td class="memItemRight" valign="bottom"><b>DOC</b> (Type of param to be set:&quot;input_gate_w&quot;, &quot;forget_gate_w&quot;, &quot;cell_w&quot;, &quot;output_gate_w&quot; &quot;input_gate_b&quot;, &quot;forget_gate_b&quot;, &quot;cell_b&quot;, &quot;output_gate_b&quot;) DOC&quot;) .Arg(&quot;input_type&quot;</td></tr>
<tr class="separator:a4880ffa2f59f7eb432d0ff0d581e9508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b47857761d8aa361eb17766420d4d78"><td class="memItemLeft" align="right" valign="top"><a id="a2b47857761d8aa361eb17766420d4d78"></a>
R recurrent or input&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;layer&quot;, &quot;layer index (starting from 0)&quot;) .Input(0</td></tr>
<tr class="separator:a2b47857761d8aa361eb17766420d4d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6850ac15f6cb380fbd084fb21d79546e"><td class="memItemLeft" align="right" valign="top"><a id="a6850ac15f6cb380fbd084fb21d79546e"></a>
R recurrent or input R&#160;</td><td class="memItemRight" valign="bottom"><b>DOC</b> (Input blob. Needed for inferring the shapes. A dummy tensor matching the input shape is ok.) DOC&quot;) .Input(1</td></tr>
<tr class="separator:a6850ac15f6cb380fbd084fb21d79546e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0c0a16baadeb20f0edc2fa6cb82684"><td class="memItemLeft" align="right" valign="top"><a id="a3b0c0a16baadeb20f0edc2fa6cb82684"></a>
R recurrent or input R <a class="el" href="classcaffe2_1_1Blob.html">Blob</a> holding all the parameters&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (2, &quot;param&quot;, &quot;Values for the specified parameter&quot;) .Output(0</td></tr>
<tr class="separator:a3b0c0a16baadeb20f0edc2fa6cb82684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f749bf3fab03c4b1604a866d40a6202"><td class="memItemLeft" align="right" valign="top"><a id="a1f749bf3fab03c4b1604a866d40a6202"></a>
R recurrent or input R <a class="el" href="classcaffe2_1_1Blob.html">Blob</a> holding all the parameters <a class="el" href="classcaffe2_1_1Blob.html">Blob</a> holding all the&#160;</td><td class="memItemRight" valign="bottom"><b>parameters</b> (same as input(1))&quot;)</td></tr>
<tr class="separator:a1f749bf3fab03c4b1604a866d40a6202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd748f8781f46aa04974d549c5501b9"><td class="memItemLeft" align="right" valign="top"><a id="a0cd748f8781f46aa04974d549c5501b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (RecurrentParamGet, <a class="el" href="classcaffe2_1_1RecurrentParamAccessOp.html">RecurrentParamAccessOp</a>&lt; float, GET_PARAM &gt;)</td></tr>
<tr class="separator:a0cd748f8781f46aa04974d549c5501b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dede7402514f70f768773be96aaa6c0"><td class="memItemLeft" align="right" valign="top"><a id="a9dede7402514f70f768773be96aaa6c0"></a>
R recurrent or input R <a class="el" href="classcaffe2_1_1Blob.html">Blob</a> holding all the parameters&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;param&quot;, &quot;<a class="el" href="classcaffe2_1_1Blob.html">Blob</a> holding the requested values&quot;)</td></tr>
<tr class="separator:a9dede7402514f70f768773be96aaa6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620fcbf44947b5e8e7b6aa94843a479d"><td class="memItemLeft" align="right" valign="top"><a id="a620fcbf44947b5e8e7b6aa94843a479d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Recurrent, <a class="el" href="structcaffe2_1_1GetRecurrentGradient.html">GetRecurrentGradient</a>)</td></tr>
<tr class="separator:a620fcbf44947b5e8e7b6aa94843a479d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943b5dba8b06a474f736631f78ca3b77"><td class="memItemLeft" align="right" valign="top"><a id="a943b5dba8b06a474f736631f78ca3b77"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceFrontSum, <a class="el" href="classcaffe2_1_1SumReduceDimsOp.html">SumReduceDimsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, true, false &gt;)</td></tr>
<tr class="separator:a943b5dba8b06a474f736631f78ca3b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74cae50e8868524aa652487bdbddb34c"><td class="memItemLeft" align="right" valign="top"><a id="a74cae50e8868524aa652487bdbddb34c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceFrontSumGradient, <a class="el" href="classcaffe2_1_1SumReduceDimsGradientOp.html">SumReduceDimsGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, true, false &gt;)</td></tr>
<tr class="separator:a74cae50e8868524aa652487bdbddb34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa63b38160fa88432cf89e19d35d5158"><td class="memItemLeft" align="right" valign="top"><a id="afa63b38160fa88432cf89e19d35d5158"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ReduceFrontSum, <a class="el" href="classcaffe2_1_1GetReduceFrontSumGradient.html">GetReduceFrontSumGradient</a>)</td></tr>
<tr class="separator:afa63b38160fa88432cf89e19d35d5158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461180cd1ece4b4e934ab89cb67101ae"><td class="memItemLeft" align="right" valign="top"><a id="a461180cd1ece4b4e934ab89cb67101ae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceBackSum, <a class="el" href="classcaffe2_1_1SumReduceDimsOp.html">SumReduceDimsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, false, false &gt;)</td></tr>
<tr class="separator:a461180cd1ece4b4e934ab89cb67101ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf19504c08e225f1216d8efd39c1580"><td class="memItemLeft" align="right" valign="top"><a id="afcf19504c08e225f1216d8efd39c1580"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceBackSumGradient, <a class="el" href="classcaffe2_1_1SumReduceDimsGradientOp.html">SumReduceDimsGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, false, false &gt;)</td></tr>
<tr class="separator:afcf19504c08e225f1216d8efd39c1580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf18ca8ca4422f8813c2e004b56badf"><td class="memItemLeft" align="right" valign="top"><a id="acbf18ca8ca4422f8813c2e004b56badf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ReduceBackSum, <a class="el" href="classcaffe2_1_1GetReduceBackSumGradient.html">GetReduceBackSumGradient</a>)</td></tr>
<tr class="separator:acbf18ca8ca4422f8813c2e004b56badf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9709e33824d02f0cd8c7dded604a235a"><td class="memItemLeft" align="right" valign="top"><a id="a9709e33824d02f0cd8c7dded604a235a"></a>
Number of dimensions to reduce&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(&quot;Reduces the input tensor along the first dimension of the input tensor by applying 'Sum') DOC&quot;) .TensorInferenceFunction([]( const OperatorDef &amp; def</td></tr>
<tr class="separator:a9709e33824d02f0cd8c7dded604a235a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a58264bb40fc4b27c9aec7f9732e2d0"><td class="memItemLeft" align="right" valign="top"><a id="a8a58264bb40fc4b27c9aec7f9732e2d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ReduceFrontSumGradient).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a8a58264bb40fc4b27c9aec7f9732e2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0682f779551261a6c4d9e9fb67452a4"><td class="memItemLeft" align="right" valign="top"><a id="aa0682f779551261a6c4d9e9fb67452a4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ReduceBackSum) .NumInputs(1) .NumOutputs(1) .Arg(&quot;num_reduce_dims&quot;</td></tr>
<tr class="separator:aa0682f779551261a6c4d9e9fb67452a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f87d4b7dc00de2cbabd47e786ef550a"><td class="memItemLeft" align="right" valign="top"><a id="a8f87d4b7dc00de2cbabd47e786ef550a"></a>
Number of dimensions to reduce&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(&quot;Reduces the input tensor along the last dimension of the input tensor by applying 'Sum') DOC&quot;) .TensorInferenceFunction([]( const OperatorDef &amp; def</td></tr>
<tr class="separator:a8f87d4b7dc00de2cbabd47e786ef550a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eeabe746137ba44ac37c426cec413f1"><td class="memItemLeft" align="right" valign="top"><a id="a7eeabe746137ba44ac37c426cec413f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ReduceBackSumGradient).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a7eeabe746137ba44ac37c426cec413f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9583603fed1bf04f85e3e8f9bdcb77a"><td class="memItemLeft" align="right" valign="top"><a id="ac9583603fed1bf04f85e3e8f9bdcb77a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceFrontMean, <a class="el" href="classcaffe2_1_1SumReduceDimsOp.html">SumReduceDimsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, true, true &gt;)</td></tr>
<tr class="separator:ac9583603fed1bf04f85e3e8f9bdcb77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d75f2b4c4c21fa0931f7ccb3fc41e5"><td class="memItemLeft" align="right" valign="top"><a id="a39d75f2b4c4c21fa0931f7ccb3fc41e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceFrontMeanGradient, <a class="el" href="classcaffe2_1_1SumReduceDimsGradientOp.html">SumReduceDimsGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, true, true &gt;)</td></tr>
<tr class="separator:a39d75f2b4c4c21fa0931f7ccb3fc41e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe10cbb7b5f5e42e3c1e1497bdfe0f34"><td class="memItemLeft" align="right" valign="top"><a id="abe10cbb7b5f5e42e3c1e1497bdfe0f34"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ReduceFrontMean, <a class="el" href="classcaffe2_1_1GetReduceFrontMeanGradient.html">GetReduceFrontMeanGradient</a>)</td></tr>
<tr class="separator:abe10cbb7b5f5e42e3c1e1497bdfe0f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a271f045a8b106d66b885013f0db3f7b7"><td class="memItemLeft" align="right" valign="top"><a id="a271f045a8b106d66b885013f0db3f7b7"></a>
Number of dimensions to reduce&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(&quot;Reduces the input tensor along the first dimension of the input tensor by applying 'Mean') DOC&quot;) .TensorInferenceFunction([]( const OperatorDef &amp; def</td></tr>
<tr class="separator:a271f045a8b106d66b885013f0db3f7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf80f72400b359c840622a040f36d68"><td class="memItemLeft" align="right" valign="top"><a id="a8cf80f72400b359c840622a040f36d68"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ReduceFrontMeanGradient).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a8cf80f72400b359c840622a040f36d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac80a72437b9367a546c067b14280097"><td class="memItemLeft" align="right" valign="top"><a id="aac80a72437b9367a546c067b14280097"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceBackMean, <a class="el" href="classcaffe2_1_1SumReduceDimsOp.html">SumReduceDimsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, false, true &gt;)</td></tr>
<tr class="separator:aac80a72437b9367a546c067b14280097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451f526ab11c67af5b26d99074b3cd1d"><td class="memItemLeft" align="right" valign="top"><a id="a451f526ab11c67af5b26d99074b3cd1d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceBackMeanGradient, <a class="el" href="classcaffe2_1_1SumReduceDimsGradientOp.html">SumReduceDimsGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, false, true &gt;)</td></tr>
<tr class="separator:a451f526ab11c67af5b26d99074b3cd1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8114f3254d4db8752ebef20359b59ad4"><td class="memItemLeft" align="right" valign="top"><a id="a8114f3254d4db8752ebef20359b59ad4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ReduceBackMean, <a class="el" href="classcaffe2_1_1GetReduceBackMeanGradient.html">GetReduceBackMeanGradient</a>)</td></tr>
<tr class="separator:a8114f3254d4db8752ebef20359b59ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2e0d55f8f31b735f1e3459ab07e4f1"><td class="memItemLeft" align="right" valign="top"><a id="a8d2e0d55f8f31b735f1e3459ab07e4f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ReduceBackMean) .NumInputs(1) .NumOutputs(1) .Arg(&quot;num_reduce_dims&quot;</td></tr>
<tr class="separator:a8d2e0d55f8f31b735f1e3459ab07e4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645a24bd15fcadb7a8bef0af8231955f"><td class="memItemLeft" align="right" valign="top"><a id="a645a24bd15fcadb7a8bef0af8231955f"></a>
Number of dimensions to reduce&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(&quot;Reduces the input tensor along the last dimension of the input tensor by applying 'Mean') DOC&quot;) .TensorInferenceFunction([]( const OperatorDef &amp; def</td></tr>
<tr class="separator:a645a24bd15fcadb7a8bef0af8231955f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb70f9d66a3e7d7fb90db5f903d2982b"><td class="memItemLeft" align="right" valign="top"><a id="afb70f9d66a3e7d7fb90db5f903d2982b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ReduceBackMeanGradient).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:afb70f9d66a3e7d7fb90db5f903d2982b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed56e9829c1e22e77294b665ebbf64a"><td class="memItemLeft" align="right" valign="top"><a id="afed56e9829c1e22e77294b665ebbf64a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceFrontMax, <a class="el" href="classcaffe2_1_1MaxReduceDimsOp.html">MaxReduceDimsOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, true &gt;)</td></tr>
<tr class="separator:afed56e9829c1e22e77294b665ebbf64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6f0b1d121e5ac581fb97c4e4777883"><td class="memItemLeft" align="right" valign="top"><a id="abd6f0b1d121e5ac581fb97c4e4777883"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceFrontMaxGradient, <a class="el" href="classcaffe2_1_1MaxReduceDimsGradientOp.html">MaxReduceDimsGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, true &gt;)</td></tr>
<tr class="separator:abd6f0b1d121e5ac581fb97c4e4777883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b28b92857aaa543768789079152c90"><td class="memItemLeft" align="right" valign="top"><a id="ab9b28b92857aaa543768789079152c90"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceBackMax, <a class="el" href="classcaffe2_1_1MaxReduceDimsOp.html">MaxReduceDimsOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, false &gt;)</td></tr>
<tr class="separator:ab9b28b92857aaa543768789079152c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af911cd29d47410ecfef1b45357f510b7"><td class="memItemLeft" align="right" valign="top"><a id="af911cd29d47410ecfef1b45357f510b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReduceBackMaxGradient, <a class="el" href="classcaffe2_1_1MaxReduceDimsGradientOp.html">MaxReduceDimsGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, false &gt;)</td></tr>
<tr class="separator:af911cd29d47410ecfef1b45357f510b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04349cba64700b565d65eec0b9305255"><td class="memItemLeft" align="right" valign="top"><a id="a04349cba64700b565d65eec0b9305255"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ReduceFrontMax, <a class="el" href="classcaffe2_1_1GetReduceFrontMaxGradient.html">GetReduceFrontMaxGradient</a>)</td></tr>
<tr class="separator:a04349cba64700b565d65eec0b9305255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bf96ee5953a075f8a573fda63fc280"><td class="memItemLeft" align="right" valign="top"><a id="a92bf96ee5953a075f8a573fda63fc280"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ReduceBackMax, <a class="el" href="classcaffe2_1_1GetReduceBackMaxGradient.html">GetReduceBackMaxGradient</a>)</td></tr>
<tr class="separator:a92bf96ee5953a075f8a573fda63fc280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf18a7c10d655e3cb50a91f599c621c6"><td class="memItemLeft" align="right" valign="top"><a id="acf18a7c10d655e3cb50a91f599c621c6"></a>
Number of dimensions to reduce&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(&quot;Reduces the input tensor along the first dimension of the input tensor by applying 'Max') DOC&quot;) .TensorInferenceFunction([]( const OperatorDef &amp; def</td></tr>
<tr class="separator:acf18a7c10d655e3cb50a91f599c621c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca78a46214042913c52193473f088dc2"><td class="memItemLeft" align="right" valign="top"><a id="aca78a46214042913c52193473f088dc2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ReduceFrontMaxGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:aca78a46214042913c52193473f088dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad415bd87f22e8432cf9b3c5d1224a429"><td class="memItemLeft" align="right" valign="top"><a id="ad415bd87f22e8432cf9b3c5d1224a429"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ReduceBackMax) .NumInputs(1) .NumOutputs(1) .Arg(&quot;num_reduce_dims&quot;</td></tr>
<tr class="separator:ad415bd87f22e8432cf9b3c5d1224a429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d02d8f2e93c5c8bd31dedeabb854fc"><td class="memItemLeft" align="right" valign="top"><a id="a01d02d8f2e93c5c8bd31dedeabb854fc"></a>
Number of dimensions to reduce&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(&quot;Reduces the input tensor along the last dimension of the input tensor by applying 'Max') DOC&quot;) .TensorInferenceFunction([]( const OperatorDef &amp; def</td></tr>
<tr class="separator:a01d02d8f2e93c5c8bd31dedeabb854fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84b91040d8030b7c034ad88b5ce1fe1"><td class="memItemLeft" align="right" valign="top"><a id="af84b91040d8030b7c034ad88b5ce1fe1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ReduceBackMaxGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:af84b91040d8030b7c034ad88b5ce1fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2303e6bcba9a25f5d4e40f0e0d37e2"><td class="memItemLeft" align="right" valign="top"><a id="acd2303e6bcba9a25f5d4e40f0e0d37e2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SumElements, <a class="el" href="classcaffe2_1_1SumElementsOp.html">SumElementsOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:acd2303e6bcba9a25f5d4e40f0e0d37e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3017fdecf785e6677b54593cda09493f"><td class="memItemLeft" align="right" valign="top"><a id="a3017fdecf785e6677b54593cda09493f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SumSqrElements, <a class="el" href="classcaffe2_1_1SumSqrElementsOp.html">SumSqrElementsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3017fdecf785e6677b54593cda09493f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac770f9cadd4711ad89994d241513d0"><td class="memItemLeft" align="right" valign="top"><a id="afac770f9cadd4711ad89994d241513d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SumElementsGradient, <a class="el" href="classcaffe2_1_1SumElementsGradientOp.html">SumElementsGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:afac770f9cadd4711ad89994d241513d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a6f98d15795ab4e4cbf06dc49f43b1"><td class="memItemLeft" align="right" valign="top"><a id="ac0a6f98d15795ab4e4cbf06dc49f43b1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RowwiseMax, <a class="el" href="classcaffe2_1_1MaxReductionOp.html">MaxReductionOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, true &gt;)</td></tr>
<tr class="separator:ac0a6f98d15795ab4e4cbf06dc49f43b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee608cdef2e782d2f3e15b6113d3460"><td class="memItemLeft" align="right" valign="top"><a id="acee608cdef2e782d2f3e15b6113d3460"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RowwiseMaxGradient, <a class="el" href="classcaffe2_1_1MaxReductionGradientOp.html">MaxReductionGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, true &gt;)</td></tr>
<tr class="separator:acee608cdef2e782d2f3e15b6113d3460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4ced6c7fd61912a48b445cdca3eea4"><td class="memItemLeft" align="right" valign="top"><a id="a7f4ced6c7fd61912a48b445cdca3eea4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ColwiseMaxGradient, <a class="el" href="classcaffe2_1_1MaxReductionGradientOp.html">MaxReductionGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, false &gt;)</td></tr>
<tr class="separator:a7f4ced6c7fd61912a48b445cdca3eea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e56d0f06246205e192cf67e4eb53a0"><td class="memItemLeft" align="right" valign="top"><a id="aa9e56d0f06246205e192cf67e4eb53a0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ColwiseMax, <a class="el" href="classcaffe2_1_1MaxReductionOp.html">MaxReductionOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, false &gt;)</td></tr>
<tr class="separator:aa9e56d0f06246205e192cf67e4eb53a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100c95cce157d007143a4e4f1c58b155"><td class="memItemLeft" align="right" valign="top"><a id="a100c95cce157d007143a4e4f1c58b155"></a>
NumInputs(1) .NumOutputs(1) .ScalarType(TensorProto NumInputs(1) .NumOutputs(1) .ScalarType(TensorProto&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (SumElementsGradient).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a100c95cce157d007143a4e4f1c58b155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710e074e59057ba20c9305753de6fe1d"><td class="memItemLeft" align="right" valign="top"><a id="a710e074e59057ba20c9305753de6fe1d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SumElements, <a class="el" href="classcaffe2_1_1GetSumElementsGradient.html">GetSumElementsGradient</a>)</td></tr>
<tr class="separator:a710e074e59057ba20c9305753de6fe1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9f64c50e026ab200358f11cff4b029"><td class="memItemLeft" align="right" valign="top"><a id="abd9f64c50e026ab200358f11cff4b029"></a>
A tenosr of dimensions batch_size x M x N to compute rowwise max&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;Y&quot;, &quot;batch_size x M rowwise-max results matrix.&quot;)</td></tr>
<tr class="separator:abd9f64c50e026ab200358f11cff4b029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58baaf4bf8729ec47290a5773fc269f4"><td class="memItemLeft" align="right" valign="top"><a id="a58baaf4bf8729ec47290a5773fc269f4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (RowwiseMaxGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a58baaf4bf8729ec47290a5773fc269f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e10141cd65f91df02338c5a2e612a4"><td class="memItemLeft" align="right" valign="top"><a id="ae4e10141cd65f91df02338c5a2e612a4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (RowwiseMax, <a class="el" href="classcaffe2_1_1GetRowwiseMaxGradient.html">GetRowwiseMaxGradient</a>)</td></tr>
<tr class="separator:ae4e10141cd65f91df02338c5a2e612a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa615559f7cfe8a100f24ec2f5f43a42f"><td class="memItemLeft" align="right" valign="top"><a id="aa615559f7cfe8a100f24ec2f5f43a42f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ColwiseMaxGradient)</td></tr>
<tr class="separator:aa615559f7cfe8a100f24ec2f5f43a42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b2c47cdd4ccc5c3049f265c56c67ec"><td class="memItemLeft" align="right" valign="top"><a id="a85b2c47cdd4ccc5c3049f265c56c67ec"></a>
A tenosr of dimensions batch_size x M x N to compute colwise max&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;Y&quot;, &quot;batch_size x N column-max results matrix.&quot;)</td></tr>
<tr class="separator:a85b2c47cdd4ccc5c3049f265c56c67ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc860d6eb5d2649bbe8a4bef24b7da9"><td class="memItemLeft" align="right" valign="top"><a id="a9cc860d6eb5d2649bbe8a4bef24b7da9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ColumnMaxGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:a9cc860d6eb5d2649bbe8a4bef24b7da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90076a90342560207e94c80c8efcdf86"><td class="memItemLeft" align="right" valign="top"><a id="a90076a90342560207e94c80c8efcdf86"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ColwiseMax, <a class="el" href="classcaffe2_1_1GetColwiseMaxGradient.html">GetColwiseMaxGradient</a>)</td></tr>
<tr class="separator:a90076a90342560207e94c80c8efcdf86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c9a2f38b64d7e92fd298625111357e"><td class="memItemLeft" align="right" valign="top"><a id="ad4c9a2f38b64d7e92fd298625111357e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Relu, <a class="el" href="classcaffe2_1_1ReluOp.html">ReluOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad4c9a2f38b64d7e92fd298625111357e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e9e65f91c86d22430f7000e5dd6df7"><td class="memItemLeft" align="right" valign="top"><a id="aa8e9e65f91c86d22430f7000e5dd6df7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReluGradient, <a class="el" href="classcaffe2_1_1ReluGradientOp.html">ReluGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa8e9e65f91c86d22430f7000e5dd6df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a3e59be8aeb73cb6378d58a9940da76"><td class="memItemLeft" align="right" valign="top"><a id="a8a3e59be8aeb73cb6378d58a9940da76"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CostInferenceFunction</b> (PointwiseCostInference&lt; 2 &gt;) .IdenticalTypeAndShape() .SetDoc(R&quot;DOC( Relu takes one input data (<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt;T&gt;) and produces one output data (<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt;T&gt;) where the rectified linear function</td></tr>
<tr class="separator:a8a3e59be8aeb73cb6378d58a9940da76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39ce3aea64f0df0d6e527af7063ead0"><td class="memItemLeft" align="right" valign="top"><a id="af39ce3aea64f0df0d6e527af7063ead0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
ReluGradient takes both Y and dY and uses this to update dX according to the
chain rule and derivatives of the rectified linear function.
)DOC&quot;)</td></tr>
<tr class="separator:af39ce3aea64f0df0d6e527af7063ead0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242f063fedcfd6720f10b5a7b870c270"><td class="memItemLeft" align="right" valign="top"><a id="a242f063fedcfd6720f10b5a7b870c270"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Relu, <a class="el" href="classcaffe2_1_1GetReluGradient.html">GetReluGradient</a>)</td></tr>
<tr class="separator:a242f063fedcfd6720f10b5a7b870c270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40256412d4129bf3b612a9026020b79b"><td class="memItemLeft" align="right" valign="top"><a id="a40256412d4129bf3b612a9026020b79b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ReluFp16, <a class="el" href="classcaffe2_1_1GetReluGradient.html">GetReluGradient</a>)</td></tr>
<tr class="separator:a40256412d4129bf3b612a9026020b79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb77e9bedf197eb81679492e72c7f78d"><td class="memItemLeft" align="right" valign="top"><a id="abb77e9bedf197eb81679492e72c7f78d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReplaceNaN, <a class="el" href="classcaffe2_1_1ReplaceNaNOp.html">ReplaceNaNOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:abb77e9bedf197eb81679492e72c7f78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91333c0430d3f7852e1c5494674ed889"><td class="memItemLeft" align="right" valign="top"><a id="a91333c0430d3f7852e1c5494674ed889"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (ReplaceNaN)</td></tr>
<tr class="separator:a91333c0430d3f7852e1c5494674ed889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9937a9917b9903bbe5e6a2ee616db41"><td class="memItemLeft" align="right" valign="top"><a id="ac9937a9917b9903bbe5e6a2ee616db41"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Reshape, <a class="el" href="classcaffe2_1_1ReshapeOp.html">ReshapeOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac9937a9917b9903bbe5e6a2ee616db41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7aa57dacbad40e89abf534ad2d3897"><td class="memItemLeft" align="right" valign="top"><a id="a8f7aa57dacbad40e89abf534ad2d3897"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (1, 2) .NumOutputs(2) .TensorInferenceFunction([](const OperatorDef &amp;def</td></tr>
<tr class="separator:a8f7aa57dacbad40e89abf534ad2d3897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca224e4b6d4df756ab84ef0ba0a98504"><td class="memItemLeft" align="right" valign="top"><a id="aca224e4b6d4df756ab84ef0ba0a98504"></a>
out [1]&#160;</td><td class="memItemRight" valign="bottom"><b>set_data_type</b> (TensorProto::INT64)</td></tr>
<tr class="separator:aca224e4b6d4df756ab84ef0ba0a98504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b1b09fdc4a1a9364b9164d209ec0f6"><td class="memItemLeft" align="right" valign="top"><a id="aa4b1b09fdc4a1a9364b9164d209ec0f6"></a>
out [1]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (in[0].dims_size())</td></tr>
<tr class="separator:aa4b1b09fdc4a1a9364b9164d209ec0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182b62362e577db6a6d7abd5c282d940"><td class="memItemLeft" align="right" valign="top"><a id="a182b62362e577db6a6d7abd5c282d940"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (!helper.HasArgument(&quot;shape&quot;))</td></tr>
<tr class="separator:a182b62362e577db6a6d7abd5c282d940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9b3fe1e903db8cb9705b4877795295"><td class="memItemLeft" align="right" valign="top"><a id="a2f9b3fe1e903db8cb9705b4877795295"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_ENFORCE_EQ</b> (in.size(), 1, &quot;New shape must not be specified by the input blob and the &quot; &quot;argument `shape` at the same time.&quot;)</td></tr>
<tr class="separator:a2f9b3fe1e903db8cb9705b4877795295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983622a08a3c507b7c23808015f8000e"><td class="memItemLeft" align="right" valign="top"><a id="a983622a08a3c507b7c23808015f8000e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>for</b> (int i=0;i&lt; actualNewShape.size();++i)</td></tr>
<tr class="separator:a983622a08a3c507b7c23808015f8000e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453266db1e0abee094d16f4db3eb2f37"><td class="memItemLeft" align="right" valign="top"><a id="a453266db1e0abee094d16f4db3eb2f37"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (unknownIdx !=-1)</td></tr>
<tr class="separator:a453266db1e0abee094d16f4db3eb2f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80b2ab967ff8a96d8a408fbb29d6992"><td class="memItemLeft" align="right" valign="top"><a id="ab80b2ab967ff8a96d8a408fbb29d6992"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>for</b> (const auto d :actualNewShape)</td></tr>
<tr class="separator:ab80b2ab967ff8a96d8a408fbb29d6992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0d078086de03f46215d1020d3416fa"><td class="memItemLeft" align="right" valign="top"><a id="a5f0d078086de03f46215d1020d3416fa"></a>
an extra argument shape must be specified It outputs the reshaped tensor as well as the original shape At most one dimension of the new shape can be In this the value is inferred from the size of the tensor and the remaining dimensions A dimension could also in which case the actual dimension value is going to be copied from the input tensor DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;shape&quot;, &quot;New shape&quot;) .Input(0</td></tr>
<tr class="separator:a5f0d078086de03f46215d1020d3416fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074be7a494aa7b0db4c55fd9fbab90cd"><td class="memItemLeft" align="right" valign="top"><a id="a074be7a494aa7b0db4c55fd9fbab90cd"></a>
an extra argument shape must be specified It outputs the reshaped tensor as well as the original shape At most one dimension of the new shape can be In this the value is inferred from the size of the tensor and the remaining dimensions A dimension could also in which case the actual dimension value is going to be copied from the input tensor DOC An input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;new_shape&quot;, &quot;New shape.&quot;) .Output(0</td></tr>
<tr class="separator:a074be7a494aa7b0db4c55fd9fbab90cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6087c2f000d49c823dd3d3a0ddc08bbe"><td class="memItemLeft" align="right" valign="top"><a id="a6087c2f000d49c823dd3d3a0ddc08bbe"></a>
an extra argument shape must be specified It outputs the reshaped tensor as well as the original shape At most one dimension of the new shape can be In this the value is inferred from the size of the tensor and the remaining dimensions A dimension could also in which case the actual dimension value is going to be copied from the input tensor DOC An input tensor Reshaped data&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1, &quot;old_shape&quot;, &quot;Original shape.&quot;)</td></tr>
<tr class="separator:a6087c2f000d49c823dd3d3a0ddc08bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb82d86019508089c62385447aae9d7"><td class="memItemLeft" align="right" valign="top"><a id="afcb82d86019508089c62385447aae9d7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Reshape, <a class="el" href="classcaffe2_1_1GetReshapeGradient.html">GetReshapeGradient</a>)</td></tr>
<tr class="separator:afcb82d86019508089c62385447aae9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ab2e70a3bfb7e2f0c7a0bb7fd0abec"><td class="memItemLeft" align="right" valign="top"><a id="aa6ab2e70a3bfb7e2f0c7a0bb7fd0abec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Reshape, <a class="el" href="classcaffe2_1_1ReshapeOp.html">ReshapeOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aa6ab2e70a3bfb7e2f0c7a0bb7fd0abec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1239df75052146b3c2b8e74e50a962"><td class="memItemLeft" align="right" valign="top"><a id="acd1239df75052146b3c2b8e74e50a962"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resizeNearest2x</b> (int batch_size, int num_channels, int input_height, int input_width, const float *input, float *output)</td></tr>
<tr class="separator:acd1239df75052146b3c2b8e74e50a962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade904b440a50a3605f59dabc45b1c6e5"><td class="memItemLeft" align="right" valign="top"><a id="ade904b440a50a3605f59dabc45b1c6e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ResizeNearest, <a class="el" href="classcaffe2_1_1ResizeNearestOp.html">ResizeNearestOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ade904b440a50a3605f59dabc45b1c6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5099b88879f337f70d805e381e75b9"><td class="memItemLeft" align="right" valign="top"><a id="a9c5099b88879f337f70d805e381e75b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ResizeNearestGradient, <a class="el" href="classcaffe2_1_1ResizeNearestGradientOp.html">ResizeNearestGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9c5099b88879f337f70d805e381e75b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd4d941856b3ae088692639ce11e15b"><td class="memItemLeft" align="right" valign="top"><a id="aafd4d941856b3ae088692639ce11e15b"></a>
Scale along width dimension&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;height_scale&quot;, &quot;Scale along height dimension&quot;) .SetDoc(R&quot;DOC( Resizes the spatial dimensions of the input using nearest neighbor interpolation. The `width_scale` and `height_scale` arguments control the size of the output</td></tr>
<tr class="separator:aafd4d941856b3ae088692639ce11e15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af348600abc35b011c1ea02b66ff54e3a"><td class="memItemLeft" align="right" valign="top"><a id="af348600abc35b011c1ea02b66ff54e3a"></a>
Scale along width dimension which is given Input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;Y&quot;, &quot;Output tensor&quot;)</td></tr>
<tr class="separator:af348600abc35b011c1ea02b66ff54e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713cdbe8cf8e7dc849e6279a4e959d57"><td class="memItemLeft" align="right" valign="top"><a id="a713cdbe8cf8e7dc849e6279a4e959d57"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ResizeNearest, <a class="el" href="classcaffe2_1_1GetResizeNearestGradient.html">GetResizeNearestGradient</a>)</td></tr>
<tr class="separator:a713cdbe8cf8e7dc849e6279a4e959d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043d03a0b74434f9e624e9bc23aa7377"><td class="memItemLeft" align="right" valign="top"><a id="a043d03a0b74434f9e624e9bc23aa7377"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ReversePackedSegs, <a class="el" href="classcaffe2_1_1ReversePackedSegsOp.html">ReversePackedSegsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a043d03a0b74434f9e624e9bc23aa7377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48804c1190c0888aae87dbb9127e907"><td class="memItemLeft" align="right" valign="top"><a id="ad48804c1190c0888aae87dbb9127e907"></a>
leaving paddings unchanged This&#160;</td><td class="memItemRight" valign="bottom"><b>operator is used to reverse input of a recurrent neural network to make it a BRNN.) DOC&quot;) .Input</b> (0, &quot;data&quot;, &quot;a 3-D (lengths, segments, embeddings,) tensor.&quot;) .Input(1</td></tr>
<tr class="separator:ad48804c1190c0888aae87dbb9127e907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde3c73031b5462d503f88c1d03bb394"><td class="memItemLeft" align="right" valign="top"><a id="abde3c73031b5462d503f88c1d03bb394"></a>
leaving paddings unchanged This length of each segment&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;reversed data&quot;, &quot;a (lengths, segments, embeddings,) tensor with each segment reversed&quot; &quot;and paddings unchanged.&quot;)</td></tr>
<tr class="separator:abde3c73031b5462d503f88c1d03bb394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55813f369cb301e8c0051b56b96a318"><td class="memItemLeft" align="right" valign="top"><a id="aa55813f369cb301e8c0051b56b96a318"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ReversePackedSegs, <a class="el" href="classcaffe2_1_1GetReversePackedSegsGradient.html">GetReversePackedSegsGradient</a>)</td></tr>
<tr class="separator:aa55813f369cb301e8c0051b56b96a318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23bb5b87e8ea0cfb2b5a63695f04d51"><td class="memItemLeft" align="right" valign="top"><a id="ae23bb5b87e8ea0cfb2b5a63695f04d51"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RMACRegions, <a class="el" href="classcaffe2_1_1RMACRegionsOp.html">RMACRegionsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae23bb5b87e8ea0cfb2b5a63695f04d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1159a62c926097876cded3160b7afe95"><td class="memItemLeft" align="right" valign="top"><a id="a1159a62c926097876cded3160b7afe95"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Scale, <a class="el" href="classcaffe2_1_1ScaleOp.html">ScaleOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1159a62c926097876cded3160b7afe95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02ecb0fbf2afa6ea64145dd15900e96"><td class="memItemLeft" align="right" valign="top"><a id="af02ecb0fbf2afa6ea64145dd15900e96"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Scale, <a class="el" href="classcaffe2_1_1GetScaleGradient.html">GetScaleGradient</a>)</td></tr>
<tr class="separator:af02ecb0fbf2afa6ea64145dd15900e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07e060dd9c1c0f4a22082fa13abd792"><td class="memItemLeft" align="right" valign="top"><a id="aa07e060dd9c1c0f4a22082fa13abd792"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Scale, <a class="el" href="classcaffe2_1_1ScaleOp.html">ScaleOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aa07e060dd9c1c0f4a22082fa13abd792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622d8c518157abd3bea547391095532f"><td class="memItemLeft" align="right" valign="top"><a id="a622d8c518157abd3bea547391095532f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseLengthsIndicesInGradientWeightedSumWithMainInputGradient, <a class="el" href="classcaffe2_1_1AbstractLengthsWithMainInputGradientOp.html">AbstractLengthsWithMainInputGradientOp</a>&lt; float, int, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, WeightedSumReducerDef::template ReducerGradient&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;, true, true &gt;)</td></tr>
<tr class="separator:a622d8c518157abd3bea547391095532f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff644a53b8cf580d4b05c161a9053133"><td class="memItemLeft" align="right" valign="top"><a id="aff644a53b8cf580d4b05c161a9053133"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseLengthsIndicesInGradientWeightedSumGradient, <a class="el" href="classcaffe2_1_1AbstractLengthsGradientOp.html">AbstractLengthsGradientOp</a>&lt; float, int, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, WeightedSumReducerDef::template ReducerGradient&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;, true &gt;)</td></tr>
<tr class="separator:aff644a53b8cf580d4b05c161a9053133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee4fbd38ead2ffa712e22a020094b2d"><td class="memItemLeft" align="right" valign="top"><a id="a0ee4fbd38ead2ffa712e22a020094b2d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseLengthsIndicesInGradientSumGradient, <a class="el" href="classcaffe2_1_1AbstractLengthsGradientOp.html">AbstractLengthsGradientOp</a>&lt; float, int, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, SumReducerDef::template ReducerGradient&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;, true &gt;)</td></tr>
<tr class="separator:a0ee4fbd38ead2ffa712e22a020094b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d6dd1f6e01d4b156c6595613c0f0f2"><td class="memItemLeft" align="right" valign="top"><a id="af3d6dd1f6e01d4b156c6595613c0f0f2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LengthsIndicesInGradientSumGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:af3d6dd1f6e01d4b156c6595613c0f0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed489fa4cf75c02fa66a66da804522d6"><td class="memItemLeft" align="right" valign="top"><a id="aed489fa4cf75c02fa66a66da804522d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsIndicesInGradientSumGradient, <a class="el" href="classcaffe2_1_1AbstractLengthsGradientOp.html">AbstractLengthsGradientOp</a>&lt; float, int, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, SumReducerDef::template ReducerGradient&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;, true &gt;)</td></tr>
<tr class="separator:aed489fa4cf75c02fa66a66da804522d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a765ec9d4e39ebf931654f2c753d52065"><td class="memItemLeft" align="right" valign="top"><a id="a765ec9d4e39ebf931654f2c753d52065"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Selu, <a class="el" href="classcaffe2_1_1SeluOp.html">SeluOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a765ec9d4e39ebf931654f2c753d52065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016d28f688e82e9b264309c577b389ed"><td class="memItemLeft" align="right" valign="top"><a id="a016d28f688e82e9b264309c577b389ed"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SeluGradient, <a class="el" href="classcaffe2_1_1SeluGradientOp.html">SeluGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a016d28f688e82e9b264309c577b389ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d0a84cf725cf38debfe35a5d2f74df"><td class="memItemLeft" align="right" valign="top"><a id="a03d0a84cf725cf38debfe35a5d2f74df"></a>
is applied to the tensor elementwise DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;alpha&quot;, &quot;(float) default to 1.6732~; affects the activation function itself. &quot; &quot;This should go with the weight initialization in the paper. &quot; &quot; See https://arxiv.org/abs/1706.02515 &quot;) .Arg(&quot;scale&quot;</td></tr>
<tr class="separator:a03d0a84cf725cf38debfe35a5d2f74df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa762ae0ea4453f1c630d46044c7cb3d"><td class="memItemLeft" align="right" valign="top"><a id="aaa762ae0ea4453f1c630d46044c7cb3d"></a>
affects the activation function itself&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;X&quot;, &quot;input tensor&quot;) .Output(0</td></tr>
<tr class="separator:aaa762ae0ea4453f1c630d46044c7cb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2727f61270b063cf813a6f4ddfc82662"><td class="memItemLeft" align="right" valign="top"><a id="a2727f61270b063cf813a6f4ddfc82662"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
SeluGradient takes both Y and dY and uses this to update dX according to the
chain rule and derivatives of the selu function.
)DOC&quot;) .Arg(&quot;alpha&quot;</td></tr>
<tr class="separator:a2727f61270b063cf813a6f4ddfc82662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1411861598dd543f5e1693661c2f03c"><td class="memItemLeft" align="right" valign="top"><a id="aa1411861598dd543f5e1693661c2f03c"></a>
affects the activation function itself&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;Y&quot;, &quot;input tensor&quot;) .Input(1</td></tr>
<tr class="separator:aa1411861598dd543f5e1693661c2f03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef2b5f398ce932ceda8ea5e6f365b3c"><td class="memItemLeft" align="right" valign="top"><a id="aaef2b5f398ce932ceda8ea5e6f365b3c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Selu, <a class="el" href="classcaffe2_1_1GetSeluGradient.html">GetSeluGradient</a>)</td></tr>
<tr class="separator:aaef2b5f398ce932ceda8ea5e6f365b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457dd70408b41358d19dc630796e39bc"><td class="memItemLeft" align="right" valign="top"><a id="a457dd70408b41358d19dc630796e39bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AddPadding, <a class="el" href="classcaffe2_1_1AddPaddingOp.html">AddPaddingOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a457dd70408b41358d19dc630796e39bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675075e89d477f05f8d7086eb11f0aab"><td class="memItemLeft" align="right" valign="top"><a id="a675075e89d477f05f8d7086eb11f0aab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RemovePadding, <a class="el" href="classcaffe2_1_1RemovePaddingOp.html">RemovePaddingOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a675075e89d477f05f8d7086eb11f0aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e17c64c70ff762d285c362af49eb59a"><td class="memItemLeft" align="right" valign="top"><a id="a9e17c64c70ff762d285c362af49eb59a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GatherPadding, <a class="el" href="classcaffe2_1_1GatherPaddingOp.html">GatherPaddingOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a9e17c64c70ff762d285c362af49eb59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca82e1ba385039e99aff711d3b972240"><td class="memItemLeft" align="right" valign="top"><a id="aca82e1ba385039e99aff711d3b972240"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (PadEmptySamples, <a class="el" href="classcaffe2_1_1PadEmptySamplesOp.html">PadEmptySamplesOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aca82e1ba385039e99aff711d3b972240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79da49fb460bb50acc1db902386e2e93"><td class="memItemLeft" align="right" valign="top"><a id="a79da49fb460bb50acc1db902386e2e93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (AddPadding, <a class="el" href="structcaffe2_1_1GetAddPaddingGradient.html">GetAddPaddingGradient</a>)</td></tr>
<tr class="separator:a79da49fb460bb50acc1db902386e2e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6f136ea5a1e636c7b3f222755d20b6"><td class="memItemLeft" align="right" valign="top"><a id="a2a6f136ea5a1e636c7b3f222755d20b6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (RemovePadding, <a class="el" href="structcaffe2_1_1GetRemovePaddingGradient.html">GetRemovePaddingGradient</a>)</td></tr>
<tr class="separator:a2a6f136ea5a1e636c7b3f222755d20b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c45cae0d2f48f16e2032724f503f15"><td class="memItemLeft" align="right" valign="top"><a id="ad9c45cae0d2f48f16e2032724f503f15"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given a partitioned tensor T&lt;N, D1..., Dn&gt;, where the partitions are
defined as ranges on its outer-most (slowest varying) dimension N,
with given range lengths, return a tensor T&lt;N + 2*padding_width, D1 ..., Dn&gt;
with paddings added to the start and end of each range.
Optionally, different paddings can be provided for beginning and end. Paddings
provided must be a tensor T&lt;D1..., Dn&gt;.

If no padding is provided, add zero padding.
If no lengths vector is provided, add padding only once,
at the start and end of data.
)DOC&quot;) .Arg(&quot;padding_width&quot;</td></tr>
<tr class="separator:ad9c45cae0d2f48f16e2032724f503f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0820e806672ca0fced95d687a66147"><td class="memItemLeft" align="right" valign="top"><a id="aee0820e806672ca0fced95d687a66147"></a>
Number of copies of padding to add around each range&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;end_padding_width&quot;, &quot;(Optional) Specifies a different end-padding width.&quot;) .Input(0</td></tr>
<tr class="separator:aee0820e806672ca0fced95d687a66147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a207663a96f270579a97765d05538016b"><td class="memItemLeft" align="right" valign="top"><a id="a207663a96f270579a97765d05538016b"></a>
Number of copies of padding to add around each range T&lt; N, D1..., Dn &gt; Input data&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;lengths&quot;, &quot;(i64) Num of elements in each range. sum(lengths) = N.&quot;) .Input(2</td></tr>
<tr class="separator:a207663a96f270579a97765d05538016b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4240c0156cbfae5d070b4cc79a735503"><td class="memItemLeft" align="right" valign="top"><a id="a4240c0156cbfae5d070b4cc79a735503"></a>
Number of copies of padding to add around each range T&lt; N, D1..., Dn &gt; Input data T&lt; D1..., Dn &gt; Padding data for range start&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3, &quot;end_padding&quot;, &quot;T&lt;D1..., Dn&gt; (optional) Padding for range end. &quot; &quot;If not provided, start_padding is used as end_padding as well.&quot;) .Output(0</td></tr>
<tr class="separator:a4240c0156cbfae5d070b4cc79a735503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67bd479ef2e32f7b2c2bdaf6e1679f5"><td class="memItemLeft" align="right" valign="top"><a id="ad67bd479ef2e32f7b2c2bdaf6e1679f5"></a>
Number of copies of padding to add around each range T&lt; N, D1..., Dn &gt; Input data T&lt; D1..., Dn &gt; Padding data for range start T&lt; N+2 *padding_width, D1..., Dn &gt; Padded data&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1, &quot;lengths_out&quot;, &quot;(i64, optional) Lengths for each padded range.&quot;)</td></tr>
<tr class="separator:ad67bd479ef2e32f7b2c2bdaf6e1679f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b783d314d17cbd61a5f0d4e684dce8"><td class="memItemLeft" align="right" valign="top"><a id="a40b783d314d17cbd61a5f0d4e684dce8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Remove padding around the edges of each segment of the input data. This is
the reverse opration of AddPadding, and uses the same arguments and conventions
for input and output data format.
)DOC&quot;) .Arg(&quot;padding_width&quot;</td></tr>
<tr class="separator:a40b783d314d17cbd61a5f0d4e684dce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167053b8721acf90135431f5c6aa53fe"><td class="memItemLeft" align="right" valign="top"><a id="a167053b8721acf90135431f5c6aa53fe"></a>
Outer size of padding to remove around each range T&lt; N, D1..., Dn &gt; Input data&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;lengths&quot;, &quot;(i64) Num of elements in each range. sum(lengths) = N. &quot; &quot;If not provided, considers all data as a single segment.&quot;) .Output(0</td></tr>
<tr class="separator:a167053b8721acf90135431f5c6aa53fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa245438509b62b2dcc01f4e66bc48258"><td class="memItemLeft" align="right" valign="top"><a id="aa245438509b62b2dcc01f4e66bc48258"></a>
Outer size of padding to remove around each range T&lt; N, D1..., Dn &gt; Input data T&lt; N - 2 *padding_width, D1..., Dn &gt; Unpadded data&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1, &quot;lengths_out&quot;, &quot;(i64, optional) Lengths for each unpadded range.&quot;)</td></tr>
<tr class="separator:aa245438509b62b2dcc01f4e66bc48258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6acc55f6aff33e7ad2d982769e5f4ee"><td class="memItemLeft" align="right" valign="top"><a id="af6acc55f6aff33e7ad2d982769e5f4ee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Gather the sum of start and end paddings in a padded input sequence. Used in
order to compute the gradients of AddPadding w.r.t the padding tensors.
)DOC&quot;) .Arg(&quot;padding_width&quot;</td></tr>
<tr class="separator:af6acc55f6aff33e7ad2d982769e5f4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac151476eab4965fd28b5330229d47517"><td class="memItemLeft" align="right" valign="top"><a id="ac151476eab4965fd28b5330229d47517"></a>
Outer size of padding present around each range T&lt; N, D1..., Dn &gt; Padded input data Sum of all start or of all paddings if end_padding_sum is not provided&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1, &quot;end_padding_sum&quot;, &quot;T&lt;D1..., Dn&gt; Sum of all end paddings, if provided.&quot;)</td></tr>
<tr class="separator:ac151476eab4965fd28b5330229d47517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c7905de9e97d0e4875a16343c14b29"><td class="memItemLeft" align="right" valign="top"><a id="aa6c7905de9e97d0e4875a16343c14b29"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Pad empty field given lengths and index features,

Input(0) is a blob pointing to the lengths of samples in one batch,
[Input(1),... Input(num_fields)] a list of tensors containing the data for
each field of the features.

PadEmptySamples is thread safe.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:aa6c7905de9e97d0e4875a16343c14b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceae11b8597903255ac12452bc1a8e83"><td class="memItemLeft" align="right" valign="top"><a id="aceae11b8597903255ac12452bc1a8e83"></a>
INT_MAX A blob containing a pointer to the lengths&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;out_lengths&quot;, &quot;<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> containing lengths with empty sample padded.&quot;)</td></tr>
<tr class="separator:aceae11b8597903255ac12452bc1a8e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e97663b7dbf517f27fbe11677f5260a"><td class="memItemLeft" align="right" valign="top"><a id="a8e97663b7dbf517f27fbe11677f5260a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Shape, <a class="el" href="classcaffe2_1_1ShapeOp.html">ShapeOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a8e97663b7dbf517f27fbe11677f5260a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fcd0dc979669945b10f0d2a689cfa87"><td class="memItemLeft" align="right" valign="top"><a id="a5fcd0dc979669945b10f0d2a689cfa87"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (in[0].dims().size())</td></tr>
<tr class="separator:a5fcd0dc979669945b10f0d2a689cfa87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33764413ff2c19ffea6d329adbf78ad"><td class="memItemLeft" align="right" valign="top"><a id="aa33764413ff2c19ffea6d329adbf78ad"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>set_data_type</b> (TensorProto::INT32)</td></tr>
<tr class="separator:aa33764413ff2c19ffea6d329adbf78ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed493261e8efa97e1b71333c4e34d19"><td class="memItemLeft" align="right" valign="top"><a id="a6ed493261e8efa97e1b71333c4e34d19"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (&quot;Produce a 1D int64 tensor with the shape of the input tensor.&quot;)</td></tr>
<tr class="separator:a6ed493261e8efa97e1b71333c4e34d19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250e210ebc7b83eff196adf32c4c5674"><td class="memItemLeft" align="right" valign="top"><a id="a250e210ebc7b83eff196adf32c4c5674"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Shape)</td></tr>
<tr class="separator:a250e210ebc7b83eff196adf32c4c5674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570069e0367edaef71f55323bafa08d0"><td class="memItemLeft" align="right" valign="top"><a id="a570069e0367edaef71f55323bafa08d0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Shape, <a class="el" href="classcaffe2_1_1ShapeOp.html">ShapeOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a570069e0367edaef71f55323bafa08d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55316d45ffcf57d0685f4ce802e808a6"><td class="memItemLeft" align="right" valign="top"><a id="a55316d45ffcf57d0685f4ce802e808a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Sigmoid, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1SigmoidCPUFunctor.html">SigmoidCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:a55316d45ffcf57d0685f4ce802e808a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ebde54190f626dc7b3aad23808229c"><td class="memItemLeft" align="right" valign="top"><a id="a07ebde54190f626dc7b3aad23808229c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SigmoidGradient, <a class="el" href="classcaffe2_1_1BinaryElementwiseOp.html">BinaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1WithoutBroadcast.html">WithoutBroadcast</a>&lt; <a class="el" href="structcaffe2_1_1SigmoidGradientCPUFunctor.html">SigmoidGradientCPUFunctor</a> &gt;&gt;)</td></tr>
<tr class="separator:a07ebde54190f626dc7b3aad23808229c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e16d0636c3fe6f41ff3c2acf707907a"><td class="memItemLeft" align="right" valign="top"><a id="a6e16d0636c3fe6f41ff3c2acf707907a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
SigmoidGradient takes both Y and dY and uses this to update dX according to the
chain rule and derivatives of the sigmoid function.
)DOC&quot;)</td></tr>
<tr class="separator:a6e16d0636c3fe6f41ff3c2acf707907a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a39de2621fd3600d6f7b973422bd36"><td class="memItemLeft" align="right" valign="top"><a id="a55a39de2621fd3600d6f7b973422bd36"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Sigmoid, <a class="el" href="classcaffe2_1_1GetSigmoidGradient.html">GetSigmoidGradient</a>)</td></tr>
<tr class="separator:a55a39de2621fd3600d6f7b973422bd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2dd25f86457b1ce019afa23e74ad314"><td class="memItemLeft" align="right" valign="top"><a id="ae2dd25f86457b1ce019afa23e74ad314"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Sin, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1SinCPUFunctor.html">SinCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:ae2dd25f86457b1ce019afa23e74ad314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5568dbbcdb47d0628f236ac0eb8c9bd8"><td class="memItemLeft" align="right" valign="top"><a id="a5568dbbcdb47d0628f236ac0eb8c9bd8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SinGradient, <a class="el" href="classcaffe2_1_1BinaryElementwiseOp.html">BinaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1WithoutBroadcast.html">WithoutBroadcast</a>&lt; <a class="el" href="structcaffe2_1_1SinGradientCPUFunctor.html">SinGradientCPUFunctor</a> &gt;&gt;)</td></tr>
<tr class="separator:a5568dbbcdb47d0628f236ac0eb8c9bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3174e345cd49490fecdf38615c69da"><td class="memItemLeft" align="right" valign="top"><a id="acc3174e345cd49490fecdf38615c69da"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (SinGradient).NumInputs(2).NumOutputs(1).IdenticalTypeAndShape()</td></tr>
<tr class="separator:acc3174e345cd49490fecdf38615c69da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e0d94d77754852fc8522925954f6f3"><td class="memItemLeft" align="right" valign="top"><a id="a77e0d94d77754852fc8522925954f6f3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Sin, <a class="el" href="classcaffe2_1_1GetSinGradient.html">GetSinGradient</a>)</td></tr>
<tr class="separator:a77e0d94d77754852fc8522925954f6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d4b756535d478a0666d976258040d6"><td class="memItemLeft" align="right" valign="top"><a id="a87d4b756535d478a0666d976258040d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SinusoidPositionEncoding, <a class="el" href="classcaffe2_1_1SinusoidPositionEncodingOp.html">SinusoidPositionEncodingOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a87d4b756535d478a0666d976258040d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621da74b2679f79390bf95335308c027"><td class="memItemLeft" align="right" valign="top"><a id="a621da74b2679f79390bf95335308c027"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Slice, <a class="el" href="classcaffe2_1_1SliceOp.html">SliceOp</a>&lt; int, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a621da74b2679f79390bf95335308c027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1edb64f5df0c515bbb6af1d0b80e54"><td class="memItemLeft" align="right" valign="top"><a id="a4f1edb64f5df0c515bbb6af1d0b80e54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SliceGradient, <a class="el" href="classcaffe2_1_1SliceGradientOp.html">SliceGradientOp</a>&lt; int, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4f1edb64f5df0c515bbb6af1d0b80e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e49a10a8eb6fceb1fc5fcb35307906f"><td class="memItemLeft" align="right" valign="top"><a id="a9e49a10a8eb6fceb1fc5fcb35307906f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (1, 3) .NumOutputs(1) .SetDoc(R&quot;DOC( Produces a slice of the input tensor. Currently</td></tr>
<tr class="separator:a9e49a10a8eb6fceb1fc5fcb35307906f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad02cb3e67bee38b29103a878b3d710c0"><td class="memItemLeft" align="right" valign="top"><a id="ad02cb3e67bee38b29103a878b3d710c0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Softmax, <a class="el" href="classcaffe2_1_1SoftmaxOp.html">SoftmaxOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad02cb3e67bee38b29103a878b3d710c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1212b684fcf3c2c96e98768ca84b857"><td class="memItemLeft" align="right" valign="top"><a id="af1212b684fcf3c2c96e98768ca84b857"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SoftmaxGradient, <a class="el" href="classcaffe2_1_1SoftmaxGradientOp.html">SoftmaxGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af1212b684fcf3c2c96e98768ca84b857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59568d6438eabd8d5e61cfe876e9d4c8"><td class="memItemLeft" align="right" valign="top"><a id="a59568d6438eabd8d5e61cfe876e9d4c8"></a>
it will be coerced into one For an arbitrary n dimensional tensor X in [a_0, a_1,..., a_{k-1}, a_k,..., a_{n-1}] and k is the axis then X will be coerced into a dimensional tensor with dimensions [a_0 *... *a_{k-1}, a_k *... *a_{n-1}] For the default case where this means the X tensor will be coerced into a tensor of where a_0 is often the batch size In this we must have or else the&#160;</td><td class="memItemRight" valign="bottom"><b>operator will throw errors.) DOC&quot;) .Arg</b> (&quot;axis&quot;, &quot;(int) default to 1; describes the axis of the inputs when coerced &quot; &quot;to 2D; defaults to one because the 0th axis most likely describes &quot; &quot;the batch_size&quot;) .Input(0</td></tr>
<tr class="separator:a59568d6438eabd8d5e61cfe876e9d4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d2dbf77f047c6b7aee79ad34be9f76"><td class="memItemLeft" align="right" valign="top"><a id="ab8d2dbf77f047c6b7aee79ad34be9f76"></a>
it will be coerced into one For an arbitrary n dimensional tensor X in [a_0, a_1,..., a_{k-1}, a_k,..., a_{n-1}] and k is the axis then X will be coerced into a dimensional tensor with dimensions [a_0 *... *a_{k-1}, a_k *... *a_{n-1}] For the default case where this means the X tensor will be coerced into a tensor of where a_0 is often the batch size In this we must have or else the The input tensor that s coerced into a matrix of&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (NxD) &quot; &quot;as described above.&quot;) .Output(0</td></tr>
<tr class="separator:ab8d2dbf77f047c6b7aee79ad34be9f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885bce453a892365513928cb409e7752"><td class="memItemLeft" align="right" valign="top"><a id="a885bce453a892365513928cb409e7752"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (SoftmaxGradient).NumInputs(2).NumOutputs(1)</td></tr>
<tr class="separator:a885bce453a892365513928cb409e7752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8825981fdefb97fb6366d2f24e68639a"><td class="memItemLeft" align="right" valign="top"><a id="a8825981fdefb97fb6366d2f24e68639a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Softmax, <a class="el" href="classcaffe2_1_1GetSoftmaxGradient.html">GetSoftmaxGradient</a>)</td></tr>
<tr class="separator:a8825981fdefb97fb6366d2f24e68639a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3879bb83a156661b7d8c7ec039980121"><td class="memItemLeft" align="right" valign="top"><a id="a3879bb83a156661b7d8c7ec039980121"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SoftmaxFp16, <a class="el" href="classcaffe2_1_1GetSoftmaxGradient.html">GetSoftmaxGradient</a>)</td></tr>
<tr class="separator:a3879bb83a156661b7d8c7ec039980121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af330cbed1de990a2c5811866b84ce32f"><td class="memItemLeft" align="right" valign="top"><a id="af330cbed1de990a2c5811866b84ce32f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SoftmaxCPU</b> (<a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &amp;context, const int N, const int D, const float *Xdata, float *Ydata, float *scale, const float *sum_multiplier, bool logarithmic, float *rowmax)</td></tr>
<tr class="separator:af330cbed1de990a2c5811866b84ce32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68815986ef2a1b95f96ffbf3a9bb2bf"><td class="memItemLeft" align="right" valign="top"><a id="ab68815986ef2a1b95f96ffbf3a9bb2bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SoftmaxWithLoss, <a class="el" href="classcaffe2_1_1SoftmaxWithLossOp.html">SoftmaxWithLossOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab68815986ef2a1b95f96ffbf3a9bb2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b83c6ed7b2c6a7e5828fbd2ceb419b"><td class="memItemLeft" align="right" valign="top"><a id="ae6b83c6ed7b2c6a7e5828fbd2ceb419b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SoftmaxWithLossGradient, <a class="el" href="classcaffe2_1_1SoftmaxWithLossGradientOp.html">SoftmaxWithLossGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae6b83c6ed7b2c6a7e5828fbd2ceb419b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6923dd503673e4a99b2d259489172209"><td class="memItemLeft" align="right" valign="top"><a id="a6923dd503673e4a99b2d259489172209"></a>
vector&lt; TensorShape &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>out</b> (2)</td></tr>
<tr class="separator:a6923dd503673e4a99b2d259489172209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6876a6c09b269f742ac40ad44fa22c17"><td class="memItemLeft" align="right" valign="top"><a id="a6876a6c09b269f742ac40ad44fa22c17"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>set_data_type</b> (logits.data_type())</td></tr>
<tr class="separator:a6876a6c09b269f742ac40ad44fa22c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08b9645e83c41b7e5887bf6ccabe3db"><td class="memItemLeft" align="right" valign="top"><a id="ad08b9645e83c41b7e5887bf6ccabe3db"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (batch_size)</td></tr>
<tr class="separator:ad08b9645e83c41b7e5887bf6ccabe3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae843583eef085c95eaaf039302d2becc"><td class="memItemLeft" align="right" valign="top"><a id="ae843583eef085c95eaaf039302d2becc"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (num_classes)</td></tr>
<tr class="separator:ae843583eef085c95eaaf039302d2becc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0825f19de4843ab725b79ffd0f612e92"><td class="memItemLeft" align="right" valign="top"><a id="a0825f19de4843ab725b79ffd0f612e92"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Combined Softmax and Cross-Entropy loss operator.
The operator computes the softmax normalized values for each layer in the batch
of the given input, after which cross-entropy loss is computed. This operator is
numerically more stable than separate Softmax and CrossEntropy ops.
The inputs are a 2-D tensor (<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt;float&gt;) of size
(batch_size x input_feature_dimensions) and tensor of labels (ground truth).
Output is tensor with the probability for each label for each example (N x D)
and averaged loss (scalar).
Use parameter label_prob=1 to enable inputting labels as a probability
distribution.
Optional third input blob can be used to weight the samples for the loss.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:a0825f19de4843ab725b79ffd0f612e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3fb25f85d3e76ad07a28223d2d3a11"><td class="memItemLeft" align="right" valign="top"><a id="a0f3fb25f85d3e76ad07a28223d2d3a11"></a>
Unscaled log probabilities&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;labels&quot;, &quot;Ground truth&quot;) .Input(2</td></tr>
<tr class="separator:a0f3fb25f85d3e76ad07a28223d2d3a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf4504a86e7127c2b3ed6ff9a0c867e"><td class="memItemLeft" align="right" valign="top"><a id="afaf4504a86e7127c2b3ed6ff9a0c867e"></a>
Unscaled log probabilities Optional blob to be used to weight the samples for the loss&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;softmax&quot;, &quot;<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> with softmax cross entropy loss&quot;) .Output(1</td></tr>
<tr class="separator:afaf4504a86e7127c2b3ed6ff9a0c867e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a735204b31b0d014e5562cea64a8198"><td class="memItemLeft" align="right" valign="top"><a id="a8a735204b31b0d014e5562cea64a8198"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (SoftmaxWithLossGradient).NumOutputs(1)</td></tr>
<tr class="separator:a8a735204b31b0d014e5562cea64a8198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38e74c82fca95c4524df696642fe77a"><td class="memItemLeft" align="right" valign="top"><a id="aa38e74c82fca95c4524df696642fe77a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Softplus, <a class="el" href="classcaffe2_1_1SoftplusOp.html">SoftplusOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa38e74c82fca95c4524df696642fe77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36000d81d5598901b3ce01b744e7487f"><td class="memItemLeft" align="right" valign="top"><a id="a36000d81d5598901b3ce01b744e7487f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SoftplusGradient, <a class="el" href="classcaffe2_1_1SoftplusGradientOp.html">SoftplusGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a36000d81d5598901b3ce01b744e7487f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ecfb1a5c9ef3e173961468e81760d8"><td class="memItemLeft" align="right" valign="top"><a id="a42ecfb1a5c9ef3e173961468e81760d8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Softplus, <a class="el" href="classcaffe2_1_1GetSoftplusGradient.html">GetSoftplusGradient</a>)</td></tr>
<tr class="separator:a42ecfb1a5c9ef3e173961468e81760d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7e77c5768d9f1402c417284babd4d5"><td class="memItemLeft" align="right" valign="top"><a id="afa7e77c5768d9f1402c417284babd4d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Softsign, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1SoftsignCPUFunctor.html">SoftsignCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:afa7e77c5768d9f1402c417284babd4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583cb57c1df5943595821d0dcb539829"><td class="memItemLeft" align="right" valign="top"><a id="a583cb57c1df5943595821d0dcb539829"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SoftsignGradient, <a class="el" href="classcaffe2_1_1BinaryElementwiseOp.html">BinaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1WithoutBroadcast.html">WithoutBroadcast</a>&lt; <a class="el" href="structcaffe2_1_1SoftsignGradientCPUFunctor.html">SoftsignGradientCPUFunctor</a> &gt;&gt;)</td></tr>
<tr class="separator:a583cb57c1df5943595821d0dcb539829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9116ef7019b0918159b356e1afdb47e8"><td class="memItemLeft" align="right" valign="top"><a id="a9116ef7019b0918159b356e1afdb47e8"></a>
by providing the same input and output blobs DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;input&quot;, &quot;1-D input tensor&quot;) .Output(0</td></tr>
<tr class="separator:a9116ef7019b0918159b356e1afdb47e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c247d49f96b66653645cac326dc74e"><td class="memItemLeft" align="right" valign="top"><a id="ae7c247d49f96b66653645cac326dc74e"></a>
by providing the same input and output blobs DOC The&#160;</td><td class="memItemRight" valign="bottom"><b>softsign</b> (x/1+|x|) values of the input tensor &quot; &quot;computed element-wise&quot;)</td></tr>
<tr class="separator:ae7c247d49f96b66653645cac326dc74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb141ed64ad6169f2f6acf59cc1c951c"><td class="memItemLeft" align="right" valign="top"><a id="abb141ed64ad6169f2f6acf59cc1c951c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Calculates the softsign gradient (sgn(x)/(1+|x|)^2) of the given input tensor
element-wise.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:abb141ed64ad6169f2f6acf59cc1c951c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01329b86a1424ad9198adff90c54c6b"><td class="memItemLeft" align="right" valign="top"><a id="ad01329b86a1424ad9198adff90c54c6b"></a>
D input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;input&quot;, &quot;1-D input tensor&quot;) .Output(0</td></tr>
<tr class="separator:ad01329b86a1424ad9198adff90c54c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567b32ed6d936d0dbdb5d8934f0ca608"><td class="memItemLeft" align="right" valign="top"><a id="a567b32ed6d936d0dbdb5d8934f0ca608"></a>
D input tensor The softsign&#160;</td><td class="memItemRight" valign="bottom"><b>gradient</b> (sgn(x)/(1+|x|)^2) values of the input tensor &quot; &quot;computed element-wise&quot;)</td></tr>
<tr class="separator:a567b32ed6d936d0dbdb5d8934f0ca608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9b1a4af9e42555e0b6b2920fdaf0f9"><td class="memItemLeft" align="right" valign="top"><a id="a9a9b1a4af9e42555e0b6b2920fdaf0f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Softsign, <a class="el" href="classcaffe2_1_1GetSoftsignGradient.html">GetSoftsignGradient</a>)</td></tr>
<tr class="separator:a9a9b1a4af9e42555e0b6b2920fdaf0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab420c1d380ece4ea2b2ceda61059caa9"><td class="memItemLeft" align="right" valign="top"><a id="ab420c1d380ece4ea2b2ceda61059caa9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SpaceToBatch, <a class="el" href="classcaffe2_1_1SpaceToBatchOp.html">SpaceToBatchOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab420c1d380ece4ea2b2ceda61059caa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91276e2e4a1d9d843dcedc1c0815935b"><td class="memItemLeft" align="right" valign="top"><a id="a91276e2e4a1d9d843dcedc1c0815935b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (SpaceToBatch).NumInputs(1).NumOutputs(1).SetDoc(R&quot;DOC( SpaceToBatch for 4-D tensors of type T. Zero-pads and then rearranges (permutes) blocks of spatial data into batch. More specifically</td></tr>
<tr class="separator:a91276e2e4a1d9d843dcedc1c0815935b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4af83599ba3c1b2ba3bf3ce8e3c933"><td class="memItemLeft" align="right" valign="top"><a id="a6c4af83599ba3c1b2ba3bf3ce8e3c933"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (BatchToSpace, <a class="el" href="classcaffe2_1_1BatchToSpaceOp.html">BatchToSpaceOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a6c4af83599ba3c1b2ba3bf3ce8e3c933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fcd57a5aed330c94ae56b2d6325ef2"><td class="memItemLeft" align="right" valign="top"><a id="a40fcd57a5aed330c94ae56b2d6325ef2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (BatchToSpace).NumInputs(1).NumOutputs(1).SetDoc(R&quot;DOC( BatchToSpace for 4-D tensors of type T. Rearranges (permutes) data from batch into blocks of spatial data</td></tr>
<tr class="separator:a40fcd57a5aed330c94ae56b2d6325ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040264084b11f8885462eabf2e448ccf"><td class="memItemLeft" align="right" valign="top"><a id="a040264084b11f8885462eabf2e448ccf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SpaceToBatch, <a class="el" href="classcaffe2_1_1GetSpaceToBatchGradient.html">GetSpaceToBatchGradient</a>)</td></tr>
<tr class="separator:a040264084b11f8885462eabf2e448ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99ac6250b0b0383f1ca68a59d853528"><td class="memItemLeft" align="right" valign="top"><a id="ae99ac6250b0b0383f1ca68a59d853528"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (BatchToSpace, <a class="el" href="classcaffe2_1_1GetBatchToSpaceGradient.html">GetBatchToSpaceGradient</a>)</td></tr>
<tr class="separator:ae99ac6250b0b0383f1ca68a59d853528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a66330ae07e769ba2997e4258bc880f"><td class="memTemplParams" colspan="2"><a id="a9a66330ae07e769ba2997e4258bc880f"></a>
template&lt;typename Context &gt; </td></tr>
<tr class="memitem:a9a66330ae07e769ba2997e4258bc880f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>spaceToBatch</b> (const <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; Context &gt; &amp;input, int pad_t, int pad_l, int block_size, <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; Context &gt; *output, Context *)</td></tr>
<tr class="separator:a9a66330ae07e769ba2997e4258bc880f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fbe16f3907d5fcaef2a1f394e6d11c"><td class="memTemplParams" colspan="2"><a id="ad1fbe16f3907d5fcaef2a1f394e6d11c"></a>
template&lt;typename Context &gt; </td></tr>
<tr class="memitem:ad1fbe16f3907d5fcaef2a1f394e6d11c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>batchToSpace</b> (const <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; Context &gt; &amp;input, int pad_t, int pad_l, int block_size, <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; Context &gt; *output, Context *)</td></tr>
<tr class="separator:ad1fbe16f3907d5fcaef2a1f394e6d11c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09acb13ce73b40a3605ef0995ed15260"><td class="memItemLeft" align="right" valign="top"><a id="a09acb13ce73b40a3605ef0995ed15260"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseToDense, <a class="el" href="classcaffe2_1_1SparseToDenseOp.html">SparseToDenseOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a09acb13ce73b40a3605ef0995ed15260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8453b21d0376a17441520bca0b99535"><td class="memItemLeft" align="right" valign="top"><a id="af8453b21d0376a17441520bca0b99535"></a>
value represented as indices vector and values tensor into a compacted tensor where the first dimension is determined by the first dimension of the input if it is given or the max index Missing values are filled with zeros The op supports duplicated indices and performs summation over corresponding values This behavior is useful for converting GradientSlices into dense representation After running this&#160;</td><td class="memItemRight" valign="bottom"><b>len</b> (mask)]+shape(default_value)`(if `lengths` is not provided the &quot; &quot;first dimension is omitted)&quot;)</td></tr>
<tr class="separator:af8453b21d0376a17441520bca0b99535"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e07bf5c8fe8cf9b4271e54079dbe7b"><td class="memItemLeft" align="right" valign="top"><a id="aa9e07bf5c8fe8cf9b4271e54079dbe7b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SpatialBNGradient, <a class="el" href="classcaffe2_1_1SpatialBNGradientOp.html">SpatialBNGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa9e07bf5c8fe8cf9b4271e54079dbe7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3265e966db5a02cd79e006c9558a8c4"><td class="memItemLeft" align="right" valign="top"><a id="ab3265e966db5a02cd79e006c9558a8c4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (SpatialBNGradient).NumInputs(5).NumOutputs(3)</td></tr>
<tr class="separator:ab3265e966db5a02cd79e006c9558a8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a270cc689758874f92fe7d28977027"><td class="memItemLeft" align="right" valign="top"><a id="a93a270cc689758874f92fe7d28977027"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SpatialBN, <a class="el" href="classcaffe2_1_1GetSpatialBNGradient.html">GetSpatialBNGradient</a>)</td></tr>
<tr class="separator:a93a270cc689758874f92fe7d28977027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4982d345187b05f9ad755a509398e7b0"><td class="memItemLeft" align="right" valign="top"><a id="a4982d345187b05f9ad755a509398e7b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SpatialBN, <a class="el" href="classcaffe2_1_1SpatialBNOp.html">SpatialBNOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4982d345187b05f9ad755a509398e7b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddf133cc0876b86b3e1a2bc4ef328a7"><td class="memItemLeft" align="right" valign="top"><a id="a8ddf133cc0876b86b3e1a2bc4ef328a7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (SpatialBN, <a class="el" href="classcaffe2_1_1CudnnSpatialBNOp.html">CudnnSpatialBNOp</a>)</td></tr>
<tr class="separator:a8ddf133cc0876b86b3e1a2bc4ef328a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c04e8b21a43bf7603be15aba8aa6b3"><td class="memItemLeft" align="right" valign="top"><a id="a33c04e8b21a43bf7603be15aba8aa6b3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (SpatialBNGradient, <a class="el" href="classcaffe2_1_1CudnnSpatialBNGradientOp.html">CudnnSpatialBNGradientOp</a>)</td></tr>
<tr class="separator:a33c04e8b21a43bf7603be15aba8aa6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bf15413f82143a3c040e975cc0f858"><td class="memItemLeft" align="right" valign="top"><a id="af4bf15413f82143a3c040e975cc0f858"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (SpatialBN, <a class="el" href="classcaffe2_1_1CudnnSpatialBNOp.html">CudnnSpatialBNOp</a>)</td></tr>
<tr class="separator:af4bf15413f82143a3c040e975cc0f858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b276d423f224f99a6058070a23779b"><td class="memItemLeft" align="right" valign="top"><a id="ad4b276d423f224f99a6058070a23779b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (SpatialBNGradient, <a class="el" href="classcaffe2_1_1CudnnSpatialBNGradientOp.html">CudnnSpatialBNGradientOp</a>)</td></tr>
<tr class="separator:ad4b276d423f224f99a6058070a23779b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9bcafb209f807b50be88e9a5709613"><td class="memItemLeft" align="right" valign="top"><a id="a3c9bcafb209f807b50be88e9a5709613"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SpatialSoftmaxWithLoss, <a class="el" href="classcaffe2_1_1SpatialSoftmaxWithLossOp.html">SpatialSoftmaxWithLossOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3c9bcafb209f807b50be88e9a5709613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6a5c55dc68fae54d5f4027159314b4"><td class="memItemLeft" align="right" valign="top"><a id="aed6a5c55dc68fae54d5f4027159314b4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SpatialSoftmaxWithLossGradient, <a class="el" href="classcaffe2_1_1SpatialSoftmaxWithLossGradientOp.html">SpatialSoftmaxWithLossGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aed6a5c55dc68fae54d5f4027159314b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7bd8f08453c3359bc855816705d7c5"><td class="memItemLeft" align="right" valign="top"><a id="aec7bd8f08453c3359bc855816705d7c5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_ENFORCE_EQ</b> (logits.dims_size(), 4)</td></tr>
<tr class="separator:aec7bd8f08453c3359bc855816705d7c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1f94dd12c0042a6b995dfaa75a026a"><td class="memItemLeft" align="right" valign="top"><a id="a3b1f94dd12c0042a6b995dfaa75a026a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_ENFORCE_EQ</b> (labels.dims_size(), 3)</td></tr>
<tr class="separator:a3b1f94dd12c0042a6b995dfaa75a026a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe456839e50c9318816b70298531303"><td class="memItemLeft" align="right" valign="top"><a id="a1fe456839e50c9318816b70298531303"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Combined Spatial Softmax and Cross-Entropy loss operator.
Similar to SoftmaxWithLoss, this operator computes the spatial softmax
normalized values for each layer in the batch of the given input, after which
cross-entropy loss is computed. This operator is numerically more stable than
separate Softmax and CrossEntropy ops. The inputs are a 2-D tensor
(<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt;float&gt;) of size (batch_size x input_feature_dimensions) and tensor of
labels (ground truth).
Output is tensor with the probability for each label in a pixel for each example
(N x D x W x H) and averaged loss (scalar).
For spatial softmax, weighting is by x,y position of the input.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:a1fe456839e50c9318816b70298531303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6460a1858caca6712da0ef4a4b70956"><td class="memItemLeft" align="right" valign="top"><a id="af6460a1858caca6712da0ef4a4b70956"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (SpatialSoftmaxWithLossGradient).NumOutputs(1)</td></tr>
<tr class="separator:af6460a1858caca6712da0ef4a4b70956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c3b548215e4cec56262725afda6b4c"><td class="memItemLeft" align="right" valign="top"><a id="ab0c3b548215e4cec56262725afda6b4c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SquareRootDivide, <a class="el" href="classcaffe2_1_1SquareRootDivideOp.html">SquareRootDivideOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab0c3b548215e4cec56262725afda6b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb72afa45c13fc89d6eaf103b15aa6e"><td class="memItemLeft" align="right" valign="top"><a id="abcb72afa45c13fc89d6eaf103b15aa6e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Given DATA tensor with first dimension N and SCALE vector of the same size N
produces an output tensor with same dimensions as DATA. Which consists of DATA
slices. i-th slice is divided by sqrt(SCALE[i]) elementwise. If SCALE[i] == 0
output slice is identical to the input one (no scaling)

Example:

  Data = [
    [2.0, 4.0],
    [9.0, 12.0]
  ]

  SCALE = [4, 9]

  OUTPUT = [
    [1.0, 2.0],
    [3.0, 4.0]
  ]

)DOC&quot;)</td></tr>
<tr class="separator:abcb72afa45c13fc89d6eaf103b15aa6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e55834dad0dcb118ea8da02d9d5d4b"><td class="memItemLeft" align="right" valign="top"><a id="af0e55834dad0dcb118ea8da02d9d5d4b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (SquareRootDivide, <a class="el" href="classcaffe2_1_1GetSquareRootDivideGradient.html">GetSquareRootDivideGradient</a>)</td></tr>
<tr class="separator:af0e55834dad0dcb118ea8da02d9d5d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947b928814ca9f64e4f32f3a7fee42d6"><td class="memItemLeft" align="right" valign="top"><a id="a947b928814ca9f64e4f32f3a7fee42d6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (StatRegistryCreate, <a class="el" href="classcaffe2_1_1StatRegistryCreateOp.html">StatRegistryCreateOp</a>)</td></tr>
<tr class="separator:a947b928814ca9f64e4f32f3a7fee42d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb1ebf8f3c49af26f704b0abcb55a9d"><td class="memItemLeft" align="right" valign="top"><a id="a9bb1ebf8f3c49af26f704b0abcb55a9d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (StatRegistryUpdate, <a class="el" href="classcaffe2_1_1StatRegistryUpdateOp.html">StatRegistryUpdateOp</a>)</td></tr>
<tr class="separator:a9bb1ebf8f3c49af26f704b0abcb55a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fcd969fdcee60b30fbc53cacde305ce"><td class="memItemLeft" align="right" valign="top"><a id="a4fcd969fdcee60b30fbc53cacde305ce"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (StatRegistryExport, <a class="el" href="classcaffe2_1_1StatRegistryExportOp.html">StatRegistryExportOp</a>)</td></tr>
<tr class="separator:a4fcd969fdcee60b30fbc53cacde305ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f762eed64a7875a6caae9f43fbe6b85"><td class="memItemLeft" align="right" valign="top"><a id="a6f762eed64a7875a6caae9f43fbe6b85"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TimerBegin, <a class="el" href="structcaffe2_1_1TimerBeginOp.html">TimerBeginOp</a>)</td></tr>
<tr class="separator:a6f762eed64a7875a6caae9f43fbe6b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73b9c12c10069e14de4781ef1ea0dae"><td class="memItemLeft" align="right" valign="top"><a id="ab73b9c12c10069e14de4781ef1ea0dae"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TimerEnd, <a class="el" href="structcaffe2_1_1TimerEndOp.html">TimerEndOp</a>)</td></tr>
<tr class="separator:ab73b9c12c10069e14de4781ef1ea0dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b3b697e874e1137d79248796227788"><td class="memItemLeft" align="right" valign="top"><a id="a49b3b697e874e1137d79248796227788"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TimerGetAndEnd, <a class="el" href="structcaffe2_1_1TimerGetAndEndOp.html">TimerGetAndEndOp</a>)</td></tr>
<tr class="separator:a49b3b697e874e1137d79248796227788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ec4b8457442b8958e7b79653dc6f47f"><td class="memItemLeft" align="right" valign="top"><a id="a0ec4b8457442b8958e7b79653dc6f47f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TimerGet, <a class="el" href="structcaffe2_1_1TimerGetOp.html">TimerGetOp</a>)</td></tr>
<tr class="separator:a0ec4b8457442b8958e7b79653dc6f47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0022af2abe4c0e36bd72218913c49d"><td class="memItemLeft" align="right" valign="top"><a id="afb0022af2abe4c0e36bd72218913c49d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CpuUtilizationReport, <a class="el" href="structcaffe2_1_1CpuUtilizationReportOp.html">CpuUtilizationReportOp</a>)</td></tr>
<tr class="separator:afb0022af2abe4c0e36bd72218913c49d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf96a77d3015c64e7bb57059a886d848"><td class="memItemLeft" align="right" valign="top"><a id="adf96a77d3015c64e7bb57059a886d848"></a>
or the global with the values of counters for the given keys DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;keys&quot;, &quot;1D string tensor with the key names to update.&quot;) .Input(1</td></tr>
<tr class="separator:adf96a77d3015c64e7bb57059a886d848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049c675a25f176645e3eaa364dd16cce"><td class="memItemLeft" align="right" valign="top"><a id="a049c675a25f176645e3eaa364dd16cce"></a>
or the global with the values of counters for the given keys DOC int64 tensor with the values to update&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (2, &quot;handle&quot;, &quot;If provided, update the given StatRegistry. &quot; &quot;Otherwise, update the global singleton.&quot;)</td></tr>
<tr class="separator:a049c675a25f176645e3eaa364dd16cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9443756c125e6febeca1ab05b64dd42"><td class="memItemLeft" align="right" valign="top"><a id="af9443756c125e6febeca1ab05b64dd42"></a>
If export values from given <a class="el" href="classcaffe2_1_1StatRegistry.html">StatRegistry</a> export values from the global singleton <a class="el" href="classcaffe2_1_1StatRegistry.html">StatRegistry</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;keys&quot;, &quot;1D string tensor with exported key names&quot;) .Output(1</td></tr>
<tr class="separator:af9443756c125e6febeca1ab05b64dd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa944bc70b6cd9c4860c0fa9d7d91274b"><td class="memItemLeft" align="right" valign="top"><a id="aa944bc70b6cd9c4860c0fa9d7d91274b"></a>
If export values from given <a class="el" href="classcaffe2_1_1StatRegistry.html">StatRegistry</a> export values from the global singleton <a class="el" href="classcaffe2_1_1StatRegistry.html">StatRegistry</a> int64 tensor with exported values&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (2, &quot;timestamps&quot;, &quot;The unix timestamp at counter retrieval.&quot;) .Arg(&quot;reset&quot;</td></tr>
<tr class="separator:aa944bc70b6cd9c4860c0fa9d7d91274b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833123932704a2dfdff5d9ff6558fa36"><td class="memItemLeft" align="right" valign="top"><a id="a833123932704a2dfdff5d9ff6558fa36"></a>
returning a pointer to it The timer is stopped by calling TimerEnd DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;counter_name&quot;, &quot;Name of the timer. If not provided, use output name.&quot;) .Output(0</td></tr>
<tr class="separator:a833123932704a2dfdff5d9ff6558fa36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1637a3c1ebd7f4da7373d2317de173ad"><td class="memItemLeft" align="right" valign="top"><a id="a1637a3c1ebd7f4da7373d2317de173ad"></a>
publishing a CAFFE_EVENT&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;timer&quot;, &quot;Pointer to timer, obtained from TimerBegin.&quot;)</td></tr>
<tr class="separator:a1637a3c1ebd7f4da7373d2317de173ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0de7265c683cb6494b066286433cf1"><td class="memItemLeft" align="right" valign="top"><a id="a4d0de7265c683cb6494b066286433cf1"></a>
Pointer to obtained from TimerBegin&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;nanos&quot;, &quot;nanoseconds in int64&quot;)</td></tr>
<tr class="separator:a4d0de7265c683cb6494b066286433cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8644d1d1376347b238ed080cecdebd29"><td class="memItemLeft" align="right" valign="top"><a id="a8644d1d1376347b238ed080cecdebd29"></a>
Delta in max CPU utilization in percentage as a float value&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;stats_name&quot;, &quot;String name of the stat entry holding CPU utilization&quot;)</td></tr>
<tr class="separator:a8644d1d1376347b238ed080cecdebd29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af853c31c48049e4fb29e79f4a7dd7b"><td class="memItemLeft" align="right" valign="top"><a id="a6af853c31c48049e4fb29e79f4a7dd7b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (<a class="el" href="classcaffe2_1_1TimerInstance.html">TimerInstance</a> *)</td></tr>
<tr class="separator:a6af853c31c48049e4fb29e79f4a7dd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a81ede51ee5a53b2ae755e010c7bbd1"><td class="memItemLeft" align="right" valign="top"><a id="a7a81ede51ee5a53b2ae755e010c7bbd1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1StatRegistry.html">caffe2::StatRegistry</a> &gt;)</td></tr>
<tr class="separator:a7a81ede51ee5a53b2ae755e010c7bbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9c44b3bbe9a0c7261d2fa150ed44f0"><td class="memItemLeft" align="right" valign="top"><a id="a3c9c44b3bbe9a0c7261d2fa150ed44f0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (StopGradient, <a class="el" href="classcaffe2_1_1StopGradientOp.html">StopGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3c9c44b3bbe9a0c7261d2fa150ed44f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5416f162e1b35ac3ad80d082f969816d"><td class="memItemLeft" align="right" valign="top"><a id="a5416f162e1b35ac3ad80d082f969816d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (1, 1) .NumOutputs(1</td></tr>
<tr class="separator:a5416f162e1b35ac3ad80d082f969816d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f3e2378b53644049d680b1e2eacf51"><td class="memItemLeft" align="right" valign="top"><a id="a17f3e2378b53644049d680b1e2eacf51"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (StopGradient)</td></tr>
<tr class="separator:a17f3e2378b53644049d680b1e2eacf51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43c511fa3130c7afe22940995b8b5f8"><td class="memItemLeft" align="right" valign="top"><a id="af43c511fa3130c7afe22940995b8b5f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (StopGradient, <a class="el" href="classcaffe2_1_1StopGradientOp.html">StopGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:af43c511fa3130c7afe22940995b8b5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79be8b7fdf68059a885842174018f40f"><td class="memItemLeft" align="right" valign="top"><a id="a79be8b7fdf68059a885842174018f40f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Summarize, <a class="el" href="classcaffe2_1_1SummarizeOp.html">SummarizeOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a79be8b7fdf68059a885842174018f40f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b921c69b4bd5a42b6eb478bd4c4a13"><td class="memItemLeft" align="right" valign="top"><a id="a47b921c69b4bd5a42b6eb478bd4c4a13"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Summarize computes four statistics of the input tensor (<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt;float&gt;)- min,
max, mean and standard deviation. The output will be written to a 1-D tensor of
size 4 if an output tensor is provided. Else, if the argument 'to_file' is
greater than 0, the values are written to a log file in the root folder.
)DOC&quot;) .Arg(&quot;to_file&quot;</td></tr>
<tr class="separator:a47b921c69b4bd5a42b6eb478bd4c4a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f5774a6fd2c2aa7ebb52eb15a965e4"><td class="memItemLeft" align="right" valign="top"><a id="aa9f5774a6fd2c2aa7ebb52eb15a965e4"></a>
default flag to indicate if the summarized statistics have to be written to a log file&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;data&quot;, &quot;The input data as <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt;float&gt;.&quot;) .Output(0</td></tr>
<tr class="separator:aa9f5774a6fd2c2aa7ebb52eb15a965e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557f680c65f7c60f730e3434de03a9d9"><td class="memItemLeft" align="right" valign="top"><a id="a557f680c65f7c60f730e3434de03a9d9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Summarize)</td></tr>
<tr class="separator:a557f680c65f7c60f730e3434de03a9d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aec7c0f131c2bf28b3a0630c6760ac4"><td class="memItemLeft" align="right" valign="top"><a id="a4aec7c0f131c2bf28b3a0630c6760ac4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Swish, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float, double &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1SwishCPUFunctor.html">SwishCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:a4aec7c0f131c2bf28b3a0630c6760ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973504de09e21e287f4c07e100ebc990"><td class="memItemLeft" align="right" valign="top"><a id="a973504de09e21e287f4c07e100ebc990"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SwishGradient, <a class="el" href="classcaffe2_1_1SwishGradientOp.html">SwishGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a973504de09e21e287f4c07e100ebc990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f588c2b952bc81bdb006316f4d7445"><td class="memItemLeft" align="right" valign="top"><a id="a74f588c2b952bc81bdb006316f4d7445"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
SwishGradient takes X, Y and dY and uses this to update dX according to the
chain rule and derivatives of the swish function.
)DOC&quot;)</td></tr>
<tr class="separator:a74f588c2b952bc81bdb006316f4d7445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef8e2c5ad3aef552dd397e80a117924"><td class="memItemLeft" align="right" valign="top"><a id="a0ef8e2c5ad3aef552dd397e80a117924"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Swish, <a class="el" href="classcaffe2_1_1GetSwishGradient.html">GetSwishGradient</a>)</td></tr>
<tr class="separator:a0ef8e2c5ad3aef552dd397e80a117924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bef3f22f81ae817a37dabf500d8f22"><td class="memItemLeft" align="right" valign="top"><a id="aa7bef3f22f81ae817a37dabf500d8f22"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Tanh, <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">UnaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1TanhCPUFunctor.html">TanhCPUFunctor</a> &gt;)</td></tr>
<tr class="separator:aa7bef3f22f81ae817a37dabf500d8f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7b7293014acde03f55c62415e4fac1"><td class="memItemLeft" align="right" valign="top"><a id="a5a7b7293014acde03f55c62415e4fac1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TanhGradient, <a class="el" href="classcaffe2_1_1BinaryElementwiseOp.html">BinaryElementwiseOp</a>&lt; <a class="el" href="structcaffe2_1_1TensorTypes.html">TensorTypes</a>&lt; float &gt;, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="structcaffe2_1_1WithoutBroadcast.html">WithoutBroadcast</a>&lt; <a class="el" href="structcaffe2_1_1TanhGradientCPUFunctor.html">TanhGradientCPUFunctor</a> &gt;&gt;)</td></tr>
<tr class="separator:a5a7b7293014acde03f55c62415e4fac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f137244053c2518bf8b36b129a2e9ee"><td class="memItemLeft" align="right" valign="top"><a id="a3f137244053c2518bf8b36b129a2e9ee"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (TanhGradient).NumInputs(2).NumOutputs(1).AllowInplace(</td></tr>
<tr class="separator:a3f137244053c2518bf8b36b129a2e9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee5d1c143195645494061c4633bd99c"><td class="memItemLeft" align="right" valign="top"><a id="acee5d1c143195645494061c4633bd99c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Tanh, <a class="el" href="classcaffe2_1_1GetTanhGradient.html">GetTanhGradient</a>)</td></tr>
<tr class="separator:acee5d1c143195645494061c4633bd99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219c46db626227d4ff918d046d71f6de"><td class="memItemLeft" align="right" valign="top"><a id="a219c46db626227d4ff918d046d71f6de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (<a class="el" href="classcaffe2_1_1TensorProtosDBInput.html">TensorProtosDBInput</a>, <a class="el" href="classcaffe2_1_1TensorProtosDBInput.html">TensorProtosDBInput</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a219c46db626227d4ff918d046d71f6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168dcc5c6601c8fcad459e826acbf700"><td class="memItemLeft" align="right" valign="top"><a id="a168dcc5c6601c8fcad459e826acbf700"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
<a class="el" href="classcaffe2_1_1TensorProtosDBInput.html">TensorProtosDBInput</a> is a simple input operator that basically reads things
from a db where each key-value pair stores an index as key, and a TensorProtos
object as value. These TensorProtos objects should have the same size, and they
will be grouped into batches of the given size. The <a class="el" href="classcaffe2_1_1db_1_1DB.html">DB</a> Reader is provided as
input to the operator and it returns as many output tensors as the size of the
TensorProtos object. Each output will simply be a tensor containing a batch of
data with size specified by the 'batch_size' argument containing data from the
corresponding index in the TensorProtos objects in the DB.
)DOC&quot;) .Arg(&quot;batch_size&quot;</td></tr>
<tr class="separator:a168dcc5c6601c8fcad459e826acbf700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7573f9ef2053e83d4dacf7d66bc01b0"><td class="memItemLeft" align="right" valign="top"><a id="ab7573f9ef2053e83d4dacf7d66bc01b0"></a>
INT_MAX default the number of samples in a batch The default value of means that the&#160;</td><td class="memItemRight" valign="bottom"><b>operator will attempt to insert the &quot; &quot;entire data in a single output blob.&quot;) .Input</b> (0, &quot;data&quot;, &quot;A pre-initialized <a class="el" href="classcaffe2_1_1db_1_1DB.html">DB</a> reader. Typically, this is obtained &quot; &quot;by calling CreateDB operator with a db_name and a db_type. The &quot; &quot;resulting output blob is a <a class="el" href="classcaffe2_1_1db_1_1DB.html">DB</a> Reader tensor&quot;) .Output(0</td></tr>
<tr class="separator:ab7573f9ef2053e83d4dacf7d66bc01b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8c4ae59099fe6ae9f4e80b961d3e7b"><td class="memItemLeft" align="right" valign="top"><a id="aee8c4ae59099fe6ae9f4e80b961d3e7b"></a>
INT_MAX default the number of samples in a batch The default value of means that the The output tensor in which the batches of data are returned The number of output tensors is equal to the size&#160;</td><td class="memItemRight" valign="bottom"><b>of</b> (number of TensorProto 's in) the TensorProtos objects stored in the &quot; &quot;<a class="el" href="classcaffe2_1_1db_1_1DB.html">DB</a> as values. Each output tensor will be of size specified by the &quot; &quot; 'batch_size' argument of the operator&quot;)</td></tr>
<tr class="separator:aee8c4ae59099fe6ae9f4e80b961d3e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92e600afc08d689214d6599a487711c"><td class="memItemLeft" align="right" valign="top"><a id="ae92e600afc08d689214d6599a487711c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (<a class="el" href="classcaffe2_1_1TensorProtosDBInput.html">TensorProtosDBInput</a>)</td></tr>
<tr class="separator:ae92e600afc08d689214d6599a487711c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7232ef46b5b3aec6fc354c6a405a69fe"><td class="memItemLeft" align="right" valign="top"><a id="a7232ef46b5b3aec6fc354c6a405a69fe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (<a class="el" href="classcaffe2_1_1TensorProtosDBInput.html">TensorProtosDBInput</a>, <a class="el" href="classcaffe2_1_1TensorProtosDBInput.html">TensorProtosDBInput</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a7232ef46b5b3aec6fc354c6a405a69fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8e805d96f97616cd7c18e7d907e68b"><td class="memItemLeft" align="right" valign="top"><a id="ada8e805d96f97616cd7c18e7d907e68b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>convert</b> (TensorProto_DataType dst_type, const char *src_start, const char *src_end, void *dst)</td></tr>
<tr class="separator:ada8e805d96f97616cd7c18e7d907e68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56b6d215becf9a310049b4bb853f3a2"><td class="memItemLeft" align="right" valign="top"><a id="ab56b6d215becf9a310049b4bb853f3a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::unique_ptr&lt; <a class="el" href="structcaffe2_1_1TextFileReaderInstance.html">TextFileReaderInstance</a> &gt;)</td></tr>
<tr class="separator:ab56b6d215becf9a310049b4bb853f3a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9ee50ab7d20684506fa4dcbda07ed6"><td class="memItemLeft" align="right" valign="top"><a id="adf9ee50ab7d20684506fa4dcbda07ed6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CreateTextFileReader, <a class="el" href="classcaffe2_1_1CreateTextFileReaderOp.html">CreateTextFileReaderOp</a>)</td></tr>
<tr class="separator:adf9ee50ab7d20684506fa4dcbda07ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfbe745c880086940762dea36c1e2a9"><td class="memItemLeft" align="right" valign="top"><a id="a5cfbe745c880086940762dea36c1e2a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TextFileReaderRead, <a class="el" href="classcaffe2_1_1TextFileReaderReadOp.html">TextFileReaderReadOp</a>)</td></tr>
<tr class="separator:a5cfbe745c880086940762dea36c1e2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fbbcd6c77c6d64920e51047034ba85"><td class="memItemLeft" align="right" valign="top"><a id="a73fbbcd6c77c6d64920e51047034ba85"></a>
Path to the file&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;num_passes&quot;, &quot;Number of passes over the file.&quot;) .Arg(&quot;field_types&quot;</td></tr>
<tr class="separator:a73fbbcd6c77c6d64920e51047034ba85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79b0bb50478a1c25fb09478a05d229a"><td class="memItemLeft" align="right" valign="top"><a id="ab79b0bb50478a1c25fb09478a05d229a"></a>
Path to the file List with type of each field Type enum is found at core DataType&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;handler&quot;, &quot;Pointer to the created TextFileReaderInstance.&quot;)</td></tr>
<tr class="separator:ab79b0bb50478a1c25fb09478a05d229a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b93c839e72c81ab685935b11d6ecda"><td class="memItemLeft" align="right" valign="top"><a id="ac6b93c839e72c81ab685935b11d6ecda"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (&quot;Read a batch of rows from the given text file reader instance. &quot; &quot;Expects the number of fields to be equal to the number of outputs. &quot; &quot;Each output is a 1D tensor containing the values for the given field &quot; &quot;for each row. When end of file is reached, returns empty tensors.&quot;) .Input(0</td></tr>
<tr class="separator:ac6b93c839e72c81ab685935b11d6ecda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4fd9d7352691bf8ef1d4f13374025e"><td class="memItemLeft" align="right" valign="top"><a id="a5e4fd9d7352691bf8ef1d4f13374025e"></a>
INT_MAX Pointer to an existing <a class="el" href="structcaffe2_1_1TextFileReaderInstance.html">TextFileReaderInstance</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;batch_size&quot;, &quot;Maximum number of rows to read.&quot;)</td></tr>
<tr class="separator:a5e4fd9d7352691bf8ef1d4f13374025e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a2b51625c32a85bb9d121d9a2bf0e8"><td class="memItemLeft" align="right" valign="top"><a id="ae2a2b51625c32a85bb9d121d9a2bf0e8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (CreateTextFileReader)</td></tr>
<tr class="separator:ae2a2b51625c32a85bb9d121d9a2bf0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0caaac7cf5c9d7e053638babf99bdbe"><td class="memItemLeft" align="right" valign="top"><a id="ab0caaac7cf5c9d7e053638babf99bdbe"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (TextFileReaderRead)</td></tr>
<tr class="separator:ab0caaac7cf5c9d7e053638babf99bdbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced5b04811dbf39ebcee085bb455bfd7"><td class="memItemLeft" align="right" valign="top"><a id="aced5b04811dbf39ebcee085bb455bfd7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Tile, <a class="el" href="classcaffe2_1_1TileOp.html">TileOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aced5b04811dbf39ebcee085bb455bfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8c74805ca38dba5dc29a0af8841557"><td class="memItemLeft" align="right" valign="top"><a id="a0f8c74805ca38dba5dc29a0af8841557"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TileGradient, <a class="el" href="classcaffe2_1_1TileGradientOp.html">TileGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a0f8c74805ca38dba5dc29a0af8841557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8de859c4ec2e626d5d90104874cef4b"><td class="memItemLeft" align="right" valign="top"><a id="ad8de859c4ec2e626d5d90104874cef4b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (1, 3) .NumOutputs(1) .TensorInferenceFunction([](const OperatorDef &amp;def</td></tr>
<tr class="separator:ad8de859c4ec2e626d5d90104874cef4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568d4a61e2de1126edd7197cf1e12bb0"><td class="memItemLeft" align="right" valign="top"><a id="a568d4a61e2de1126edd7197cf1e12bb0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (in.size() &gt; 1)</td></tr>
<tr class="separator:a568d4a61e2de1126edd7197cf1e12bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd9f711f18cdae6e15ba981a252ef93"><td class="memItemLeft" align="right" valign="top"><a id="a0fd9f711f18cdae6e15ba981a252ef93"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>set_dims</b> (canonical_axis, out[0].dims().Get(canonical_axis) *tiles)</td></tr>
<tr class="separator:a0fd9f711f18cdae6e15ba981a252ef93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49879c1767e9375a616da520542fcd20"><td class="memItemLeft" align="right" valign="top"><a id="a49879c1767e9375a616da520542fcd20"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Constructs a tensor by tiling a given tensor along a specified axis.

This operation creates a new tensor by replicating the input tensor 'tiles'
times along dimension 'axis'. The output tensor's 'axis'th dimension has
input.dims(axis) * tiles elements, and the values of input are replicated
'tiles' times along the 'axis'th dimension.
For example, tiling  by tile=2, axis=0 produces
.
)DOC&quot;) .Arg(&quot;tiles&quot;</td></tr>
<tr class="separator:a49879c1767e9375a616da520542fcd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc701e48cf028188e93a7cbabb151917"><td class="memItemLeft" align="right" valign="top"><a id="abc701e48cf028188e93a7cbabb151917"></a>
Number of replicas&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;axis&quot;, &quot;Axis to replicate along&quot;) .Input(0</td></tr>
<tr class="separator:abc701e48cf028188e93a7cbabb151917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ccbb825af5f5deee1325135cbf93e2"><td class="memItemLeft" align="right" valign="top"><a id="a73ccbb825af5f5deee1325135cbf93e2"></a>
Number of replicas The input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;tiles&quot;, &quot;(optional) Number of replicas (overrides argument)&quot;) .Input(2</td></tr>
<tr class="separator:a73ccbb825af5f5deee1325135cbf93e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36426f3160b822cda69b21b2bc4bbff7"><td class="memItemLeft" align="right" valign="top"><a id="a36426f3160b822cda69b21b2bc4bbff7"></a>
Number of replicas The input tensor optional Axis to replicate&#160;</td><td class="memItemRight" valign="bottom"><b>along</b> (overrides argument)&quot;) .Output( 0</td></tr>
<tr class="separator:a36426f3160b822cda69b21b2bc4bbff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b19f8c7e52f0be20be3e3ac9b79499f"><td class="memItemLeft" align="right" valign="top"><a id="a0b19f8c7e52f0be20be3e3ac9b79499f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (TileGradient).NumInputs(1</td></tr>
<tr class="separator:a0b19f8c7e52f0be20be3e3ac9b79499f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bc48b2c0bac2dfd8465141227acdbf"><td class="memItemLeft" align="right" valign="top"><a id="aa5bc48b2c0bac2dfd8465141227acdbf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumOutputs</b> (1)</td></tr>
<tr class="separator:aa5bc48b2c0bac2dfd8465141227acdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf75898e19a1c52e1528eb3440a208de"><td class="memItemLeft" align="right" valign="top"><a id="adf75898e19a1c52e1528eb3440a208de"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Tile, <a class="el" href="classcaffe2_1_1GetTileGradient.html">GetTileGradient</a>)</td></tr>
<tr class="separator:adf75898e19a1c52e1528eb3440a208de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b28296fcf9749bca35b17dbfc2a2ba1"><td class="memItemLeft" align="right" valign="top"><a id="a4b28296fcf9749bca35b17dbfc2a2ba1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TopK, <a class="el" href="classcaffe2_1_1TopKOp.html">TopKOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4b28296fcf9749bca35b17dbfc2a2ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990b405ba4c8182efbaea6a6905633e2"><td class="memItemLeft" align="right" valign="top"><a id="a990b405ba4c8182efbaea6a6905633e2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (TopKGradient, <a class="el" href="classcaffe2_1_1TopKGradientOp.html">TopKGradientOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a990b405ba4c8182efbaea6a6905633e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb453bf870992dae18192829f6daeefc"><td class="memItemLeft" align="right" valign="top"><a id="acb453bf870992dae18192829f6daeefc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> ([](const OperatorDef &amp;def, const vector&lt; TensorShape &gt; &amp;in) { vector&lt; TensorShape &gt; out={in[0], in[0]};<a class="el" href="classcaffe2_1_1ArgumentHelper.html">ArgumentHelper</a> helper(def);auto k=helper.GetSingleArgument(&quot;k&quot;, -1);auto dims_size=in[0].dims_size();out[0].set_dims(dims_size - 1, k);out[1].set_dims(dims_size - 1, k);out[1].set_data_type(TensorProto_DataType_INT32);if(def.output_size() &gt; 2) { TensorShape flatten_indices_shape;flatten_indices_shape.set_data_type(TensorProto_DataType_INT32);flatten_indices_shape.add_dims(std::accumulate(in[0].dims().begin(), in[0].dims().end() - 1, 1, std::multiplies&lt; long &gt;()) *k);out.push_back(flatten_indices_shape);} return out;}) .SetDoc(R&quot;DOC( Retrieve the top-K elements for the last dimension. Given an input tensor of shape [a_1</td></tr>
<tr class="separator:acb453bf870992dae18192829f6daeefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638d9ffa47f1717a0217914b25126c1d"><td class="memItemLeft" align="right" valign="top"><a id="a638d9ffa47f1717a0217914b25126c1d"></a>
r and integer argument return two k which contains the values of the top k elements along the last dimension <a class="el" href="structcaffe2_1_1Index.html">Index</a> tensor of shape [a_1, a_2,..., a_n, k] which contains the indices of the top k&#160;</td><td class="memItemRight" valign="bottom"><b>elements</b> (original indices from the input tensor). Given two equivalent values</td></tr>
<tr class="separator:a638d9ffa47f1717a0217914b25126c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458ff0b5d7d00cd6ae4c5d62bffb2b34"><td class="memItemLeft" align="right" valign="top"><a id="a458ff0b5d7d00cd6ae4c5d62bffb2b34"></a>
r and integer argument return two k which contains the values of the top k elements along the last dimension <a class="el" href="structcaffe2_1_1Index.html">Index</a> tensor of shape [a_1, a_2,..., a_n, k] which contains the indices of the top k this&#160;</td><td class="memItemRight" valign="bottom"><b>operator uses the indices along the last dim- ension as a tiebreaker. That is, the element with the lower index will appear first.) DOC&quot;) .Input</b> (0, &quot;X&quot;, &quot;<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> of shape [a_1, a_2, ..., a_n, r]&quot;) .Output(0</td></tr>
<tr class="separator:a458ff0b5d7d00cd6ae4c5d62bffb2b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a981d93cbf13830eff8b1c9affd685"><td class="memItemLeft" align="right" valign="top"><a id="a92a981d93cbf13830eff8b1c9affd685"></a>
r and integer argument return two k which contains the values of the top k elements along the last dimension <a class="el" href="structcaffe2_1_1Index.html">Index</a> tensor of shape [a_1, a_2,..., a_n, k] which contains the indices of the top k this <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> of shape [a_1, a_2,..., a_n, k] containing top K values from the input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1, &quot;Indices&quot;, &quot;<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> of shape [a_1, a_2, ..., a_n, k] containing&quot; &quot; the corresponding input tensor indices for the top K values.&quot;) .Output(2</td></tr>
<tr class="separator:a92a981d93cbf13830eff8b1c9affd685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9cee5bbd45cb01621ae7e3e9947e68"><td class="memItemLeft" align="right" valign="top"><a id="a2e9cee5bbd45cb01621ae7e3e9947e68"></a>
r and integer argument return two k which contains the values of the top k elements along the last dimension <a class="el" href="structcaffe2_1_1Index.html">Index</a> tensor of shape [a_1, a_2,..., a_n, k] which contains the indices of the top k this <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> of shape [a_1, a_2,..., a_n, k] containing top K values from the input tensor Flatten <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> of shape [a_1 *a_2 *... *a_n *k] containing the indices into the flatten input&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;k&quot;, &quot;Number of top elements to retrieve&quot;)</td></tr>
<tr class="separator:a2e9cee5bbd45cb01621ae7e3e9947e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc3da3e59a50ff7ae720341129e89b7"><td class="memItemLeft" align="right" valign="top"><a id="affc3da3e59a50ff7ae720341129e89b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (TopKGradient).NumInputs(3).NumOutputs(1)</td></tr>
<tr class="separator:affc3da3e59a50ff7ae720341129e89b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33c32b9ceb4778f282b50465e3687fa"><td class="memItemLeft" align="right" valign="top"><a id="af33c32b9ceb4778f282b50465e3687fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (TopK, <a class="el" href="classcaffe2_1_1GetTopKGradient.html">GetTopKGradient</a>)</td></tr>
<tr class="separator:af33c32b9ceb4778f282b50465e3687fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0487b1160adba1852af6eef9181d7f"><td class="memItemLeft" align="right" valign="top"><a id="adf0487b1160adba1852af6eef9181d7f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Transpose, <a class="el" href="classcaffe2_1_1TransposeOp.html">TransposeOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:adf0487b1160adba1852af6eef9181d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f489cfb91e4c05e08ba01fc596af21a"><td class="memItemLeft" align="right" valign="top"><a id="a4f489cfb91e4c05e08ba01fc596af21a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (axes.empty())</td></tr>
<tr class="separator:a4f489cfb91e4c05e08ba01fc596af21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb6b0665bf1eb93e58b29000fbe057a"><td class="memItemLeft" align="right" valign="top"><a id="abbb6b0665bf1eb93e58b29000fbe057a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_ENFORCE</b> (valid_axes, &quot;Axes argument passed in had invalid values&quot;)</td></tr>
<tr class="separator:abbb6b0665bf1eb93e58b29000fbe057a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1344e0f4340cecc51c044fe562d8c"><td class="memItemLeft" align="right" valign="top"><a id="a32b1344e0f4340cecc51c044fe562d8c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_ENFORCE</b> (axes.size()==tensor_size, &quot;Axes argument passed in had the incorrect size&quot;)</td></tr>
<tr class="separator:a32b1344e0f4340cecc51c044fe562d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b6dc9376693decba7be1f0205be8a2"><td class="memItemLeft" align="right" valign="top"><a id="ad1b6dc9376693decba7be1f0205be8a2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>for</b> (auto axis=axes.begin();axis !=axes.end();++axis)</td></tr>
<tr class="separator:ad1b6dc9376693decba7be1f0205be8a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef373055c279e8615846f4d260412761"><td class="memItemLeft" align="right" valign="top"><a id="aef373055c279e8615846f4d260412761"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Transpose the input tensor similar to numpy.transpose. For example, when
axes=(1, 0, 2), given an input tensor of shape (1, 2, 3), the output shape
will be (2, 1, 3).
)DOC&quot;) .Arg(&quot;axes&quot;</td></tr>
<tr class="separator:aef373055c279e8615846f4d260412761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8886b5fffc193adc7678c913d0739052"><td class="memItemLeft" align="right" valign="top"><a id="a8886b5fffc193adc7678c913d0739052"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (Transpose, <a class="el" href="classcaffe2_1_1GetTransposeGradient.html">GetTransposeGradient</a>)</td></tr>
<tr class="separator:a8886b5fffc193adc7678c913d0739052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f4078c9362f6abbf685aa1c1b5ca9c"><td class="memItemLeft" align="right" valign="top"><a id="a10f4078c9362f6abbf685aa1c1b5ca9c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDNN_OPERATOR</b> (Transpose, <a class="el" href="classcaffe2_1_1CuDNNTransposeOp.html">CuDNNTransposeOp</a>)</td></tr>
<tr class="separator:a10f4078c9362f6abbf685aa1c1b5ca9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9988f946e01a8bde14f466b0fc2fa5f"><td class="memTemplParams" colspan="2"><a id="ae9988f946e01a8bde14f466b0fc2fa5f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae9988f946e01a8bde14f466b0fc2fa5f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TransposeCUDA</b> (vector&lt; int &gt; &amp;axes, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &amp;context, const <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt; &amp;input, <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt; *output, <a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> &amp;buffer_cpu, <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt; &amp;buffer)</td></tr>
<tr class="separator:ae9988f946e01a8bde14f466b0fc2fa5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b46540691eb1afcf1547e3a91b57a5"><td class="memItemLeft" align="right" valign="top"><a id="ae4b46540691eb1afcf1547e3a91b57a5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (WallClockTime, <a class="el" href="classcaffe2_1_1WallClockTimeOp.html">WallClockTimeOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae4b46540691eb1afcf1547e3a91b57a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89258398f3cc3618d00035f0230dd47"><td class="memItemLeft" align="right" valign="top"><a id="ad89258398f3cc3618d00035f0230dd47"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Print, <a class="el" href="classcaffe2_1_1PrintOp.html">PrintOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad89258398f3cc3618d00035f0230dd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520ac7ca6bb4e5c58248527effc9755c"><td class="memItemLeft" align="right" valign="top"><a id="a520ac7ca6bb4e5c58248527effc9755c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (FlattenToVec, <a class="el" href="classcaffe2_1_1FlattenToVecOp.html">FlattenToVecOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a520ac7ca6bb4e5c58248527effc9755c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33a021e8766ed8a069056a5fef6a219"><td class="memItemLeft" align="right" valign="top"><a id="ab33a021e8766ed8a069056a5fef6a219"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Alias, <a class="el" href="classcaffe2_1_1AliasOp.html">AliasOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab33a021e8766ed8a069056a5fef6a219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99c902c10fcc4c740225d2e92d23ac4"><td class="memItemLeft" align="right" valign="top"><a id="ac99c902c10fcc4c740225d2e92d23ac4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ResizeLike, <a class="el" href="classcaffe2_1_1ResizeLikeOp.html">ResizeLikeOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ac99c902c10fcc4c740225d2e92d23ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c5967b5a9c33819f0d47045f7fed6d"><td class="memItemLeft" align="right" valign="top"><a id="ad1c5967b5a9c33819f0d47045f7fed6d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SumInt, <a class="el" href="classcaffe2_1_1SumOp.html">SumOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad1c5967b5a9c33819f0d47045f7fed6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177ef4037d8a1560bd61c47798c4a078"><td class="memItemLeft" align="right" valign="top"><a id="a177ef4037d8a1560bd61c47798c4a078"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (WeightedSum, <a class="el" href="classcaffe2_1_1WeightedSumOp.html">WeightedSumOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a177ef4037d8a1560bd61c47798c4a078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fce6d9f20ad9b777c83ff28add34965"><td class="memItemLeft" align="right" valign="top"><a id="a4fce6d9f20ad9b777c83ff28add34965"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (WeightedSumGradient, <a class="el" href="classcaffe2_1_1WeightedSumGradientOp.html">WeightedSumGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4fce6d9f20ad9b777c83ff28add34965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbfff336193d2ecb5fa64f5a36cf434"><td class="memItemLeft" align="right" valign="top"><a id="a8cbfff336193d2ecb5fa64f5a36cf434"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ScatterWeightedSum, <a class="el" href="classcaffe2_1_1ScatterWeightedSumOp.html">ScatterWeightedSumOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a8cbfff336193d2ecb5fa64f5a36cf434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046774787ee2fa03fc8c3285426e2520"><td class="memItemLeft" align="right" valign="top"><a id="a046774787ee2fa03fc8c3285426e2520"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ScatterAssign, <a class="el" href="classcaffe2_1_1ScatterAssignOp.html">ScatterAssignOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a046774787ee2fa03fc8c3285426e2520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccb1145c431471e3eef480fc3dedd18"><td class="memItemLeft" align="right" valign="top"><a id="a6ccb1145c431471e3eef480fc3dedd18"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (EnsureCPUOutput, <a class="el" href="classcaffe2_1_1CopyOp.html">CopyOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a6ccb1145c431471e3eef480fc3dedd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31f258716b43bd475dc13f904120f9f"><td class="memItemLeft" align="right" valign="top"><a id="af31f258716b43bd475dc13f904120f9f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CopyFromCPUInput, <a class="el" href="classcaffe2_1_1CopyOp.html">CopyOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af31f258716b43bd475dc13f904120f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6d36b3549f883e3cd6e53b36ba1a94"><td class="memItemLeft" align="right" valign="top"><a id="a5f6d36b3549f883e3cd6e53b36ba1a94"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CopyOnDeviceLike, <a class="el" href="classcaffe2_1_1CopyOnDeviceLikeOp.html">CopyOnDeviceLikeOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a5f6d36b3549f883e3cd6e53b36ba1a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8819d12f475637364ebbe942e8a3e1bf"><td class="memItemLeft" align="right" valign="top"><a id="a8819d12f475637364ebbe942e8a3e1bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Copy, <a class="el" href="classcaffe2_1_1CopyOp.html">CopyOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a8819d12f475637364ebbe942e8a3e1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815977f8c140f506d4fc3792180a1d43"><td class="memItemLeft" align="right" valign="top"><a id="a815977f8c140f506d4fc3792180a1d43"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsToShape, <a class="el" href="classcaffe2_1_1LengthsToShapeOp.html">LengthsToShapeOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a815977f8c140f506d4fc3792180a1d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b807d8754dc2e4cb8eb0888b87c21e"><td class="memItemLeft" align="right" valign="top"><a id="a85b807d8754dc2e4cb8eb0888b87c21e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (HasElements, <a class="el" href="classcaffe2_1_1HasElementsOp.html">HasElementsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a85b807d8754dc2e4cb8eb0888b87c21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4b03b3eeecbe0cc9e4804846d8a691"><td class="memItemLeft" align="right" valign="top"><a id="a3c4b03b3eeecbe0cc9e4804846d8a691"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (IsEmpty, <a class="el" href="classcaffe2_1_1IsEmptyOp.html">IsEmptyOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3c4b03b3eeecbe0cc9e4804846d8a691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e76112be57bae9b1bd0c999bce8b18"><td class="memItemLeft" align="right" valign="top"><a id="af3e76112be57bae9b1bd0c999bce8b18"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Gather, <a class="el" href="classcaffe2_1_1GatherOp.html">GatherOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af3e76112be57bae9b1bd0c999bce8b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77929d08f345c156764caa27cd657179"><td class="memItemLeft" align="right" valign="top"><a id="a77929d08f345c156764caa27cd657179"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (GatherRanges, <a class="el" href="classcaffe2_1_1GatherRangesOp.html">GatherRangesOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a77929d08f345c156764caa27cd657179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd98b44084f36957d000676d1a9c92a9"><td class="memItemLeft" align="right" valign="top"><a id="acd98b44084f36957d000676d1a9c92a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsGather, <a class="el" href="classcaffe2_1_1LengthsGatherOp.html">LengthsGatherOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:acd98b44084f36957d000676d1a9c92a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9625fbfbca8dffa2b0b5523a796a61"><td class="memItemLeft" align="right" valign="top"><a id="afc9625fbfbca8dffa2b0b5523a796a61"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Unique, <a class="el" href="classcaffe2_1_1UniqueOp.html">UniqueOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:afc9625fbfbca8dffa2b0b5523a796a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814526a9f15708d215ba04a8a89173f8"><td class="memItemLeft" align="right" valign="top"><a id="a814526a9f15708d215ba04a8a89173f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsToSegmentIds, <a class="el" href="classcaffe2_1_1LengthsToSegmentIdsOp.html">LengthsToSegmentIdsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a814526a9f15708d215ba04a8a89173f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2775339e1ddc54710638bb4be2307b4"><td class="memItemLeft" align="right" valign="top"><a id="ad2775339e1ddc54710638bb4be2307b4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsToRanges, <a class="el" href="classcaffe2_1_1LengthsToRangesOp.html">LengthsToRangesOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad2775339e1ddc54710638bb4be2307b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64450dcd999e7cd2ca206f6c5c74f54"><td class="memItemLeft" align="right" valign="top"><a id="ad64450dcd999e7cd2ca206f6c5c74f54"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SegmentIdsToLengths, <a class="el" href="classcaffe2_1_1SegmentIdsToLengthsOp.html">SegmentIdsToLengthsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad64450dcd999e7cd2ca206f6c5c74f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48089cf88fff8b981d2a274ca69fb3bb"><td class="memItemLeft" align="right" valign="top"><a id="a48089cf88fff8b981d2a274ca69fb3bb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SegmentIdsToRanges, <a class="el" href="classcaffe2_1_1SegmentIdsToRangesOp.html">SegmentIdsToRangesOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a48089cf88fff8b981d2a274ca69fb3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af56d34cf4fe5bc72c7f4ef5b16bfa5ca"><td class="memItemLeft" align="right" valign="top"><a id="af56d34cf4fe5bc72c7f4ef5b16bfa5ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LengthsToWeights, <a class="el" href="classcaffe2_1_1LengthsToWeightsOp.html">LengthsToWeightsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af56d34cf4fe5bc72c7f4ef5b16bfa5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6af8be33595de71a93f223fdf520d82"><td class="memItemLeft" align="right" valign="top"><a id="ae6af8be33595de71a93f223fdf520d82"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (EnsureDense, <a class="el" href="classcaffe2_1_1EnsureDenseOp.html">EnsureDenseOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ae6af8be33595de71a93f223fdf520d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77aa2a71bc9ba02ed8e43b70d5dad1e"><td class="memItemLeft" align="right" valign="top"><a id="ad77aa2a71bc9ba02ed8e43b70d5dad1e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AccumulateHistogram, <a class="el" href="classcaffe2_1_1AccumulateHistogramOp.html">AccumulateHistogramOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad77aa2a71bc9ba02ed8e43b70d5dad1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d10e655f4b3f8ebfc33fe7cb0cba57"><td class="memItemLeft" align="right" valign="top"><a id="a63d10e655f4b3f8ebfc33fe7cb0cba57"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (UnsafeCoalesce, <a class="el" href="classcaffe2_1_1UnsafeCoalesceOp.html">UnsafeCoalesceOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a63d10e655f4b3f8ebfc33fe7cb0cba57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861e55e4c15206433888161a4763efbe"><td class="memItemLeft" align="right" valign="top"><a id="a861e55e4c15206433888161a4763efbe"></a>
bool saves contents to the root folder of the current appending the tensor contents to a file named after the blob name logs to stderr&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;tensor&quot;, &quot;The tensor to print.&quot;)</td></tr>
<tr class="separator:a861e55e4c15206433888161a4763efbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353a20a1cfc55a53677f008197e8a57c"><td class="memItemLeft" align="right" valign="top"><a id="a353a20a1cfc55a53677f008197e8a57c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (LengthsToShape).NumInputs(1).NumOutputs(1)</td></tr>
<tr class="separator:a353a20a1cfc55a53677f008197e8a57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97957c09ab68e82c773d83375dc3bd0a"><td class="memItemLeft" align="right" valign="top"><a id="a97957c09ab68e82c773d83375dc3bd0a"></a>
out [0]&#160;</td><td class="memItemRight" valign="bottom"><b>add_dims</b> (total)</td></tr>
<tr class="separator:a97957c09ab68e82c773d83375dc3bd0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdef336988191a9f2723bb458b96f34"><td class="memItemLeft" align="right" valign="top"><a id="a0bdef336988191a9f2723bb458b96f34"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Flattens the input tensor into a 1D vector.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:a0bdef336988191a9f2723bb458b96f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d81287a9a7cfabd88c3be7ed7626eb3"><td class="memItemLeft" align="right" valign="top"><a id="a5d81287a9a7cfabd88c3be7ed7626eb3"></a>
out&#160;</td><td class="memItemRight" valign="bottom"><b>push_back</b> (in[1])</td></tr>
<tr class="separator:a5d81287a9a7cfabd88c3be7ed7626eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c93dc2df6c5a3138152345895d77c6b"><td class="memItemLeft" align="right" valign="top"><a id="a5c93dc2df6c5a3138152345895d77c6b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Produces tensor containing data of first input and shape of second input.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:a5c93dc2df6c5a3138152345895d77c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe37a46448f5c469f61abd3a3effc6f0"><td class="memItemLeft" align="right" valign="top"><a id="abe37a46448f5c469f61abd3a3effc6f0"></a>
<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> whose data will be copied into the output&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;shape_tensor&quot;, &quot;<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> whose shape will be applied to output.&quot;) .Output(0</td></tr>
<tr class="separator:abe37a46448f5c469f61abd3a3effc6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725d5cdacd4d70598c904a27d2839134"><td class="memItemLeft" align="right" valign="top"><a id="a725d5cdacd4d70598c904a27d2839134"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (1, INT_MAX) .NumOutputs(1) .InputsCanCrossDevices() .TensorInferenceFunction([](const OperatorDef &amp;</td></tr>
<tr class="separator:a725d5cdacd4d70598c904a27d2839134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8077a7ce4a3cbdb858af1f0e85a71359"><td class="memItemLeft" align="right" valign="top"><a id="a8077a7ce4a3cbdb858af1f0e85a71359"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> ([](int n) { return(n &gt; 0 &amp;&amp;n % 2==0);}) .NumOutputs(1) .AllowInplace(</td></tr>
<tr class="separator:a8077a7ce4a3cbdb858af1f0e85a71359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6421a283bf49ff004fdad02f3976ba"><td class="memItemLeft" align="right" valign="top"><a id="aca6421a283bf49ff004fdad02f3976ba"></a>
weight tensor pairs Input should be in the form where X_i all have the same and weight_i are size tensors that specifies the weight of each vector Note that if one wants to do in place it could only be done with X_0 also as the but not other X_i DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;data_0&quot;, &quot;First of the input tensors.&quot;) .Input(0</td></tr>
<tr class="separator:aca6421a283bf49ff004fdad02f3976ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c47fb3cb6cd16c29f6fdb4b37f9790"><td class="memItemLeft" align="right" valign="top"><a id="a01c47fb3cb6cd16c29f6fdb4b37f9790"></a>
weight tensor pairs Input should be in the form where X_i all have the same and weight_i are size tensors that specifies the weight of each vector Note that if one wants to do in place it could only be done with X_0 also as the but not other X_i DOC Weight of the first input in the sum&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;output&quot;, &quot;Result containing weighted elem-wise sum of inputs.&quot;)</td></tr>
<tr class="separator:a01c47fb3cb6cd16c29f6fdb4b37f9790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731f1980c4ab65b61626ce92161954e4"><td class="memItemLeft" align="right" valign="top"><a id="a731f1980c4ab65b61626ce92161954e4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> ([](int n) { return(n &gt; 0 &amp;&amp;n % 2==1);}) .NumOutputs(1</td></tr>
<tr class="separator:a731f1980c4ab65b61626ce92161954e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656443250b180078b8845da54769299c"><td class="memItemLeft" align="right" valign="top"><a id="a656443250b180078b8845da54769299c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> ([](int n) { return(n &gt; 3 &amp;&amp;(n - 3) % 2==0);}) .NumOutputs(1) .EnforceInplace(</td></tr>
<tr class="separator:a656443250b180078b8845da54769299c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48b4564a78799d70aab8576b380b4f8"><td class="memItemLeft" align="right" valign="top"><a id="ac48b4564a78799d70aab8576b380b4f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Similar to WeightedSum, computes the weighted sum of several tensors, with
the difference that inputs are sliced tensors. The first tensor has to be
in-place and only slices of it on the first dimension as indexed by INDICES
will be updated.

Note: The op pretty much ignores the exact shapes of the input arguments and
cares only about sizes. It's done for performance consideration to avoid
unnecessary reshapes. Only first dimension of X_0 is important, let's call it
N. If M is the total size of X_0 and K is the size of INDICES then X_i is
assumed to be of shape K x (M / N) regardless of the real shape.

Note: Each update in INDICES is applied independently which means that if
duplicated elements are present in INDICES the corresponding slice of X_0
will be scaled multiple times. Manual collapsing of INDICES is required
beforehand if necessary.

Note: Updates are applied sequentially by inputs which might have undesired
consequences if the input tensor is accessed concurrently by different op
(e.g. when doing Hogwild). Other threads might see intermediate results even
on individual slice level, e.g. X_0 scaled by weight_0 but without any
updates applied.

Currently only works on CPU because of access to INDICES.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:ac48b4564a78799d70aab8576b380b4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0d658fca0e40d6b008f80b4d964265"><td class="memItemLeft" align="right" valign="top"><a id="a9d0d658fca0e40d6b008f80b4d964265"></a>
<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;Weight_0&quot;, &quot;Scalar weight for X_0, applied only to slices affected.&quot;) .Input(2</td></tr>
<tr class="separator:a9d0d658fca0e40d6b008f80b4d964265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c88fe3cb451c172ce8b32fe63c2055"><td class="memItemLeft" align="right" valign="top"><a id="aa9c88fe3cb451c172ce8b32fe63c2055"></a>
<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> to be updated D list of indices on the first dimension of X_0 that need to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3, &quot;X_1&quot;, &quot;Update slices, with shape len(INDICES) + shape(X_0)[1:]&quot;) .Input(4</td></tr>
<tr class="separator:aa9c88fe3cb451c172ce8b32fe63c2055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fd2bb24a674bf06a438d9d645102c1"><td class="memItemLeft" align="right" valign="top"><a id="a49fd2bb24a674bf06a438d9d645102c1"></a>
<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> to be updated D list of indices on the first dimension of X_0 that need to be updated Scalar weight for X_1 update&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;X_0&quot;, &quot;Has to be exactly the same tensor as the input 0&quot;) .EnforceInplace(</td></tr>
<tr class="separator:a49fd2bb24a674bf06a438d9d645102c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100b1baddccb694741e43ad30440de58"><td class="memItemLeft" align="right" valign="top"><a id="a100b1baddccb694741e43ad30440de58"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Update slices of the tensor in-place by overriding current value.

Note: The op pretty much ignores the exact shapes of the input arguments and
cares only about sizes. It's done for performance consideration to avoid
unnecessary reshapes. Only first dimension of X_0 is important, let's call it
N. If M is the total size of X_0 and K is the size of INDICES then X_i is
assumed to be of shape K x (M / N) regardless of the real shape.

Note: Each update in INDICES is applied independently which means that if
duplicated elements are present in INDICES arbitrary one will win.

Currently only works on CPU because of access to INDICES.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:a100b1baddccb694741e43ad30440de58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516ac12add289a43b11827b60283d973"><td class="memItemLeft" align="right" valign="top"><a id="a516ac12add289a43b11827b60283d973"></a>
<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;INDICES&quot;, &quot;1-D list of indices on the first dimension&quot; &quot;of X_0 that need to be updated&quot;) .Input(2</td></tr>
<tr class="separator:a516ac12add289a43b11827b60283d973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e34bb7fd859f44abd71fed1f5981b4e"><td class="memItemLeft" align="right" valign="top"><a id="a0e34bb7fd859f44abd71fed1f5981b4e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Print, <a class="el" href="classcaffe2_1_1PrintOp.html">PrintOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a0e34bb7fd859f44abd71fed1f5981b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a437cf85dd21af2b2b6da5149f58da7"><td class="memItemLeft" align="right" valign="top"><a id="a5a437cf85dd21af2b2b6da5149f58da7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Flatten, <a class="el" href="classcaffe2_1_1FlattenOp.html">FlattenOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a5a437cf85dd21af2b2b6da5149f58da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f32fed087f9dc83b0f6a0e74bd622b"><td class="memItemLeft" align="right" valign="top"><a id="ab7f32fed087f9dc83b0f6a0e74bd622b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (FlattenToVec, <a class="el" href="classcaffe2_1_1FlattenToVecOp.html">FlattenToVecOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ab7f32fed087f9dc83b0f6a0e74bd622b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b3668843cb4ec89c047ed7677b89ca"><td class="memItemLeft" align="right" valign="top"><a id="a50b3668843cb4ec89c047ed7677b89ca"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Alias, <a class="el" href="classcaffe2_1_1AliasOp.html">AliasOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a50b3668843cb4ec89c047ed7677b89ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70158fdfb357723e27860b8c3507083"><td class="memItemLeft" align="right" valign="top"><a id="af70158fdfb357723e27860b8c3507083"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (ResizeLike, <a class="el" href="classcaffe2_1_1ResizeLikeOp.html">ResizeLikeOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:af70158fdfb357723e27860b8c3507083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1055817e3eed3d9c60ad2e8730123458"><td class="memItemLeft" align="right" valign="top"><a id="a1055817e3eed3d9c60ad2e8730123458"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Sum, <a class="el" href="classcaffe2_1_1SumOp.html">SumOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a1055817e3eed3d9c60ad2e8730123458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c937fe941261e4ba28926f3d7457a23"><td class="memItemLeft" align="right" valign="top"><a id="a6c937fe941261e4ba28926f3d7457a23"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (WeightedSum, <a class="el" href="classcaffe2_1_1WeightedSumOp.html">WeightedSumOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a6c937fe941261e4ba28926f3d7457a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac00eb2d0451f20575c498ee0659a787"><td class="memItemLeft" align="right" valign="top"><a id="aac00eb2d0451f20575c498ee0659a787"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (EnsureCPUOutput, <a class="el" href="classcaffe2_1_1CopyOp.html">CopyOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aac00eb2d0451f20575c498ee0659a787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7af60bdd53c299221823ee67c0b0fa"><td class="memItemLeft" align="right" valign="top"><a id="a5e7af60bdd53c299221823ee67c0b0fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CopyFromCPUInput, <a class="el" href="classcaffe2_1_1CopyOp.html">CopyOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a5e7af60bdd53c299221823ee67c0b0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4c7f776bc8597b6d7d97bf978cdc42"><td class="memItemLeft" align="right" valign="top"><a id="a2c4c7f776bc8597b6d7d97bf978cdc42"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CopyGPUToCPU, <a class="el" href="classcaffe2_1_1CopyOp.html">CopyOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a>, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a2c4c7f776bc8597b6d7d97bf978cdc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c78b2ae6f9ce5caa570e569c016073"><td class="memItemLeft" align="right" valign="top"><a id="ad2c78b2ae6f9ce5caa570e569c016073"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CopyCPUToGPU, <a class="el" href="classcaffe2_1_1CopyOp.html">CopyOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad2c78b2ae6f9ce5caa570e569c016073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a2a2d46d6b7db1bbce4b7f35bb23bf"><td class="memItemLeft" align="right" valign="top"><a id="ac4a2a2d46d6b7db1bbce4b7f35bb23bf"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Copy, <a class="el" href="classcaffe2_1_1CopyOp.html">CopyOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ac4a2a2d46d6b7db1bbce4b7f35bb23bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4876c6e9c8491246510c810133aa0df4"><td class="memItemLeft" align="right" valign="top"><a id="a4876c6e9c8491246510c810133aa0df4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CopyOnDeviceLike, <a class="el" href="classcaffe2_1_1CopyOnDeviceLikeOp.html">CopyOnDeviceLikeOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a>, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a4876c6e9c8491246510c810133aa0df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f45f2abd3fc143dcb7a7ca3b241a4d"><td class="memItemLeft" align="right" valign="top"><a id="ac3f45f2abd3fc143dcb7a7ca3b241a4d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (UnsafeCoalesce, <a class="el" href="classcaffe2_1_1UnsafeCoalesceOp.html">UnsafeCoalesceOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ac3f45f2abd3fc143dcb7a7ca3b241a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab079c71ac67fe9eb47f08939c74314cb"><td class="memItemLeft" align="right" valign="top"><a id="ab079c71ac67fe9eb47f08939c74314cb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (WeightedSample, <a class="el" href="classcaffe2_1_1WeightedSampleOp.html">WeightedSampleOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab079c71ac67fe9eb47f08939c74314cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b0129de6bf15b80c7bd747b438beeb"><td class="memItemLeft" align="right" valign="top"><a id="af8b0129de6bf15b80c7bd747b438beeb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> ([](const OperatorDef &amp;def, const vector&lt; TensorShape &gt; &amp;in) { vector&lt; TensorShape &gt; out(2);int batch_size=in[0].dims(0);out[0]=CreateTensorShape(vector&lt; int &gt;{batch_size}, TensorProto::INT32);out[1]=CreateTensorShape(vector&lt; int &gt;{batch_size}, TensorProto::FLOAT);return out;}) .SetDoc(R&quot;DOC( The operator performs sampling based on the input sampling weights for each batch. All weights must be non-negative numbers. The input is a 2-D tensor (<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt;float&gt;) of size (batch_size x weights_dim). For each batch</td></tr>
<tr class="separator:af8b0129de6bf15b80c7bd747b438beeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cd9b9f239c167c0cef4c250b6b577a"><td class="memItemLeft" align="right" valign="top"><a id="a88cd9b9f239c167c0cef4c250b6b577a"></a>
an index is randomly sampled from the distribution given by the weights of the corresponding batch The output is a D&#160;</td><td class="memItemRight" valign="bottom"><b>tensor</b> (<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; int &gt;) of size(batch_size x 1) and contains the index(es) of the sampled output.) DOC&quot;) .Input( 0</td></tr>
<tr class="separator:a88cd9b9f239c167c0cef4c250b6b577a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0e38482da15b79bedd92d89154455d"><td class="memItemLeft" align="right" valign="top"><a id="aae0e38482da15b79bedd92d89154455d"></a>
an index is randomly sampled from the distribution given by the weights of the corresponding batch The output is a D A D <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; float &gt; of&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> (batch_size x weights_dim).&quot; &quot;All weights must be non-negative numbers.&quot;) .Input( 1</td></tr>
<tr class="separator:aae0e38482da15b79bedd92d89154455d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9595ed908897a80976049b68a734b1"><td class="memItemLeft" align="right" valign="top"><a id="a1c9595ed908897a80976049b68a734b1"></a>
an index is randomly sampled from the distribution given by the weights of the corresponding batch The output is a D A D <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; float &gt; of An optional D <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; float &gt; of The output tensor contains&#160;</td><td class="memItemRight" valign="bottom"><b>index</b> (es) sampled from distribution given&quot; &quot;by the weight vector(s) in the input tensor&quot; &quot;The output is a 1-D <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; int &gt; of size(batch_size x 1)&quot;) .Output( 1</td></tr>
<tr class="separator:a1c9595ed908897a80976049b68a734b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8987c943fb4b39ed176c1daf3648fd"><td class="memItemLeft" align="right" valign="top"><a id="aac8987c943fb4b39ed176c1daf3648fd"></a>
an index is randomly sampled from the distribution given by the weights of the corresponding batch The output is a D A D <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; float &gt; of An optional D <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; float &gt; of The output tensor contains The output tensor contains&#160;</td><td class="memItemRight" valign="bottom"><b>value</b> (s) selected by the sampled index(es)&quot; &quot;It is a 1-D <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; float &gt; of size(batch_size x 1)&quot;)</td></tr>
<tr class="separator:aac8987c943fb4b39ed176c1daf3648fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c809c643823734ab57c3a85a5e9170"><td class="memItemLeft" align="right" valign="top"><a id="a76c809c643823734ab57c3a85a5e9170"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (WeightedSample)</td></tr>
<tr class="separator:a76c809c643823734ab57c3a85a5e9170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102ffa79682074513d591e377397b042"><td class="memItemLeft" align="right" valign="top"><a id="a102ffa79682074513d591e377397b042"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (While, <a class="el" href="classcaffe2_1_1WhileOp.html">WhileOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a102ffa79682074513d591e377397b042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876b1e22c1b3bc97afd4ea23ed14df71"><td class="memItemLeft" align="right" valign="top"><a id="a876b1e22c1b3bc97afd4ea23ed14df71"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
'While' control operator, first input is a scalar boolean blob that stores loop's
condition value. Accepts 'loop_net' (required) and 'cond_net' (optional) arguments for
loop's body and condition subnets respectively. If condition subnet is specified,
it is executed before the first and after each iteration. Subnets are executed in
the same workspace as 'While'.
    )DOC&quot;) .Arg(&quot;loop_net&quot;</td></tr>
<tr class="separator:a876b1e22c1b3bc97afd4ea23ed14df71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1591e201a8207e9956c885afecbfdf8"><td class="memItemLeft" align="right" valign="top"><a id="ab1591e201a8207e9956c885afecbfdf8"></a>
INT_MAX Net executed on each iteration&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;cond_net&quot;, &quot;Net to (re)compute condition value&quot;) .Input(0</td></tr>
<tr class="separator:ab1591e201a8207e9956c885afecbfdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f21c6c1b8416cc320cd2a77b367d632"><td class="memItemLeft" align="right" valign="top"><a id="a6f21c6c1b8416cc320cd2a77b367d632"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (While, <a class="el" href="classcaffe2_1_1WhileOp.html">WhileOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a6f21c6c1b8416cc320cd2a77b367d632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f526c762e31c803fbb22e25978d1ff"><td class="memItemLeft" align="right" valign="top"><a id="a86f526c762e31c803fbb22e25978d1ff"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (ZeroGradient, <a class="el" href="classcaffe2_1_1ZeroGradientOp.html">ZeroGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a86f526c762e31c803fbb22e25978d1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6005751214e6bcbd2ed96de870cec48"><td class="memItemLeft" align="right" valign="top"><a id="ab6005751214e6bcbd2ed96de870cec48"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (ZeroGradient).NumInputs(1).NumOutputs(0).SetDoc(R&quot;DOC( ZeroGradient operators doesn't produce any output blobs. One can use this operator to produce 0 gradient for the input blob. )DOC&quot;)</td></tr>
<tr class="separator:ab6005751214e6bcbd2ed96de870cec48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada778193a182df6ced292b0e04f500a8"><td class="memItemLeft" align="right" valign="top"><a id="ada778193a182df6ced292b0e04f500a8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_GRADIENT</b> (ZeroGradient, <a class="el" href="structcaffe2_1_1GetZeroGradientOpGradient.html">GetZeroGradientOpGradient</a>)</td></tr>
<tr class="separator:ada778193a182df6ced292b0e04f500a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61627ee70d1645f2d0cd56fb0f46e08"><td class="memItemLeft" align="right" valign="top"><a id="aa61627ee70d1645f2d0cd56fb0f46e08"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (ZeroGradient, <a class="el" href="classcaffe2_1_1ZeroGradientOp.html">ZeroGradientOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aa61627ee70d1645f2d0cd56fb0f46e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f5d9b0facc3fe62f20059c681557a9"><td class="memItemLeft" align="right" valign="top"><a id="a90f5d9b0facc3fe62f20059c681557a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EMBEDDING_SPECIALIZATION</b> (int32_t, float, float)</td></tr>
<tr class="separator:a90f5d9b0facc3fe62f20059c681557a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54fcea1bec7e99f4f453c2721376aded"><td class="memItemLeft" align="right" valign="top"><a id="a54fcea1bec7e99f4f453c2721376aded"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EMBEDDING_SPECIALIZATION</b> (int64_t, float, float)</td></tr>
<tr class="separator:a54fcea1bec7e99f4f453c2721376aded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715ff1b09f2313843be9f2f1a389f966"><td class="memItemLeft" align="right" valign="top"><a id="a715ff1b09f2313843be9f2f1a389f966"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EMBEDDING_SPECIALIZATION</b> (int32_t, float16, float)</td></tr>
<tr class="separator:a715ff1b09f2313843be9f2f1a389f966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e20503a4304a1b0283fd66ffff8f4a9"><td class="memItemLeft" align="right" valign="top"><a id="a8e20503a4304a1b0283fd66ffff8f4a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EMBEDDING_SPECIALIZATION</b> (int64_t, float16, float)</td></tr>
<tr class="separator:a8e20503a4304a1b0283fd66ffff8f4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4180d52576f9f6723e4fe7364af9104e"><td class="memItemLeft" align="right" valign="top"><a id="a4180d52576f9f6723e4fe7364af9104e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EMBEDDING_SPECIALIZATION</b> (int32_t, uint8_t, float)</td></tr>
<tr class="separator:a4180d52576f9f6723e4fe7364af9104e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae567c2ddecf3c2fe288935120e6e03be"><td class="memItemLeft" align="right" valign="top"><a id="ae567c2ddecf3c2fe288935120e6e03be"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EMBEDDING_SPECIALIZATION</b> (int64_t, uint8_t, float)</td></tr>
<tr class="separator:ae567c2ddecf3c2fe288935120e6e03be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df473adce0513ec1ed647ed7673fab5"><td class="memTemplParams" colspan="2">template&lt;typename IndexType , typename InType , typename OutType &gt; </td></tr>
<tr class="memitem:a5df473adce0513ec1ed647ed7673fab5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecaffe2.html#a5df473adce0513ec1ed647ed7673fab5">EmbeddingLookup</a> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const InType *input, const IndexType *indices, const int *lengths, const float *weights, const float *scale_bias, bool normalize_by_lengths, OutType *out)</td></tr>
<tr class="memdesc:a5df473adce0513ec1ed647ed7673fab5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Embedding lookup with reduction.  <a href="#a5df473adce0513ec1ed647ed7673fab5">More...</a><br /></td></tr>
<tr class="separator:a5df473adce0513ec1ed647ed7673fab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e4d37453d19d43640bf45774924ebb"><td class="memItemLeft" align="right" valign="top"><a id="af6e4d37453d19d43640bf45774924ebb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EmbeddingLookup_int32_t_float_float__avx2_fma</b> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const float *input, const int32_t *indices, const int *lengths, const float *weights, const float *scale_bias, bool normalize_by_lengths, float *out)</td></tr>
<tr class="separator:af6e4d37453d19d43640bf45774924ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcaa8ed9e20bb1ce71a332c87e89886"><td class="memItemLeft" align="right" valign="top"><a id="aafcaa8ed9e20bb1ce71a332c87e89886"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EmbeddingLookup_int64_t_float_float__avx2_fma</b> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const float *input, const int64_t *indices, const int *lengths, const float *weights, const float *scale_bias, bool normalize_by_lengths, float *out)</td></tr>
<tr class="separator:aafcaa8ed9e20bb1ce71a332c87e89886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace643f72bac033199df10d71904c9a52"><td class="memItemLeft" align="right" valign="top"><a id="ace643f72bac033199df10d71904c9a52"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EmbeddingLookup_int32_t_float16_float__avx2_fma</b> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const float16 *input, const int32_t *indices, const int *lengths, const float *weights, const float *scale_bias, bool normalize_by_lengths, float *out)</td></tr>
<tr class="separator:ace643f72bac033199df10d71904c9a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d8d44ef6a1de5e519baf96dd39f8d2b"><td class="memItemLeft" align="right" valign="top"><a id="a1d8d44ef6a1de5e519baf96dd39f8d2b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EmbeddingLookup_int64_t_float16_float__avx2_fma</b> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const float16 *input, const int64_t *indices, const int *lengths, const float *weights, const float *scale_bias, bool normalize_by_lengths, float *out)</td></tr>
<tr class="separator:a1d8d44ef6a1de5e519baf96dd39f8d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1610953d85200cb50aa5c1bb39fe73b"><td class="memItemLeft" align="right" valign="top"><a id="af1610953d85200cb50aa5c1bb39fe73b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EmbeddingLookup_int32_t_uint8_t_float__avx2_fma</b> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const uint8_t *input, const int32_t *indices, const int *lengths, const float *weights, const float *scale_bias, bool normalize_by_lengths, float *out)</td></tr>
<tr class="separator:af1610953d85200cb50aa5c1bb39fe73b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d32570002aa4e0bb8bd603c8295c019"><td class="memItemLeft" align="right" valign="top"><a id="a2d32570002aa4e0bb8bd603c8295c019"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>EmbeddingLookup_int64_t_uint8_t_float__avx2_fma</b> (const TIndex block_size, const TIndex output_size, const TIndex index_size, const TIndex data_size, const uint8_t *input, const int64_t *indices, const int *lengths, const float *weights, const float *scale_bias, bool normalize_by_lengths, float *out)</td></tr>
<tr class="separator:a2d32570002aa4e0bb8bd603c8295c019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5496fbdc2cb8dde299857e6b90093dfe"><td class="memTemplParams" colspan="2"><a id="a5496fbdc2cb8dde299857e6b90093dfe"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5496fbdc2cb8dde299857e6b90093dfe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TypedAxpy&lt; float, float &gt;</b> (int N, const float a, const float *x, float *y)</td></tr>
<tr class="separator:a5496fbdc2cb8dde299857e6b90093dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4835083ea5bfa10c7b3af8e23bfda8"><td class="memItemLeft" align="right" valign="top"><a id="afb4835083ea5bfa10c7b3af8e23bfda8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TypedAxpy_float16_float__base</b> (int N, const float a, const float16 *x, float *y)</td></tr>
<tr class="separator:afb4835083ea5bfa10c7b3af8e23bfda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac432a44186d193fffeeb76f623104555"><td class="memTemplParams" colspan="2"><a id="ac432a44186d193fffeeb76f623104555"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ac432a44186d193fffeeb76f623104555"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TypedAxpy&lt; float16, float &gt;</b> (int N, const float a, const float16 *x, float *y)</td></tr>
<tr class="separator:ac432a44186d193fffeeb76f623104555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f03fa74e51e214bde37bea2b5a060ad"><td class="memItemLeft" align="right" valign="top"><a id="a9f03fa74e51e214bde37bea2b5a060ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TypedAxpy_uint8_float__base</b> (int N, const float a, const std::uint8_t *x, float *y)</td></tr>
<tr class="separator:a9f03fa74e51e214bde37bea2b5a060ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475524f78a260b2f1c5688254fef332d"><td class="memTemplParams" colspan="2"><a id="a475524f78a260b2f1c5688254fef332d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a475524f78a260b2f1c5688254fef332d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TypedAxpy&lt; std::uint8_t, float &gt;</b> (int N, const float a, const std::uint8_t *x, float *y)</td></tr>
<tr class="separator:a475524f78a260b2f1c5688254fef332d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31911563cde2f40247726cd126da6c75"><td class="memTemplParams" colspan="2"><a id="a31911563cde2f40247726cd126da6c75"></a>
template&lt;typename IN , typename OUT &gt; </td></tr>
<tr class="memitem:a31911563cde2f40247726cd126da6c75"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>TypedAxpy</b> (int N, const OUT a, const IN *x, OUT *y)</td></tr>
<tr class="separator:a31911563cde2f40247726cd126da6c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ea5a7d37f764d5402b8bdc0fd09e23"><td class="memItemLeft" align="right" valign="top"><a id="ab1ea5a7d37f764d5402b8bdc0fd09e23"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TypedAxpy_float16_float__avx_f16c</b> (int N, const float a, const float16 *x, float *y)</td></tr>
<tr class="separator:ab1ea5a7d37f764d5402b8bdc0fd09e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468511fd72083ef868ea78e5a4abe606"><td class="memItemLeft" align="right" valign="top"><a id="a468511fd72083ef868ea78e5a4abe606"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TypedAxpy_float16_float__avx2_fma</b> (int N, const float a, const float16 *x, float *y)</td></tr>
<tr class="separator:a468511fd72083ef868ea78e5a4abe606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0fe630d1fc251b4ccb093469400af1"><td class="memItemLeft" align="right" valign="top"><a id="a2a0fe630d1fc251b4ccb093469400af1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TypedAxpy_uint8_float__avx2_fma</b> (int N, const float a, const std::uint8_t *x, float *y)</td></tr>
<tr class="separator:a2a0fe630d1fc251b4ccb093469400af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050a59050cee23f2396f5e10997050a6"><td class="memItemLeft" align="right" valign="top"><a id="a050a59050cee23f2396f5e10997050a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (std::shared_ptr&lt; <a class="el" href="classcaffe2_1_1BlobsQueue.html">BlobsQueue</a> &gt;)</td></tr>
<tr class="separator:a050a59050cee23f2396f5e10997050a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d08fe955467bcab0d55b1da49c78ea3"><td class="memItemLeft" align="right" valign="top"><a id="a3d08fe955467bcab0d55b1da49c78ea3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CreateBlobsQueue, <a class="el" href="classcaffe2_1_1CreateBlobsQueueOp.html">CreateBlobsQueueOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a3d08fe955467bcab0d55b1da49c78ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3a0730dc2efc0c8bf27ecc274a57c4"><td class="memItemLeft" align="right" valign="top"><a id="abc3a0730dc2efc0c8bf27ecc274a57c4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (EnqueueBlobs, <a class="el" href="classcaffe2_1_1EnqueueBlobsOp.html">EnqueueBlobsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:abc3a0730dc2efc0c8bf27ecc274a57c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa80a228741c5b32dc50bd12b5ad762"><td class="memItemLeft" align="right" valign="top"><a id="afaa80a228741c5b32dc50bd12b5ad762"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (DequeueBlobs, <a class="el" href="classcaffe2_1_1DequeueBlobsOp.html">DequeueBlobsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:afaa80a228741c5b32dc50bd12b5ad762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f157af0b2dbaa599297dcd3479bfda"><td class="memItemLeft" align="right" valign="top"><a id="a96f157af0b2dbaa599297dcd3479bfda"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (CloseBlobsQueue, <a class="el" href="classcaffe2_1_1CloseBlobsQueueOp.html">CloseBlobsQueueOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a96f157af0b2dbaa599297dcd3479bfda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8bdff09f365a4910b36705480f3ceb"><td class="memItemLeft" align="right" valign="top"><a id="adb8bdff09f365a4910b36705480f3ceb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SafeEnqueueBlobs, <a class="el" href="classcaffe2_1_1SafeEnqueueBlobsOp.html">SafeEnqueueBlobsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:adb8bdff09f365a4910b36705480f3ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af547c162adbe651e91c8569334110347"><td class="memItemLeft" align="right" valign="top"><a id="af547c162adbe651e91c8569334110347"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SafeDequeueBlobs, <a class="el" href="classcaffe2_1_1SafeDequeueBlobsOp.html">SafeDequeueBlobsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:af547c162adbe651e91c8569334110347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb563fa919e5cfbeabb350f432ea1b2"><td class="memItemLeft" align="right" valign="top"><a id="a7eb563fa919e5cfbeabb350f432ea1b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (WeightedSampleDequeueBlobs, <a class="el" href="classcaffe2_1_1WeightedSampleDequeueBlobsOp.html">WeightedSampleDequeueBlobsOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a7eb563fa919e5cfbeabb350f432ea1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa108c917884eb0e3e25a3e41ca576863"><td class="memItemLeft" align="right" valign="top"><a id="aa108c917884eb0e3e25a3e41ca576863"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (CreateBlobsQueue).NumInputs(0).NumOutputs(1)</td></tr>
<tr class="separator:aa108c917884eb0e3e25a3e41ca576863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b5cc795af36be812460257e034808c"><td class="memItemLeft" align="right" valign="top"><a id="a27b5cc795af36be812460257e034808c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputsOutputs</b> ([](int inputs, int outputs) { return inputs &gt;=2 &amp;&amp;outputs &gt;=1 &amp;&amp;inputs==outputs+1;}) .EnforceInplace([](int input</td></tr>
<tr class="separator:a27b5cc795af36be812460257e034808c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283b93e76298303dd22d32700d645800"><td class="memItemLeft" align="right" valign="top"><a id="a283b93e76298303dd22d32700d645800"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputsOutputs</b> ([](int inputs, int outputs) { return inputs==1 &amp;&amp;outputs &gt;=1;}) .SetDoc(R&quot;DOC( Dequeue the blobs from queue. )DOC&quot;) .Arg(&quot;timeout_secs&quot;</td></tr>
<tr class="separator:a283b93e76298303dd22d32700d645800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade28e4bf908330f4ce2dbbb2a046fab7"><td class="memItemLeft" align="right" valign="top"><a id="ade28e4bf908330f4ce2dbbb2a046fab7"></a>
Timeout in The shared pointer for the <a class="el" href="classcaffe2_1_1BlobsQueue.html">BlobsQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;blob&quot;, &quot;The blob to store the dequeued data&quot;)</td></tr>
<tr class="separator:ade28e4bf908330f4ce2dbbb2a046fab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56400e7db97acdb8d20260e747876595"><td class="memItemLeft" align="right" valign="top"><a id="a56400e7db97acdb8d20260e747876595"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (CloseBlobsQueue).NumInputs(1).NumOutputs(0)</td></tr>
<tr class="separator:a56400e7db97acdb8d20260e747876595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab000c5a3e721a4682d04e42692d4e59"><td class="memItemLeft" align="right" valign="top"><a id="aab000c5a3e721a4682d04e42692d4e59"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputsOutputs</b> ([](int inputs, int outputs) { return inputs &gt;=2 &amp;&amp;outputs &gt;=2 &amp;&amp;inputs==outputs;}) .EnforceInplace([](int input</td></tr>
<tr class="separator:aab000c5a3e721a4682d04e42692d4e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb0b330e0a5e5189d497b6464ab9cf9"><td class="memItemLeft" align="right" valign="top"><a id="aabb0b330e0a5e5189d497b6464ab9cf9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Enqueue the blobs into queue. When the queue is closed and full, the output
status will be set to true which can be used as exit criteria for execution
step.
The 1st input is the queue and the last output is the status. The rest are
data blobs.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:aabb0b330e0a5e5189d497b6464ab9cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3056e4d18f2e9548948c1e3c56621b8"><td class="memItemLeft" align="right" valign="top"><a id="ab3056e4d18f2e9548948c1e3c56621b8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputsOutputs</b> ([](int inputs, int outputs) { return inputs==1 &amp;&amp;outputs &gt;=2;}) .SetDoc(R&quot;DOC( Dequeue the blobs from queue. When the queue is closed and empty</td></tr>
<tr class="separator:ab3056e4d18f2e9548948c1e3c56621b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a317f45603a9abb18927e127379e76fc0"><td class="memItemLeft" align="right" valign="top"><a id="a317f45603a9abb18927e127379e76fc0"></a>
the output status will be set to true which can be used as exit criteria for execution step The input is the queue and the last output is the status The rest are data blobs DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;num_records&quot;, &quot;(default 1) If &gt; 1, multiple records will be dequeued and tensors &quot; &quot;for each column will be concatenated. This requires all tensors in &quot; &quot;the records to be at least 1D, and to have the same inner dimensions.&quot;) .Input(0</td></tr>
<tr class="separator:a317f45603a9abb18927e127379e76fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804025609049acbdf4a8f912f8496e63"><td class="memItemLeft" align="right" valign="top"><a id="a804025609049acbdf4a8f912f8496e63"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Dequeue the blobs from multiple queues. When one of queues is closed and empty,
the output status will be set to true which can be used as exit criteria for
execution step.
The 1st input is the queue and the last output is the status. The rest are
data blobs.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:a804025609049acbdf4a8f912f8496e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf8929088680b81f5f66c26b4ee20f3"><td class="memItemLeft" align="right" valign="top"><a id="a7bf8929088680b81f5f66c26b4ee20f3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (CreateBlobsQueue)</td></tr>
<tr class="separator:a7bf8929088680b81f5f66c26b4ee20f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357f4d3f2d14ea7d366be90153e19f53"><td class="memItemLeft" align="right" valign="top"><a id="a357f4d3f2d14ea7d366be90153e19f53"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (EnqueueBlobs)</td></tr>
<tr class="separator:a357f4d3f2d14ea7d366be90153e19f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3815b5eb1e08d00057593e8f457a22ea"><td class="memItemLeft" align="right" valign="top"><a id="a3815b5eb1e08d00057593e8f457a22ea"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (DequeueBlobs)</td></tr>
<tr class="separator:a3815b5eb1e08d00057593e8f457a22ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab827355b441c918e25d4b80a76f900c1"><td class="memItemLeft" align="right" valign="top"><a id="ab827355b441c918e25d4b80a76f900c1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (CloseBlobsQueue)</td></tr>
<tr class="separator:ab827355b441c918e25d4b80a76f900c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6fd20c9ee048bb5217bbafc73e5786"><td class="memItemLeft" align="right" valign="top"><a id="a9a6fd20c9ee048bb5217bbafc73e5786"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (SafeEnqueueBlobs)</td></tr>
<tr class="separator:a9a6fd20c9ee048bb5217bbafc73e5786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f60df3c55c85a5dc1ad041cec23bd4"><td class="memItemLeft" align="right" valign="top"><a id="a49f60df3c55c85a5dc1ad041cec23bd4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (SafeDequeueBlobs)</td></tr>
<tr class="separator:a49f60df3c55c85a5dc1ad041cec23bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdb2be4139d4d31669ef96634a01857"><td class="memItemLeft" align="right" valign="top"><a id="aacdb2be4139d4d31669ef96634a01857"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (WeightedSampleDequeueBlobs)</td></tr>
<tr class="separator:aacdb2be4139d4d31669ef96634a01857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4f33b32b373b18f9fe66143ea3e8dc"><td class="memItemLeft" align="right" valign="top"><a id="a3e4f33b32b373b18f9fe66143ea3e8dc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CreateBlobsQueue, <a class="el" href="classcaffe2_1_1CreateBlobsQueueOp.html">CreateBlobsQueueOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a3e4f33b32b373b18f9fe66143ea3e8dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9b371e732330cdf8b8d0ec93ec5613"><td class="memItemLeft" align="right" valign="top"><a id="a7c9b371e732330cdf8b8d0ec93ec5613"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (EnqueueBlobs, <a class="el" href="classcaffe2_1_1EnqueueBlobsOp.html">EnqueueBlobsOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a7c9b371e732330cdf8b8d0ec93ec5613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b89cd90a1ce2627bf1e8aff627b8b6"><td class="memItemLeft" align="right" valign="top"><a id="a55b89cd90a1ce2627bf1e8aff627b8b6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (DequeueBlobs, <a class="el" href="classcaffe2_1_1DequeueBlobsOp.html">DequeueBlobsOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a55b89cd90a1ce2627bf1e8aff627b8b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cd6df4aaa20225d3118c02e87161df"><td class="memItemLeft" align="right" valign="top"><a id="af9cd6df4aaa20225d3118c02e87161df"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (CloseBlobsQueue, <a class="el" href="classcaffe2_1_1CloseBlobsQueueOp.html">CloseBlobsQueueOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:af9cd6df4aaa20225d3118c02e87161df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5598fe404cb1ec5db79c7c265b7b46c"><td class="memItemLeft" align="right" valign="top"><a id="aa5598fe404cb1ec5db79c7c265b7b46c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (SafeEnqueueBlobs, <a class="el" href="classcaffe2_1_1SafeEnqueueBlobsOp.html">SafeEnqueueBlobsOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aa5598fe404cb1ec5db79c7c265b7b46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ec76fc3e77c96d1c77b8a1066abb62"><td class="memItemLeft" align="right" valign="top"><a id="ae0ec76fc3e77c96d1c77b8a1066abb62"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (SafeDequeueBlobs, <a class="el" href="classcaffe2_1_1SafeDequeueBlobsOp.html">SafeDequeueBlobsOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ae0ec76fc3e77c96d1c77b8a1066abb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae097b8dbd7befdac3c5893994197e4e1"><td class="memItemLeft" align="right" valign="top"><a id="ae097b8dbd7befdac3c5893994197e4e1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_KNOWN_TYPE</b> (RebatchingQueuePtr)</td></tr>
<tr class="separator:ae097b8dbd7befdac3c5893994197e4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b7fb160455401466308ec5db0c93f1"><td class="memItemLeft" align="right" valign="top"><a id="aa3b7fb160455401466308ec5db0c93f1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Adagrad, <a class="el" href="classcaffe2_1_1AdagradOp.html">AdagradOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:aa3b7fb160455401466308ec5db0c93f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e53d10b1f6875368533d53f8f183bab"><td class="memItemLeft" align="right" valign="top"><a id="a0e53d10b1f6875368533d53f8f183bab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(

Computes the AdaGrad update for an input gradient and accumulated
history. Concretely, given inputs (param, grad, moment, learning_rate),
computes

    new_moment = moment + square(grad)
    new_grad = learning_rate * grad / (sqrt(new_moment) + epsilon)
    new_param = param + new_grad
and returns (new_param, new_moment).

)DOC&quot;) .Input(0</td></tr>
<tr class="separator:a0e53d10b1f6875368533d53f8f183bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff3bb407c4ff8896734ba9c4647a97b4"><td class="memItemLeft" align="right" valign="top"><a id="aff3bb407c4ff8896734ba9c4647a97b4"></a>
Parameters to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;moment&quot;, &quot;Moment history&quot;) .Input(2</td></tr>
<tr class="separator:aff3bb407c4ff8896734ba9c4647a97b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84e662a20b6e01f049b86f7dc09a707"><td class="memItemLeft" align="right" valign="top"><a id="ad84e662a20b6e01f049b86f7dc09a707"></a>
Parameters to be updated Gradient computed&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3, &quot;lr&quot;, &quot;learning rate&quot;) .Output(0</td></tr>
<tr class="separator:ad84e662a20b6e01f049b86f7dc09a707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d00b8bb09b31a0cd39c9abf403eff6a"><td class="memItemLeft" align="right" valign="top"><a id="a8d00b8bb09b31a0cd39c9abf403eff6a"></a>
Parameters to be updated Gradient computed Updated parameters&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1, &quot;output_moment&quot;, &quot;Updated moment&quot;) .Arg(&quot;epsilon&quot;</td></tr>
<tr class="separator:a8d00b8bb09b31a0cd39c9abf403eff6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab842818be52dc0722d872d923d193cf6"><td class="memItemLeft" align="right" valign="top"><a id="ab842818be52dc0722d872d923d193cf6"></a>
Parameters to be updated Gradient computed Updated parameters Default&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;decay&quot;, &quot;Default 1. If it is in (0, 1), the gradient square sum &quot; &quot;is decayed by this factor.&quot;)</td></tr>
<tr class="separator:ab842818be52dc0722d872d923d193cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8403cbf6feb78929cc3f0734ddf104b"><td class="memItemLeft" align="right" valign="top"><a id="ab8403cbf6feb78929cc3f0734ddf104b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseAdagrad, <a class="el" href="classcaffe2_1_1SparseAdagradOp.html">SparseAdagradOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab8403cbf6feb78929cc3f0734ddf104b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec133588cd8ddf84d2e09df4611e78d3"><td class="memItemLeft" align="right" valign="top"><a id="aec133588cd8ddf84d2e09df4611e78d3"></a>
runs the dense AdaGrad update&#160;</td><td class="memItemRight" valign="bottom"><b>on</b> (param, grad, moment[indices], lr)</td></tr>
<tr class="separator:aec133588cd8ddf84d2e09df4611e78d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee24aa3bec297ef92c6e50bbfa73889"><td class="memItemLeft" align="right" valign="top"><a id="a8ee24aa3bec297ef92c6e50bbfa73889"></a>
runs the dense AdaGrad update and&#160;</td><td class="memItemRight" valign="bottom"><b>returns</b> (new_param, new_moment) as in the dense case.) DOC&quot;) .Input(0</td></tr>
<tr class="separator:a8ee24aa3bec297ef92c6e50bbfa73889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdf91e09a8160edd441ec33a05c20d1"><td class="memItemLeft" align="right" valign="top"><a id="a9fdf91e09a8160edd441ec33a05c20d1"></a>
runs the dense AdaGrad update and Parameters to be updated Sparse indices&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3, &quot;grad&quot;, &quot;Gradient computed&quot;) .Input(4</td></tr>
<tr class="separator:a9fdf91e09a8160edd441ec33a05c20d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac343e673dfc1086d68bb543228c59426"><td class="memItemLeft" align="right" valign="top"><a id="ac343e673dfc1086d68bb543228c59426"></a>
runs the dense AdaGrad update and Parameters to be updated Sparse indices learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (0, &quot;output_param&quot;, &quot;Updated parameters&quot;) .Output(1</td></tr>
<tr class="separator:ac343e673dfc1086d68bb543228c59426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a13c19411779f3cacf282c9f59e3d7d"><td class="memItemLeft" align="right" valign="top"><a id="a5a13c19411779f3cacf282c9f59e3d7d"></a>
runs the dense AdaGrad update and Parameters to be updated Sparse indices learning rate Updated moment&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;epsilon&quot;, &quot;Default 1e-5&quot;)</td></tr>
<tr class="separator:a5a13c19411779f3cacf282c9f59e3d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4d1694dde0ae0a9a3426b87044bef4"><td class="memItemLeft" align="right" valign="top"><a id="a4e4d1694dde0ae0a9a3426b87044bef4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RowWiseSparseAdagrad, <a class="el" href="classcaffe2_1_1RowWiseSparseAdagradOp.html">RowWiseSparseAdagradOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a4e4d1694dde0ae0a9a3426b87044bef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f5924a76aa2ecb54e94cab5a790cd7"><td class="memItemLeft" align="right" valign="top"><a id="a56f5924a76aa2ecb54e94cab5a790cd7"></a>
runs a modified sparse Adagrad update and&#160;</td><td class="memItemRight" valign="bottom"><b>returns</b> (new_param, new_momwnr)</td></tr>
<tr class="separator:a56f5924a76aa2ecb54e94cab5a790cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b143dd444d36d0e9b950bceeceae86"><td class="memItemLeft" align="right" valign="top"><a id="af8b143dd444d36d0e9b950bceeceae86"></a>
runs a modified sparse Adagrad update and where moment is a tensor with length equal to the number of rows in and the new moment is calculated by adding the average squared sum of gradients across each row Note that indices must also be a tensor indexing into the rows of param DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (0, &quot;param&quot;, &quot;Parameters to be updated&quot;) .Input(1</td></tr>
<tr class="separator:af8b143dd444d36d0e9b950bceeceae86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c76ea8b5de73d12417778d7248e029"><td class="memItemLeft" align="right" valign="top"><a id="a10c76ea8b5de73d12417778d7248e029"></a>
runs a modified sparse Adagrad update and where moment is a tensor with length equal to the number of rows in and the new moment is calculated by adding the average squared sum of gradients across each row Note that indices must also be a tensor indexing into the rows of param DOC Moment history&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (2, &quot;indices&quot;, &quot;Sparse indices&quot;) .Input(3</td></tr>
<tr class="separator:a10c76ea8b5de73d12417778d7248e029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182b148a2fa26f9f736d3e47ca0512bc"><td class="memItemLeft" align="right" valign="top"><a id="a182b148a2fa26f9f736d3e47ca0512bc"></a>
runs a modified sparse Adagrad update and where moment is a tensor with length equal to the number of rows in and the new moment is calculated by adding the average squared sum of gradients across each row Note that indices must also be a tensor indexing into the rows of param DOC Moment history Gradient computed&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (4, &quot;lr&quot;, &quot;learning rate&quot;) .Output(0</td></tr>
<tr class="separator:a182b148a2fa26f9f736d3e47ca0512bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5a3eb76fefc394e28b95d56bf0f5bb"><td class="memItemLeft" align="right" valign="top"><a id="abd5a3eb76fefc394e28b95d56bf0f5bb"></a>
runs a modified sparse Adagrad update and where moment is a tensor with length equal to the number of rows in and the new moment is calculated by adding the average squared sum of gradients across each row Note that indices must also be a tensor indexing into the rows of param DOC Moment history Gradient computed Updated parameters&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1, &quot;output_moment_1&quot;, &quot;Updated moment&quot;) .Arg(&quot;epsilon&quot;</td></tr>
<tr class="separator:abd5a3eb76fefc394e28b95d56bf0f5bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d4427cfc6d811d547367315564dbf1"><td class="memItemLeft" align="right" valign="top"><a id="a49d4427cfc6d811d547367315564dbf1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Adagrad)</td></tr>
<tr class="separator:a49d4427cfc6d811d547367315564dbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c71a348333a99d7adb7597d16d69eac"><td class="memItemLeft" align="right" valign="top"><a id="a6c71a348333a99d7adb7597d16d69eac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (SparseAdagrad)</td></tr>
<tr class="separator:a6c71a348333a99d7adb7597d16d69eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca4d273c28e7a0bc4576d6fb59838f2"><td class="memItemLeft" align="right" valign="top"><a id="a9ca4d273c28e7a0bc4576d6fb59838f2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (RowWiseSparseAdagrad)</td></tr>
<tr class="separator:a9ca4d273c28e7a0bc4576d6fb59838f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52caf415e26784864b15d1805ff7989a"><td class="memTemplParams" colspan="2"><a id="a52caf415e26784864b15d1805ff7989a"></a>
template&lt;typename Context &gt; </td></tr>
<tr class="memitem:a52caf415e26784864b15d1805ff7989a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>adagrad_update</b> (int N, const float *w, const float *g, const float *h, float *nw, float *nh, float epsilon, float decay, const float *lr, Context *)</td></tr>
<tr class="separator:a52caf415e26784864b15d1805ff7989a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f1267836a46dfedf7588466f02db90"><td class="memItemLeft" align="right" valign="top"><a id="a46f1267836a46dfedf7588466f02db90"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Adam, <a class="el" href="classcaffe2_1_1AdamOp.html">AdamOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a46f1267836a46dfedf7588466f02db90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb9c02da85ef7f7bb4992d8bad3f48c"><td class="memItemLeft" align="right" valign="top"><a id="a6eb9c02da85ef7f7bb4992d8bad3f48c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (6) .NumOutputs(3) .AllowInplace(</td></tr>
<tr class="separator:a6eb9c02da85ef7f7bb4992d8bad3f48c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37808b7f9bbc2c904aee7b461146ff87"><td class="memItemLeft" align="right" valign="top"><a id="a37808b7f9bbc2c904aee7b461146ff87"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(

Computes the Adam update (https://arxiv.org/abs/1412.6980) for an
input gradient and momentum parameters. Concretely, given inputs
(param, m1, m2, grad, lr, iters),

    t = iters + 1
    corrected_local_rate = lr * sqrt(1 - power(beta2, t)) /
      (1 - power(beta1, t))
    m1_o = (beta1 * m1) + (1 - beta1) * grad
    m2_o = (beta2 * m2) + (1 - beta2) * np.square(grad)
    grad_o = corrected_local_rate * m1_o / \       (sqrt(m2_o) + epsilon)
    param_o = param + grad_o

and returns (param_o, m1_o, m2_o)

)DOC&quot;) .Input(0</td></tr>
<tr class="separator:a37808b7f9bbc2c904aee7b461146ff87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5090d77f6f86adf4e34a2d33ece951c"><td class="memItemLeft" align="right" valign="top"><a id="af5090d77f6f86adf4e34a2d33ece951c"></a>
Parameters to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;moment_1&quot;, &quot;First moment history&quot;) .Input(2</td></tr>
<tr class="separator:af5090d77f6f86adf4e34a2d33ece951c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c7acfd65ab5128b3ae413ce8bff1d0"><td class="memItemLeft" align="right" valign="top"><a id="a56c7acfd65ab5128b3ae413ce8bff1d0"></a>
Parameters to be updated Second moment history learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (5, &quot;iter&quot;, &quot;iteration number&quot;) .Output(0</td></tr>
<tr class="separator:a56c7acfd65ab5128b3ae413ce8bff1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144ab0120d42e4b21aadcf2fae42128e"><td class="memItemLeft" align="right" valign="top"><a id="a144ab0120d42e4b21aadcf2fae42128e"></a>
Parameters to be updated Second moment history learning rate Updated parameters&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1, &quot;output_moment_1&quot;, &quot;Updated first moment&quot;) .Output(2</td></tr>
<tr class="separator:a144ab0120d42e4b21aadcf2fae42128e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e440606338bf9dec528ed9ff1a5e02"><td class="memItemLeft" align="right" valign="top"><a id="ab2e440606338bf9dec528ed9ff1a5e02"></a>
Parameters to be updated Second moment history learning rate Updated parameters Updated second moment&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;beta1&quot;, &quot;Default 0.9&quot;) .Arg(&quot;beta2&quot;</td></tr>
<tr class="separator:ab2e440606338bf9dec528ed9ff1a5e02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9f6b19d8ef9b88e5951823b273ca77"><td class="memItemLeft" align="right" valign="top"><a id="a1e9f6b19d8ef9b88e5951823b273ca77"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseAdam, <a class="el" href="classcaffe2_1_1SparseAdamOp.html">SparseAdamOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a1e9f6b19d8ef9b88e5951823b273ca77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a33a96f797f4d0e764f06f3c7dbbc0c"><td class="memItemLeft" align="right" valign="top"><a id="a3a33a96f797f4d0e764f06f3c7dbbc0c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(

Computes the Adam Update for the sparse case.
Given inputs (param, moment1, moment2, indices, grad, lr, iter), runs the dense
Adam on (param, moment1[indices], momemnt2[indices], lr, iter) and returns
(new_param, new_moment1, new_moment2) as in dense case

)DOC&quot;) .Input(0</td></tr>
<tr class="separator:a3a33a96f797f4d0e764f06f3c7dbbc0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9438f581de5d6b2e2083fbceac340675"><td class="memItemLeft" align="right" valign="top"><a id="a9438f581de5d6b2e2083fbceac340675"></a>
Parameters to be updated Second moment history&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3, &quot;indices&quot;, &quot;Sparse indices&quot;) .Input(4</td></tr>
<tr class="separator:a9438f581de5d6b2e2083fbceac340675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05b58697ed6b162a9442e976a4734dc"><td class="memItemLeft" align="right" valign="top"><a id="ad05b58697ed6b162a9442e976a4734dc"></a>
Parameters to be updated Second moment history Gradient computed&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (5, &quot;lr&quot;, &quot;learning rate&quot;) .Input(6</td></tr>
<tr class="separator:ad05b58697ed6b162a9442e976a4734dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2efd2b48cd39137c629589925a6d98"><td class="memItemLeft" align="right" valign="top"><a id="a1e2efd2b48cd39137c629589925a6d98"></a>
Parameters to be updated Second moment history Gradient computed iteration number Updated first moment&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (2, &quot;output_moment_2&quot;, &quot;Updated second moment&quot;) .Arg(&quot;beta1&quot;</td></tr>
<tr class="separator:a1e2efd2b48cd39137c629589925a6d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df0ee66f914c57eef5bb91b199544c8"><td class="memItemLeft" align="right" valign="top"><a id="a9df0ee66f914c57eef5bb91b199544c8"></a>
Parameters to be updated Second moment history Gradient computed iteration number Updated first moment Default&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;beta2&quot;, &quot;Default 0.999&quot;) .Arg(&quot;epsilon&quot;</td></tr>
<tr class="separator:a9df0ee66f914c57eef5bb91b199544c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4750713478bdc53029a1d45b53e2a6"><td class="memItemLeft" align="right" valign="top"><a id="a5f4750713478bdc53029a1d45b53e2a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (Adam)</td></tr>
<tr class="separator:a5f4750713478bdc53029a1d45b53e2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4918dbf8c1590d5dc79bafa7cdf29f8"><td class="memItemLeft" align="right" valign="top"><a id="aa4918dbf8c1590d5dc79bafa7cdf29f8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (SparseAdam)</td></tr>
<tr class="separator:aa4918dbf8c1590d5dc79bafa7cdf29f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad673b1c06055f145a885459af259d9"><td class="memTemplParams" colspan="2"><a id="aaad673b1c06055f145a885459af259d9"></a>
template&lt;typename Context &gt; </td></tr>
<tr class="memitem:aaad673b1c06055f145a885459af259d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>adam_update</b> (int N, const float *g, const float *m, const float *v, float *ng, float *nm, float *nv, float beta1, float beta2, float eps_hat, float correction, const float *lr, Context *)</td></tr>
<tr class="separator:aaad673b1c06055f145a885459af259d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a21d356a425abb26679238d3e423d3"><td class="memTemplParams" colspan="2"><a id="a13a21d356a425abb26679238d3e423d3"></a>
template&lt;typename Context &gt; </td></tr>
<tr class="memitem:a13a21d356a425abb26679238d3e423d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>adam_compute</b> (int N, const float *w, const float *g, const float *m, const float *v, float *nw, float *nm, float *nv, float beta1, float beta2, float eps_hat, float correction, const float *lr, Context *)</td></tr>
<tr class="separator:a13a21d356a425abb26679238d3e423d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add629e670381f07181b2d11b67f60159"><td class="memTemplParams" colspan="2"><a id="add629e670381f07181b2d11b67f60159"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:add629e670381f07181b2d11b67f60159"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fp16_momentum_sgd_update</b> (int N, const float16 *g, const float16 *m, float16 *ng, float16 *nm, const float *lr, float momentum, bool nesterov, float weight_decay, bool fp32_update, float16 *param, Context *)</td></tr>
<tr class="separator:add629e670381f07181b2d11b67f60159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc3e89243f7989891f1e3a3f5c36d24"><td class="memTemplParams" colspan="2"><a id="aafc3e89243f7989891f1e3a3f5c36d24"></a>
template&lt;class Context &gt; </td></tr>
<tr class="memitem:aafc3e89243f7989891f1e3a3f5c36d24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fp32_momentum_sgd_update</b> (int N, const float *g, const float *m, float *ng, float *nm, const float *lr, float momentum, bool nesterov, float weight_decay, float *param, Context *)</td></tr>
<tr class="separator:aafc3e89243f7989891f1e3a3f5c36d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a5937c8436cf4791e689d943200c7a"><td class="memTemplParams" colspan="2"><a id="a16a5937c8436cf4791e689d943200c7a"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a16a5937c8436cf4791e689d943200c7a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sgn</b> (const T x)</td></tr>
<tr class="separator:a16a5937c8436cf4791e689d943200c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8705b9ad77634eb047afca0b24737e0c"><td class="memTemplParams" colspan="2"><a id="a8705b9ad77634eb047afca0b24737e0c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8705b9ad77634eb047afca0b24737e0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ftrl_compute</b> (const T w, const T n, const T z, const T g, T &amp;nw, T &amp;nn, T &amp;nz, const <a class="el" href="structcaffe2_1_1FtrlParams.html">FtrlParams</a>&lt; T &gt; &amp;params)</td></tr>
<tr class="separator:a8705b9ad77634eb047afca0b24737e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d83bad64c7bb33db49c289d7b61f78"><td class="memTemplParams" colspan="2"><a id="ab5d83bad64c7bb33db49c289d7b61f78"></a>
template&lt;typename Context , typename T &gt; </td></tr>
<tr class="memitem:ab5d83bad64c7bb33db49c289d7b61f78"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ftrl_update</b> (int N, const T *w, const T *nz, const T *g, T *new_w, T *new_nz, const <a class="el" href="structcaffe2_1_1FtrlParams.html">FtrlParams</a>&lt; T &gt; &amp;params, Context *)</td></tr>
<tr class="separator:ab5d83bad64c7bb33db49c289d7b61f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62eb2309a93b3e4e1b0858c6ceeefbd5"><td class="memItemLeft" align="right" valign="top"><a id="a62eb2309a93b3e4e1b0858c6ceeefbd5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Iter, <a class="el" href="classcaffe2_1_1IterOp.html">IterOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a62eb2309a93b3e4e1b0858c6ceeefbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d2904a82671957e8cb3d50705d05f9"><td class="memItemLeft" align="right" valign="top"><a id="ab8d2904a82671957e8cb3d50705d05f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (AtomicIter, <a class="el" href="classcaffe2_1_1AtomicIterOp.html">AtomicIterOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ab8d2904a82671957e8cb3d50705d05f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90b4bd2ed2e46b5c17a1400c46aeb75"><td class="memItemLeft" align="right" valign="top"><a id="ac90b4bd2ed2e46b5c17a1400c46aeb75"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_BLOB_SERIALIZER</b> ((<a class="el" href="classcaffe2_1_1TypeMeta.html#a0b050c4a9e4e5b2f9e099b0f2a6db019">TypeMeta::Id</a>&lt; std::unique_ptr&lt; std::mutex &gt;&gt;()), <a class="el" href="classcaffe2_1_1MutexSerializer.html">MutexSerializer</a>)</td></tr>
<tr class="separator:ac90b4bd2ed2e46b5c17a1400c46aeb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76ee30697814ee55ca6b7c2401cf927"><td class="memItemLeft" align="right" valign="top"><a id="aa76ee30697814ee55ca6b7c2401cf927"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_BLOB_DESERIALIZER</b> (std::unique_ptr&lt; std::mutex &gt;, <a class="el" href="classcaffe2_1_1MutexDeserializer.html">MutexDeserializer</a>)</td></tr>
<tr class="separator:aa76ee30697814ee55ca6b7c2401cf927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f038928b82ec9c9b9521bc80ffc83a7"><td class="memItemLeft" align="right" valign="top"><a id="a5f038928b82ec9c9b9521bc80ffc83a7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Stores a singe integer, that gets incremented on each call to Run().
Useful for tracking the iteration count during SGD, for example.
)DOC&quot;)</td></tr>
<tr class="separator:a5f038928b82ec9c9b9521bc80ffc83a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4877602b88ed371df5959f15e3d2b2d5"><td class="memItemLeft" align="right" valign="top"><a id="a4877602b88ed371df5959f15e3d2b2d5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
Similar to Iter, but takes a mutex as the first input to make sure that
updates are carried out atomically. This can be used in e.g. Hogwild sgd
algorithms.
)DOC&quot;) .Input(0</td></tr>
<tr class="separator:a4877602b88ed371df5959f15e3d2b2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46909fd86c9584cf1d83eed0ee34dfd"><td class="memItemLeft" align="right" valign="top"><a id="ab46909fd86c9584cf1d83eed0ee34dfd"></a>
The mutex used to do atomic increment&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;iter&quot;, &quot;The iter counter as an int64_t TensorCPU.&quot;)</td></tr>
<tr class="separator:ab46909fd86c9584cf1d83eed0ee34dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac719df125c37019704abe5c7f53ea318"><td class="memItemLeft" align="right" valign="top"><a id="ac719df125c37019704abe5c7f53ea318"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (Iter)</td></tr>
<tr class="separator:ac719df125c37019704abe5c7f53ea318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca995e1c8a5d198e1ce9945d43079b9"><td class="memItemLeft" align="right" valign="top"><a id="a4ca995e1c8a5d198e1ce9945d43079b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (AtomicIter)</td></tr>
<tr class="separator:a4ca995e1c8a5d198e1ce9945d43079b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153f3c396bac274030d0fb5fe7421585"><td class="memItemLeft" align="right" valign="top"><a id="a153f3c396bac274030d0fb5fe7421585"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>IncrementIter</b> (<a class="el" href="classcaffe2_1_1Tensor.html">TensorCPU</a> *output)</td></tr>
<tr class="separator:a153f3c396bac274030d0fb5fe7421585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a257144a05c7bc7118a38c1682b3f2d7c"><td class="memItemLeft" align="right" valign="top"><a id="a257144a05c7bc7118a38c1682b3f2d7c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (Iter, <a class="el" href="classcaffe2_1_1IterOp.html">IterOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:a257144a05c7bc7118a38c1682b3f2d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccb1da1f9193dd20fadb69e7588b852"><td class="memItemLeft" align="right" valign="top"><a id="adccb1da1f9193dd20fadb69e7588b852"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (AtomicIter, <a class="el" href="classcaffe2_1_1AtomicIterOp.html">AtomicIterOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:adccb1da1f9193dd20fadb69e7588b852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebe1cda68cef6846906968b891c98b0"><td class="memItemLeft" align="right" valign="top"><a id="a8ebe1cda68cef6846906968b891c98b0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (LearningRate, <a class="el" href="classcaffe2_1_1LearningRateOp.html">LearningRateOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a8ebe1cda68cef6846906968b891c98b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f81397a4037790bd3c31b33e1372b1"><td class="memItemLeft" align="right" valign="top"><a id="aa7f81397a4037790bd3c31b33e1372b1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (LearningRate, <a class="el" href="classcaffe2_1_1LearningRateOp.html">LearningRateOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:aa7f81397a4037790bd3c31b33e1372b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06058e388890cc66dcfe34c26887b400"><td class="memItemLeft" align="right" valign="top"><a id="a06058e388890cc66dcfe34c26887b400"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MomentumSGD, <a class="el" href="classcaffe2_1_1MomentumSGDOp.html">MomentumSGDOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a06058e388890cc66dcfe34c26887b400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2590ae79c9009f4f062451de8cfd03"><td class="memItemLeft" align="right" valign="top"><a id="a4c2590ae79c9009f4f062451de8cfd03"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> ([](const OperatorDef &amp;, const vector&lt; TensorShape &gt; &amp;in) { vector&lt; TensorShape &gt; out(2);out[0]=in[0];out[1]=in[1];return out;}) .SetDoc(R&quot;DOC( Computes a momentum SGD update for an input gradient and momentum parameters. Concretely</td></tr>
<tr class="separator:a4c2590ae79c9009f4f062451de8cfd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d02bdb33af75f50e798248acb9b04f1"><td class="memItemLeft" align="right" valign="top"><a id="a0d02bdb33af75f50e798248acb9b04f1"></a>
given&#160;</td><td class="memItemRight" valign="bottom"><b>inputs</b> (grad, m, lr) and parameters(momentum</td></tr>
<tr class="separator:a0d02bdb33af75f50e798248acb9b04f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be29eecd8f5475a405b86e6ea2cd828"><td class="memItemLeft" align="right" valign="top"><a id="a6be29eecd8f5475a405b86e6ea2cd828"></a>
given adjusted_gradient m_new Output&#160;</td><td class="memItemRight" valign="bottom"><b>is</b> (grad, momentum) Note the difference to MomemtumSGDUpdate</td></tr>
<tr class="separator:a6be29eecd8f5475a405b86e6ea2cd828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aff43e7aa0ccff31188a67b364eeb76"><td class="memItemLeft" align="right" valign="top"><a id="a6aff43e7aa0ccff31188a67b364eeb76"></a>
given adjusted_gradient m_new Output which actually performs the parameter&#160;</td><td class="memItemRight" valign="bottom"><b>update</b> (and is thus faster).) DOC&quot;)</td></tr>
<tr class="separator:a6aff43e7aa0ccff31188a67b364eeb76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888fa7c9e77dc141bbdded7fa03766d8"><td class="memItemLeft" align="right" valign="top"><a id="a888fa7c9e77dc141bbdded7fa03766d8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (MomentumSGD)</td></tr>
<tr class="separator:a888fa7c9e77dc141bbdded7fa03766d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f8dc6505fb594b1ea42226095c7df3"><td class="memItemLeft" align="right" valign="top"><a id="a02f8dc6505fb594b1ea42226095c7df3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (MomentumSGDUpdate, <a class="el" href="classcaffe2_1_1MomentumSGDUpdateOp.html">MomentumSGDUpdateOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a02f8dc6505fb594b1ea42226095c7df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cf5267202ee7f19dcc17da1ab2334c"><td class="memItemLeft" align="right" valign="top"><a id="a56cf5267202ee7f19dcc17da1ab2334c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TensorInferenceFunction</b> ([](const OperatorDef &amp;, const vector&lt; TensorShape &gt; &amp;in) { vector&lt; TensorShape &gt; out(3);out[0]=in[0];out[1]=in[1];out[2]=in[3];return out;}) .SetDoc(R&quot;DOC( Performs a momentum SGD update for an input gradient and momentum parameters. Concretely</td></tr>
<tr class="separator:a56cf5267202ee7f19dcc17da1ab2334c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d337e8e55be7b94f9687b45e9c22b72"><td class="memItemLeft" align="right" valign="top"><a id="a5d337e8e55be7b94f9687b45e9c22b72"></a>
given&#160;</td><td class="memItemRight" valign="bottom"><b>inputs</b> (grad, m, lr, param) and arguments(momentum</td></tr>
<tr class="separator:a5d337e8e55be7b94f9687b45e9c22b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51afa8a3eff6a21f17d111e525bb1eab"><td class="memItemLeft" align="right" valign="top"><a id="a51afa8a3eff6a21f17d111e525bb1eab"></a>
given param&#160;</td><td class="memItemRight" valign="bottom"><b>return</b> ((1+momentum) *m_new - momentum *m, m_new, param) Output is(grad</td></tr>
<tr class="separator:a51afa8a3eff6a21f17d111e525bb1eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2fc43856b6b48cefada73f27cb3618"><td class="memItemLeft" align="right" valign="top"><a id="a1e2fc43856b6b48cefada73f27cb3618"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (MomentumSGDUpdate)</td></tr>
<tr class="separator:a1e2fc43856b6b48cefada73f27cb3618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29067a3f5dbbdcb2140b3ee9bc7a0644"><td class="memItemLeft" align="right" valign="top"><a id="a29067a3f5dbbdcb2140b3ee9bc7a0644"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (SparseMomentumSGDUpdate, <a class="el" href="classcaffe2_1_1SparseMomentumSGDUpdateOp.html">SparseMomentumSGDUpdateOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a29067a3f5dbbdcb2140b3ee9bc7a0644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722a012d1af34e7a851824e90982e3ad"><td class="memItemLeft" align="right" valign="top"><a id="a722a012d1af34e7a851824e90982e3ad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EnforceInplace</b> ({{1, 1}, {3, 2}}) .TensorInferenceFunction([](const OperatorDef &amp;</td></tr>
<tr class="separator:a722a012d1af34e7a851824e90982e3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171e6fde935ded428c0f40338849193b"><td class="memItemLeft" align="right" valign="top"><a id="a171e6fde935ded428c0f40338849193b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(

Performs a momentum SGD update analogous to MomentumSGDUpdate, but using a
GradientSlice and indices into the full param and momentum tables. Both param
and momentum should be in-place (corresponding inputs and outputs should be the
same blobs).



)DOC&quot;) .Input(0</td></tr>
<tr class="separator:a171e6fde935ded428c0f40338849193b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7bf4c2361295cefe92809f812440a2"><td class="memItemLeft" align="right" valign="top"><a id="a5d7bf4c2361295cefe92809f812440a2"></a>
GradientSlice with gradients for updated indices&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;moment&quot;, &quot;Momentum blob, same shape as param.&quot;) .Input(2</td></tr>
<tr class="separator:a5d7bf4c2361295cefe92809f812440a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61490e57097e0ea32e33ed7126a5e2c"><td class="memItemLeft" align="right" valign="top"><a id="ae61490e57097e0ea32e33ed7126a5e2c"></a>
GradientSlice with gradients for updated indices Learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3, &quot;param&quot;, &quot;Full parameter blob.&quot;) .Input(4</td></tr>
<tr class="separator:ae61490e57097e0ea32e33ed7126a5e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df01e983d4971cc151e5245a0e6023e"><td class="memItemLeft" align="right" valign="top"><a id="a9df01e983d4971cc151e5245a0e6023e"></a>
GradientSlice with gradients for updated indices Learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>Indices</b> (in first dimension of param) where updates are performed.&quot;) .Output(0</td></tr>
<tr class="separator:a9df01e983d4971cc151e5245a0e6023e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e0a5469c7167a8750215c9948579bd"><td class="memItemLeft" align="right" valign="top"><a id="a37e0a5469c7167a8750215c9948579bd"></a>
GradientSlice with gradients for updated indices Learning rate Adjusted gradient&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1, &quot;output_moment&quot;, &quot;Updated momentum.&quot;) .Output(2</td></tr>
<tr class="separator:a37e0a5469c7167a8750215c9948579bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5766c459874e455afda8ecf58e2cf21"><td class="memItemLeft" align="right" valign="top"><a id="ae5766c459874e455afda8ecf58e2cf21"></a>
GradientSlice with gradients for updated indices Learning rate Adjusted gradient Updated parameter&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;momentum&quot;, &quot;Momentum hyperparameter.&quot;) .Arg(&quot;nesterov&quot;</td></tr>
<tr class="separator:ae5766c459874e455afda8ecf58e2cf21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadde0286b179d85bed73ee10dcc51b68"><td class="memItemLeft" align="right" valign="top"><a id="aadde0286b179d85bed73ee10dcc51b68"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (SparseMomentumSGDUpdate)</td></tr>
<tr class="separator:aadde0286b179d85bed73ee10dcc51b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6ad2b102c2dbbb3ee0e6008974d60d"><td class="memTemplParams" colspan="2"><a id="a3c6ad2b102c2dbbb3ee0e6008974d60d"></a>
template&lt;typename Context &gt; </td></tr>
<tr class="memitem:a3c6ad2b102c2dbbb3ee0e6008974d60d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>momentum_sgd_update</b> (const int N, const float *g, const float *m, float *ng, float *nm, const float *lr, const float momentum, const bool nesterov, float *param, Context *)</td></tr>
<tr class="separator:a3c6ad2b102c2dbbb3ee0e6008974d60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3024274d23e0aa690e9ede7b3e79ecb2"><td class="memTemplParams" colspan="2"><a id="a3024274d23e0aa690e9ede7b3e79ecb2"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a3024274d23e0aa690e9ede7b3e79ecb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rmsprop_update&lt; CPUContext &gt;</b> (int N, const float *g, const float *ms, const float *mom, float *ng, float *nms, float *nmom, float decay, float momentum, float epsilon, const float *lr, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> *)</td></tr>
<tr class="separator:a3024274d23e0aa690e9ede7b3e79ecb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b90ea97be1a556b20e63346816d4f0"><td class="memItemLeft" align="right" valign="top"><a id="a97b90ea97be1a556b20e63346816d4f0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (RmsProp, <a class="el" href="classcaffe2_1_1RmsPropOp.html">RmsPropOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a97b90ea97be1a556b20e63346816d4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b0208e81d09b152dcd96b1273453b2"><td class="memItemLeft" align="right" valign="top"><a id="a97b0208e81d09b152dcd96b1273453b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(

Computes the RMSProp update
(http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf).
Concretely, given inputs (grad, mean_squares, mom, lr), computes:

    mean_squares_o = mean_squares + (1 - decay) * (square(grad) - mean_squares)
    mom_o = momentum * mom + lr * grad / sqrt(epsilon + mean_squares_o)
    grad_o = mom_o

returns (grad_o, mean_squares_o, mom_o).

)DOC&quot;)</td></tr>
<tr class="separator:a97b0208e81d09b152dcd96b1273453b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e7a8e73e8793ec9ee086c500e62e2f"><td class="memItemLeft" align="right" valign="top"><a id="ab8e7a8e73e8793ec9ee086c500e62e2f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (RmsProp)</td></tr>
<tr class="separator:ab8e7a8e73e8793ec9ee086c500e62e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1cbdf70bb22108c3b37d00943ca4b3"><td class="memTemplParams" colspan="2"><a id="a7c1cbdf70bb22108c3b37d00943ca4b3"></a>
template&lt;typename Context &gt; </td></tr>
<tr class="memitem:a7c1cbdf70bb22108c3b37d00943ca4b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>rmsprop_update</b> (int N, const float *g, const float *ms, const float *mom, float *ng, float *nms, float *nmom, float decay, float momentum, float epsilon, const float *lr, Context *context)</td></tr>
<tr class="separator:a7c1cbdf70bb22108c3b37d00943ca4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6241feb2dd8e48a9a813cc86874c140"><td class="memItemLeft" align="right" valign="top"><a id="ad6241feb2dd8e48a9a813cc86874c140"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (YellowFin, <a class="el" href="classcaffe2_1_1YellowFinOp.html">YellowFinOp</a>&lt; float, <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:ad6241feb2dd8e48a9a813cc86874c140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701e0c4184dbfcbce0df567173295942"><td class="memItemLeft" align="right" valign="top"><a id="a701e0c4184dbfcbce0df567173295942"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (10) .NumOutputs(8) .AllowInplace(</td></tr>
<tr class="separator:a701e0c4184dbfcbce0df567173295942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47bb8b328b085804c24f8a4f228bd0d"><td class="memItemLeft" align="right" valign="top"><a id="aa47bb8b328b085804c24f8a4f228bd0d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(

Computes the YellowFin update (https://arxiv.org/abs/1706.03471) and performs
momentum SGD optimization step. lr and mu are not being shared between
parameters. curv_win, g_avg, g2_avg and scalars_memory are just auxiliary
memory for computing moving averages (see the publication). Takes arguments
beta: coefficient for moving averages,
curv_win_width: timeframe when average squared gradient is being stored,
epsilon: for numerical purposes,
nesterov and zero_debias for debias of moving average.

)DOC&quot;) .Input(0</td></tr>
<tr class="separator:aa47bb8b328b085804c24f8a4f228bd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1090edcdc963f94934d8734768423f7"><td class="memItemLeft" align="right" valign="top"><a id="ac1090edcdc963f94934d8734768423f7"></a>
Parameters to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (1, &quot;moment&quot;, &quot;Momentum&quot;) .Input(2</td></tr>
<tr class="separator:ac1090edcdc963f94934d8734768423f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fdb0c5ff318e5300a05918d1f64427"><td class="memItemLeft" align="right" valign="top"><a id="a86fdb0c5ff318e5300a05918d1f64427"></a>
Parameters to be updated Learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (3, &quot;mu&quot;, &quot;Momentum coefficient&quot;) .Input(4</td></tr>
<tr class="separator:a86fdb0c5ff318e5300a05918d1f64427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b8b34757d3fe5518e51dd6111efb1a"><td class="memItemLeft" align="right" valign="top"><a id="a72b8b34757d3fe5518e51dd6111efb1a"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (5, &quot;g_avg&quot;, &quot;Moving average of gradient&quot;) .Input(6</td></tr>
<tr class="separator:a72b8b34757d3fe5518e51dd6111efb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d98dd8d97264d94cd6f901e2144c1c7"><td class="memItemLeft" align="right" valign="top"><a id="a8d98dd8d97264d94cd6f901e2144c1c7"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (7, &quot;scalars_memory&quot;, &quot;Memory for stateful scalars&quot;) .Input(8</td></tr>
<tr class="separator:a8d98dd8d97264d94cd6f901e2144c1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10880c1cbb853cf6052e25711ca1df98"><td class="memItemLeft" align="right" valign="top"><a id="a10880c1cbb853cf6052e25711ca1df98"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed&#160;</td><td class="memItemRight" valign="bottom"><b>Input</b> (9, &quot;iter&quot;, &quot;Iteration number&quot;) .Output(0</td></tr>
<tr class="separator:a10880c1cbb853cf6052e25711ca1df98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034890ca64d4e57601c93bbf8071c758"><td class="memItemLeft" align="right" valign="top"><a id="a034890ca64d4e57601c93bbf8071c758"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed Parameters to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (1, &quot;output_moment&quot;, &quot;Momentum&quot;) .Output(2</td></tr>
<tr class="separator:a034890ca64d4e57601c93bbf8071c758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19217ceee3f563023356453536754504"><td class="memItemLeft" align="right" valign="top"><a id="a19217ceee3f563023356453536754504"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed Parameters to be updated Output learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (3, &quot;output_mu&quot;, &quot;Output momentum coefficient&quot;) .Output(4</td></tr>
<tr class="separator:a19217ceee3f563023356453536754504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6419c9d8654c862ead5e3e18f78f671e"><td class="memItemLeft" align="right" valign="top"><a id="a6419c9d8654c862ead5e3e18f78f671e"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed Parameters to be updated Output learning rate Output memory for latest curvature ranges&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (5, &quot;output_g_avg&quot;, &quot;Output moving average of gradient&quot;) .Output(6</td></tr>
<tr class="separator:a6419c9d8654c862ead5e3e18f78f671e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fee0080d8264200d19a666200d588fc"><td class="memItemLeft" align="right" valign="top"><a id="a3fee0080d8264200d19a666200d588fc"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed Parameters to be updated Output learning rate Output memory for latest curvature ranges Output moving average of squared gradient&#160;</td><td class="memItemRight" valign="bottom"><b>Output</b> (7, &quot;output_scalars_memory&quot;, &quot;Output memory for stateful scalars&quot;) .Arg(&quot;beta&quot;</td></tr>
<tr class="separator:a3fee0080d8264200d19a666200d588fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e7a5235e90d30dcacb8916147115d1"><td class="memItemLeft" align="right" valign="top"><a id="a85e7a5235e90d30dcacb8916147115d1"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed Parameters to be updated Output learning rate Output memory for latest curvature ranges Output moving average of squared gradient Default&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;curv_win_width&quot;, &quot;Default 20&quot;) .Arg(&quot;epsilon&quot;</td></tr>
<tr class="separator:a85e7a5235e90d30dcacb8916147115d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d7b6cfd8606c0e9d19e702e4798b5b"><td class="memItemLeft" align="right" valign="top"><a id="a86d7b6cfd8606c0e9d19e702e4798b5b"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed Parameters to be updated Output learning rate Output memory for latest curvature ranges Output moving average of squared gradient Default Default&#160;</td><td class="memItemRight" valign="bottom"><b>Arg</b> (&quot;nesterov&quot;, &quot;Default false&quot;) .Arg(&quot;zero_debias&quot;</td></tr>
<tr class="separator:a86d7b6cfd8606c0e9d19e702e4798b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614581fe220bb4852ba056a8ef579a29"><td class="memItemLeft" align="right" valign="top"><a id="a614581fe220bb4852ba056a8ef579a29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (YellowFin)</td></tr>
<tr class="separator:a614581fe220bb4852ba056a8ef579a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad138bc472309a6859cd5a50fb4dc64ae"><td class="memItemLeft" align="right" valign="top"><a id="ad138bc472309a6859cd5a50fb4dc64ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>initNNPACK</b> ()</td></tr>
<tr class="separator:ad138bc472309a6859cd5a50fb4dc64ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79995aa56787333ca75efbbb79c8bc61"><td class="memItemLeft" align="right" valign="top"><a id="a79995aa56787333ca75efbbb79c8bc61"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR_WITH_ENGINE</b> (Conv, NNPACK, <a class="el" href="classcaffe2_1_1NNPACKConvOp.html">NNPACKConvOp</a>)</td></tr>
<tr class="separator:a79995aa56787333ca75efbbb79c8bc61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd050498d59ac5ef9339d349f0c7b8dd"><td class="memItemLeft" align="right" valign="top"><a id="acd050498d59ac5ef9339d349f0c7b8dd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CAFFE2_EARLY_INIT_FUNCTION</b> (registerGlobalPerfNetObserverReporter, &amp;registerGlobalPerfNetObserverReporter, &quot;Caffe2 print net observer reporter&quot;)</td></tr>
<tr class="separator:acd050498d59ac5ef9339d349f0c7b8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b80f7cccd2721bdc0b6e3dd0229f447"><td class="memItemLeft" align="right" valign="top"><a id="a0b80f7cccd2721bdc0b6e3dd0229f447"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CAFFE2_EARLY_INIT_FUNCTION</b> (registerGlobalPerfNetObserverCreator, &amp;registerGlobalPerfNetObserverCreator, &quot;Caffe2 net global observer creator&quot;)</td></tr>
<tr class="separator:a0b80f7cccd2721bdc0b6e3dd0229f447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac251f4b88db090cb5d63c9e0cc783f91"><td class="memItemLeft" align="right" valign="top"><a id="ac251f4b88db090cb5d63c9e0cc783f91"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (QuantDecompZstd, <a class="el" href="classcaffe2_1_1QuantDecompZstdOp.html">QuantDecompZstdOp</a>)</td></tr>
<tr class="separator:ac251f4b88db090cb5d63c9e0cc783f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13adadeb981cc6358bb8e7df90fec9b"><td class="memItemLeft" align="right" valign="top"><a id="ae13adadeb981cc6358bb8e7df90fec9b"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>SetDoc</b> (R&quot;DOC(
 Decompress a set of tensors that are compressed using zstd.
 The data can be compressed using mutils.compress_data_list(), see
 quant_decomp_op_test.py for an example.
 The number of outputs depended on the input.
 )DOC&quot;) .Input(0</td></tr>
<tr class="separator:ae13adadeb981cc6358bb8e7df90fec9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcf58f3d62b4c9b0cf0ec94d0ef41f1"><td class="memItemLeft" align="right" valign="top"><a id="a1bcf58f3d62b4c9b0cf0ec94d0ef41f1"></a>
INT_MAX Compressed data in&#160;</td><td class="memItemRight" valign="bottom"><b>tensor</b> (uint8_t)</td></tr>
<tr class="separator:a1bcf58f3d62b4c9b0cf0ec94d0ef41f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f092565e57a6cc19c9457cee62adc9"><td class="memItemLeft" align="right" valign="top"><a id="ab0f092565e57a6cc19c9457cee62adc9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SHOULD_NOT_DO_GRADIENT</b> (QuantDecompZstd)</td></tr>
<tr class="separator:ab0f092565e57a6cc19c9457cee62adc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a308109b3449984670fb7857df21939"><td class="memItemLeft" align="right" valign="top"><a id="a2a308109b3449984670fb7857df21939"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>are_nodes_common</b> (const <a class="el" href="structcaffe2_1_1transform_1_1Graph.html">Graph</a> &amp;g, int model_idx, int candidate_idx)</td></tr>
<tr class="separator:a2a308109b3449984670fb7857df21939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e71d23701ed932b2aa1aeecfb50418"><td class="memItemLeft" align="right" valign="top"><a id="ad2e71d23701ed932b2aa1aeecfb50418"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_TRANSFORM</b> (CommonSubexpressionElimination, <a class="el" href="classcaffe2_1_1CommonSubexpressionEliminationTransform.html">CommonSubexpressionEliminationTransform</a>)</td></tr>
<tr class="separator:ad2e71d23701ed932b2aa1aeecfb50418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8514f554606ce65accb85d0fe3d8de86"><td class="memItemLeft" align="right" valign="top"><a id="a8514f554606ce65accb85d0fe3d8de86"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_TRANSFORM</b> (ConvToNNPack, <a class="el" href="classcaffe2_1_1ConvToNNPackTransform.html">ConvToNNPackTransform</a>)</td></tr>
<tr class="separator:a8514f554606ce65accb85d0fe3d8de86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4de906b41a8aabb7bdddcf918de41a5"><td class="memItemLeft" align="right" valign="top"><a id="ac4de906b41a8aabb7bdddcf918de41a5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>compare_ops</b> (const OperatorDef &amp;p_op, const OperatorDef &amp;g_op, bool arg_match)</td></tr>
<tr class="separator:ac4de906b41a8aabb7bdddcf918de41a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bd2b58cb62675d3618b8e13541c192"><td class="memItemLeft" align="right" valign="top"><a id="ae9bd2b58cb62675d3618b8e13541c192"></a>
const <a class="el" href="classcaffe2_1_1CpuId.html">CpuId</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetCpuId</b> ()</td></tr>
<tr class="separator:ae9bd2b58cb62675d3618b8e13541c192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141c2c5e0b2a5195f016cb34f35f8cd6"><td class="memTemplParams" colspan="2"><a id="a141c2c5e0b2a5195f016cb34f35f8cd6"></a>
template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a141c2c5e0b2a5195f016cb34f35f8cd6"><td class="memTemplItemLeft" align="right" valign="top">__device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mixed_mult</b> (T data1, T2 data2)</td></tr>
<tr class="separator:a141c2c5e0b2a5195f016cb34f35f8cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f1108b7f0508e53032fbc8ef9956cb"><td class="memTemplParams" colspan="2"><a id="ac1f1108b7f0508e53032fbc8ef9956cb"></a>
template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:ac1f1108b7f0508e53032fbc8ef9956cb"><td class="memTemplItemLeft" align="right" valign="top">__device__ T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mixed_add</b> (T data1, T2 data2)</td></tr>
<tr class="separator:ac1f1108b7f0508e53032fbc8ef9956cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801c105f14153aaca6e1cce8fb308941"><td class="memTemplParams" colspan="2"><a id="a801c105f14153aaca6e1cce8fb308941"></a>
template&lt;typename TIN , typename TOUT &gt; </td></tr>
<tr class="memitem:a801c105f14153aaca6e1cce8fb308941"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mixed_store</b> (TIN *data_in, TOUT *data_out)</td></tr>
<tr class="separator:a801c105f14153aaca6e1cce8fb308941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa52b1b197a9ab0e10a5b74b09aeac4"><td class="memTemplParams" colspan="2"><a id="aeaa52b1b197a9ab0e10a5b74b09aeac4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeaa52b1b197a9ab0e10a5b74b09aeac4"><td class="memTemplItemLeft" align="right" valign="top">__device__ void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>mixed_store</b> (T *data_in, T *data_out)</td></tr>
<tr class="separator:aeaa52b1b197a9ab0e10a5b74b09aeac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da9c276eaa60e471e5782245870b763"><td class="memItemLeft" align="right" valign="top"><a id="a3da9c276eaa60e471e5782245870b763"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MurmurHash3_x86_32</b> (const void *key, int len, uint32_t seed, void *out)</td></tr>
<tr class="separator:a3da9c276eaa60e471e5782245870b763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be24256e9245ccd71c0b012ad4f45b4"><td class="memItemLeft" align="right" valign="top"><a id="a7be24256e9245ccd71c0b012ad4f45b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MurmurHash3_x86_128</b> (const void *key, const int len, uint32_t seed, void *out)</td></tr>
<tr class="separator:a7be24256e9245ccd71c0b012ad4f45b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c9229fa909eeb94b774d82630ffc98"><td class="memItemLeft" align="right" valign="top"><a id="ab5c9229fa909eeb94b774d82630ffc98"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>MurmurHash3_x64_128</b> (const void *key, const int len, const uint32_t seed, void *out)</td></tr>
<tr class="separator:ab5c9229fa909eeb94b774d82630ffc98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220c8114ce19cbe8d7aba391cc00a04b"><td class="memItemLeft" align="right" valign="top"><a id="a220c8114ce19cbe8d7aba391cc00a04b"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>DeviceTypeName</b> (const int32_t &amp;d)</td></tr>
<tr class="separator:a220c8114ce19cbe8d7aba391cc00a04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4a606edca5a14e8a672dd07e784e75"><td class="memItemLeft" align="right" valign="top"><a id="a6a4a606edca5a14e8a672dd07e784e75"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsSameDevice</b> (const DeviceOption &amp;lhs, const DeviceOption &amp;rhs)</td></tr>
<tr class="separator:a6a4a606edca5a14e8a672dd07e784e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2859f4f68d05334e5e8d65e389e59ce"><td class="memItemLeft" align="right" valign="top"><a id="ae2859f4f68d05334e5e8d65e389e59ce"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadStringFromFile</b> (const char *filename, string *str)</td></tr>
<tr class="separator:ae2859f4f68d05334e5e8d65e389e59ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5a6dab5657f189505350a0ea0f0253"><td class="memItemLeft" align="right" valign="top"><a id="a1c5a6dab5657f189505350a0ea0f0253"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>WriteStringToFile</b> (const string &amp;str, const char *filename)</td></tr>
<tr class="separator:a1c5a6dab5657f189505350a0ea0f0253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9886fa046ce8a853ac6d8a8d1a77d2cb"><td class="memItemLeft" align="right" valign="top"><a id="a9886fa046ce8a853ac6d8a8d1a77d2cb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadProtoFromTextFile</b> (const char *filename, Message *proto)</td></tr>
<tr class="separator:a9886fa046ce8a853ac6d8a8d1a77d2cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7681e2ec093b7ae7f746a3739b343fc6"><td class="memItemLeft" align="right" valign="top"><a id="a7681e2ec093b7ae7f746a3739b343fc6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>WriteProtoToTextFile</b> (const Message &amp;proto, const char *filename)</td></tr>
<tr class="separator:a7681e2ec093b7ae7f746a3739b343fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9029f1ac1b6ecd1551e69778ea262c9a"><td class="memItemLeft" align="right" valign="top"><a id="a9029f1ac1b6ecd1551e69778ea262c9a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadProtoFromBinaryFile</b> (const char *filename, MessageLite *proto)</td></tr>
<tr class="separator:a9029f1ac1b6ecd1551e69778ea262c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da65e9dd896203cb899ac8096772836"><td class="memItemLeft" align="right" valign="top"><a id="a1da65e9dd896203cb899ac8096772836"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>WriteProtoToBinaryFile</b> (const MessageLite &amp;proto, const char *filename)</td></tr>
<tr class="separator:a1da65e9dd896203cb899ac8096772836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02de292b6d9d8eec4669f4a41237d5d9"><td class="memItemLeft" align="right" valign="top"><a id="a02de292b6d9d8eec4669f4a41237d5d9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const NetDef &amp;l, const NetDef &amp;r)</td></tr>
<tr class="separator:a02de292b6d9d8eec4669f4a41237d5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f6ec4b6a64af60b595c14df4ca9d04"><td class="memItemLeft" align="right" valign="top"><a id="ac9f6ec4b6a64af60b595c14df4ca9d04"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;output, const NetDef &amp;n)</td></tr>
<tr class="separator:ac9f6ec4b6a64af60b595c14df4ca9d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c7ce208db0da25e3447036b3f4f47d"><td class="memTemplParams" colspan="2"><a id="a66c7ce208db0da25e3447036b3f4f47d"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a66c7ce208db0da25e3447036b3f4f47d"><td class="memTemplItemLeft" align="right" valign="top">Argument&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeArgument</b> (const string &amp;name, const MessageLite &amp;value)</td></tr>
<tr class="separator:a66c7ce208db0da25e3447036b3f4f47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24dde499614e22286208ca6c59a6f4b"><td class="memItemLeft" align="right" valign="top"><a id="ae24dde499614e22286208ca6c59a6f4b"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasOutput</b> (const OperatorDef &amp;op, const std::string &amp;output)</td></tr>
<tr class="separator:ae24dde499614e22286208ca6c59a6f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd7e657102f426c70d571f595236bd1"><td class="memItemLeft" align="right" valign="top"><a id="addd7e657102f426c70d571f595236bd1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasInput</b> (const OperatorDef &amp;op, const std::string &amp;input)</td></tr>
<tr class="separator:addd7e657102f426c70d571f595236bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ec6e8afda8c8b6231ac63126f624ca"><td class="memItemLeft" align="right" valign="top"><a id="a51ec6e8afda8c8b6231ac63126f624ca"></a>
const Argument &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetArgument</b> (const OperatorDef &amp;def, const string &amp;name)</td></tr>
<tr class="separator:a51ec6e8afda8c8b6231ac63126f624ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78921a720415b2c70de29f6a94a83ab9"><td class="memItemLeft" align="right" valign="top"><a id="a78921a720415b2c70de29f6a94a83ab9"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>GetFlagArgument</b> (const OperatorDef &amp;def, const string &amp;name, bool def_value)</td></tr>
<tr class="separator:a78921a720415b2c70de29f6a94a83ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a326d0d8aad5e0fc1ac98616e36705"><td class="memItemLeft" align="right" valign="top"><a id="ac3a326d0d8aad5e0fc1ac98616e36705"></a>
Argument *&#160;</td><td class="memItemRight" valign="bottom"><b>GetMutableArgument</b> (const string &amp;name, const bool create_if_missing, OperatorDef *def)</td></tr>
<tr class="separator:ac3a326d0d8aad5e0fc1ac98616e36705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7014e29ce11c4df85ee7f178e57b0b6"><td class="memItemLeft" align="right" valign="top"><a id="ad7014e29ce11c4df85ee7f178e57b0b6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadProtoFromBinaryFile</b> (const string filename, MessageLite *proto)</td></tr>
<tr class="separator:ad7014e29ce11c4df85ee7f178e57b0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7e48bc7da22ad09a9e6c53c029fc166"><td class="memItemLeft" align="right" valign="top"><a id="aa7e48bc7da22ad09a9e6c53c029fc166"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>WriteProtoToBinaryFile</b> (const MessageLite &amp;proto, const string &amp;filename)</td></tr>
<tr class="separator:aa7e48bc7da22ad09a9e6c53c029fc166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab06aa493c35c111e34f3664e2154118"><td class="memItemLeft" align="right" valign="top"><a id="aab06aa493c35c111e34f3664e2154118"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>ProtoDebugString</b> (const Message &amp;proto)</td></tr>
<tr class="separator:aab06aa493c35c111e34f3664e2154118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e4d270640fe3295f155f0a325451f8"><td class="memItemLeft" align="right" valign="top"><a id="aa2e4d270640fe3295f155f0a325451f8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadProtoFromTextFile</b> (const string filename, Message *proto)</td></tr>
<tr class="separator:aa2e4d270640fe3295f155f0a325451f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9842cb97b5568c533b21f5e0d34694"><td class="memItemLeft" align="right" valign="top"><a id="a2c9842cb97b5568c533b21f5e0d34694"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>WriteProtoToTextFile</b> (const Message &amp;proto, const string &amp;filename)</td></tr>
<tr class="separator:a2c9842cb97b5568c533b21f5e0d34694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cd4c76aea16a60bb6194c5235a2b5b1"><td class="memItemLeft" align="right" valign="top"><a id="a4cd4c76aea16a60bb6194c5235a2b5b1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadProtoFromFile</b> (const char *filename, Message *proto)</td></tr>
<tr class="separator:a4cd4c76aea16a60bb6194c5235a2b5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6c104b71dcb8d6689e47c8eb1c9edd"><td class="memItemLeft" align="right" valign="top"><a id="aed6c104b71dcb8d6689e47c8eb1c9edd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadProtoFromFile</b> (const string &amp;filename, Message *proto)</td></tr>
<tr class="separator:aed6c104b71dcb8d6689e47c8eb1c9edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbf56a50048541aae3fc997a79e2315"><td class="memTemplParams" colspan="2"><a id="aebbf56a50048541aae3fc997a79e2315"></a>
template&lt;class IterableInputs  = std::initializer_list&lt;string&gt;, class IterableOutputs  = std::initializer_list&lt;string&gt;, class IterableArgs  = std::initializer_list&lt;Argument&gt;&gt; </td></tr>
<tr class="memitem:aebbf56a50048541aae3fc997a79e2315"><td class="memTemplItemLeft" align="right" valign="top">OperatorDef&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateOperatorDef</b> (const string &amp;type, const string &amp;name, const IterableInputs &amp;inputs, const IterableOutputs &amp;outputs, const IterableArgs &amp;args, const DeviceOption &amp;device_option=DeviceOption(), const string &amp;engine=&quot;&quot;)</td></tr>
<tr class="separator:aebbf56a50048541aae3fc997a79e2315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b29e74962bf44701fd387c5f129b68c"><td class="memTemplParams" colspan="2"><a id="a1b29e74962bf44701fd387c5f129b68c"></a>
template&lt;class IterableInputs  = std::initializer_list&lt;string&gt;, class IterableOutputs  = std::initializer_list&lt;string&gt;&gt; </td></tr>
<tr class="memitem:a1b29e74962bf44701fd387c5f129b68c"><td class="memTemplItemLeft" align="right" valign="top">OperatorDef&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CreateOperatorDef</b> (const string &amp;type, const string &amp;name, const IterableInputs &amp;inputs, const IterableOutputs &amp;outputs, const DeviceOption &amp;device_option=DeviceOption(), const string &amp;engine=&quot;&quot;)</td></tr>
<tr class="separator:a1b29e74962bf44701fd387c5f129b68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec0c30960ea7ea3b02e461b902196a4"><td class="memTemplParams" colspan="2"><a id="acec0c30960ea7ea3b02e461b902196a4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acec0c30960ea7ea3b02e461b902196a4"><td class="memTemplItemLeft" align="right" valign="top">Argument&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeArgument</b> (const string &amp;name, const T &amp;value)</td></tr>
<tr class="separator:acec0c30960ea7ea3b02e461b902196a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fe7c3dabef65d5aee07f54aa8a85e8e"><td class="memTemplParams" colspan="2"><a id="a6fe7c3dabef65d5aee07f54aa8a85e8e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6fe7c3dabef65d5aee07f54aa8a85e8e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AddArgument</b> (const string &amp;name, const T &amp;value, OperatorDef *def)</td></tr>
<tr class="separator:a6fe7c3dabef65d5aee07f54aa8a85e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea81b709fceb86f663d11ab502b1d1ff"><td class="memItemLeft" align="right" valign="top"><a id="aea81b709fceb86f663d11ab502b1d1ff"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const DeviceOption &amp;dl, const DeviceOption &amp;dr)</td></tr>
<tr class="separator:aea81b709fceb86f663d11ab502b1d1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9681d9c5cbe25a7e3ac4b7a32f80391b"><td class="memItemLeft" align="right" valign="top"><a id="a9681d9c5cbe25a7e3ac4b7a32f80391b"></a>
std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>split</b> (char separator, const std::string &amp;string)</td></tr>
<tr class="separator:a9681d9c5cbe25a7e3ac4b7a32f80391b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f4c349da35ab5c551a3dd29c61f732"><td class="memItemLeft" align="right" valign="top"><a id="aa2f4c349da35ab5c551a3dd29c61f732"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>editDistance</b> (const std::string &amp;s1, const std::string &amp;s2, size_t max_distance)</td></tr>
<tr class="separator:aa2f4c349da35ab5c551a3dd29c61f732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61001fa69bf0c7b2c13495d0af76d763"><td class="memItemLeft" align="right" valign="top"><a id="a61001fa69bf0c7b2c13495d0af76d763"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><b>editDistanceHelper</b> (const char *s1, size_t s1_len, const char *s2, size_t s2_len, std::vector&lt; size_t &gt; &amp;current, std::vector&lt; size_t &gt; &amp;previous, std::vector&lt; size_t &gt; &amp;previous1, size_t max_distance)</td></tr>
<tr class="separator:a61001fa69bf0c7b2c13495d0af76d763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39806ba605fafaac38f9e9c539706f4c"><td class="memItemLeft" align="right" valign="top"><a id="a39806ba605fafaac38f9e9c539706f4c"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Do256NOPs</b> ()</td></tr>
<tr class="separator:a39806ba605fafaac38f9e9c539706f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c95d7b8489a4665a6fd90de8e93df0"><td class="memTemplParams" colspan="2"><a id="ae2c95d7b8489a4665a6fd90de8e93df0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2c95d7b8489a4665a6fd90de8e93df0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>WaitForVariableChange</b> (std::atomic&lt; T &gt; *var, T initial_value, std::condition_variable *cond, std::mutex *mutex)</td></tr>
<tr class="separator:ae2c95d7b8489a4665a6fd90de8e93df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ac2eb7e450d80ba2700e9d49bb7803"><td class="memItemLeft" align="right" valign="top"><a id="a47ac2eb7e450d80ba2700e9d49bb7803"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (VideoInput, <a class="el" href="classcaffe2_1_1VideoInputOp.html">VideoInputOp</a>&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt;)</td></tr>
<tr class="separator:a47ac2eb7e450d80ba2700e9d49bb7803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b79d942d717ea0f9a0b4fa1f2bf5e23"><td class="memItemLeft" align="right" valign="top"><a id="a0b79d942d717ea0f9a0b4fa1f2bf5e23"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NumInputs</b> (0, 1) .NumOutputs(2) .TensorInferenceFunction([](const OperatorDef &amp;def</td></tr>
<tr class="separator:a0b79d942d717ea0f9a0b4fa1f2bf5e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68a5d17cd5418f6100822bec4b33ff7"><td class="memItemLeft" align="right" valign="top"><a id="ae68a5d17cd5418f6100822bec4b33ff7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>CHECK_GT</b> (crop, 0)</td></tr>
<tr class="separator:ae68a5d17cd5418f6100822bec4b33ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc1076d4c4c6c076d385fa639ffffa1f"><td class="memItemLeft" align="right" valign="top"><a id="acc1076d4c4c6c076d385fa639ffffa1f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>if</b> (!multiple_label)</td></tr>
<tr class="separator:acc1076d4c4c6c076d385fa639ffffa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08128f09da097f94938d256fe2ca0db7"><td class="memItemLeft" align="right" valign="top"><a id="a08128f09da097f94938d256fe2ca0db7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>NO_GRADIENT</b> (VideoInput)</td></tr>
<tr class="separator:a08128f09da097f94938d256fe2ca0db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a1119be7ed5fbbe15f12e9e6f908ad"><td class="memItemLeft" align="right" valign="top"><a id="ae8a1119be7ed5fbbe15f12e9e6f908ad"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CUDA_OPERATOR</b> (VideoInput, <a class="el" href="classcaffe2_1_1VideoInputOp.html">VideoInputOp</a>&lt; <a class="el" href="classcaffe2_1_1CUDAContext.html">CUDAContext</a> &gt;)</td></tr>
<tr class="separator:ae8a1119be7ed5fbbe15f12e9e6f908ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1f7c429c590ca373072aa6d3f6014b"><td class="memItemLeft" align="right" valign="top"><a id="a2c1f7c429c590ca373072aa6d3f6014b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ImageChannelToBuffer</b> (const cv::Mat *img, float *buffer, int c)</td></tr>
<tr class="separator:a2c1f7c429c590ca373072aa6d3f6014b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a968bcee5f345bab213925635000da834"><td class="memItemLeft" align="right" valign="top"><a id="a968bcee5f345bab213925635000da834"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ImageDataToBuffer</b> (unsigned char *data_buffer, int height, int width, float *buffer, int c)</td></tr>
<tr class="separator:a968bcee5f345bab213925635000da834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9177ac38a80b63fdbdc387c4a6121d2c"><td class="memItemLeft" align="right" valign="top"><a id="a9177ac38a80b63fdbdc387c4a6121d2c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ClipTransform</b> (const float *clip_data, const int channels, const int length, const int height, const int width, const int crop_size, const bool mirror, float mean, float std, float *transformed_clip, std::mt19937 *randgen, std::bernoulli_distribution *mirror_this_clip, const bool use_center_crop)</td></tr>
<tr class="separator:a9177ac38a80b63fdbdc387c4a6121d2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b368e613dc600f3609cc2235757d96"><td class="memItemLeft" align="right" valign="top"><a id="a67b368e613dc600f3609cc2235757d96"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadClipFromFrames</b> (std::string img_dir, const int start_frm, std::string im_extension, const int length, const int height, const int width, const int sampling_rate, float *&amp;buffer)</td></tr>
<tr class="separator:a67b368e613dc600f3609cc2235757d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d75f94837fcf73f0c28f168b4e8fcd"><td class="memItemLeft" align="right" valign="top"><a id="af5d75f94837fcf73f0c28f168b4e8fcd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>GetNumberOfFrames</b> (std::string filename)</td></tr>
<tr class="separator:af5d75f94837fcf73f0c28f168b4e8fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f7e1eb3edf1acae2fc4f90888cccec"><td class="memItemLeft" align="right" valign="top"><a id="a38f7e1eb3edf1acae2fc4f90888cccec"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>GetVideoFPS</b> (std::string filename)</td></tr>
<tr class="separator:a38f7e1eb3edf1acae2fc4f90888cccec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a42963eb0a07462f976601841039bce"><td class="memItemLeft" align="right" valign="top"><a id="a5a42963eb0a07462f976601841039bce"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>GetVideoMeta</b> (std::string filename, int &amp;number_of_frames, double &amp;fps)</td></tr>
<tr class="separator:a5a42963eb0a07462f976601841039bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d9e814fc90ff2342adc9620b6697fc"><td class="memItemLeft" align="right" valign="top"><a id="a16d9e814fc90ff2342adc9620b6697fc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadClipFromVideoLazzy</b> (std::string filename, const int start_frm, const int length, const int height, const int width, const int sampling_rate, float *&amp;buffer)</td></tr>
<tr class="separator:a16d9e814fc90ff2342adc9620b6697fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd950c506e6b59d7d8db0192184ddca"><td class="memItemLeft" align="right" valign="top"><a id="aecd950c506e6b59d7d8db0192184ddca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadClipFromVideoSequential</b> (std::string filename, const int start_frm, const int length, const int height, const int width, const int sampling_rate, float *&amp;buffer)</td></tr>
<tr class="separator:aecd950c506e6b59d7d8db0192184ddca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad044dea8561e562f2f94f802c4d0c3fc"><td class="memItemLeft" align="right" valign="top"><a id="ad044dea8561e562f2f94f802c4d0c3fc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ReadClipFromVideo</b> (std::string filename, const int start_frm, const int length, const int height, const int width, const int sampling_rate, float *&amp;buffer)</td></tr>
<tr class="separator:ad044dea8561e562f2f94f802c4d0c3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41ce5bcab51a16dd3e15102437effa83"><td class="memItemLeft" align="right" valign="top"><a id="a41ce5bcab51a16dd3e15102437effa83"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>DecodeClipFromVideoFile</b> (std::string filename, const int start_frm, const int length, const int height, const int width, const int sampling_rate, float *&amp;buffer)</td></tr>
<tr class="separator:a41ce5bcab51a16dd3e15102437effa83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ced7f8591409819cc445e5b8f873739"><td class="memItemLeft" align="right" valign="top"><a id="a9ced7f8591409819cc445e5b8f873739"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>DecodeClipFromMemoryBuffer</b> (const char *video_buffer, const int size, const int start_frm, const int length, const int height, const int width, const int sampling_rate, float *&amp;buffer, std::mt19937 *randgen)</td></tr>
<tr class="separator:a9ced7f8591409819cc445e5b8f873739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8063a225139b51b5c3201af38cd13227"><td class="memItemLeft" align="right" valign="top"><a id="a8063a225139b51b5c3201af38cd13227"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>REGISTER_CPU_OPERATOR</b> (Caffe2ModuleTestDynamicDummy, <a class="el" href="classcaffe2_1_1Caffe2ModuleTestDynamicDummyOp.html">Caffe2ModuleTestDynamicDummyOp</a>)</td></tr>
<tr class="separator:a8063a225139b51b5c3201af38cd13227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0282f7845ed6da9bc1aa5c7020ec891d"><td class="memItemLeft" align="right" valign="top"><a id="a0282f7845ed6da9bc1aa5c7020ec891d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>OPERATOR_SCHEMA</b> (Caffe2ModuleTestDynamicDummy)</td></tr>
<tr class="separator:a0282f7845ed6da9bc1aa5c7020ec891d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aada76412edcca7a9bada88b46160ecbe"><td class="memItemLeft" align="right" valign="top"><a id="aada76412edcca7a9bada88b46160ecbe"></a>
DoRunWithOtherType2 typedef <a class="el" href="classcaffe2_1_1Registry.html">Registry</a>&lt; std::string, std::unique_ptr&lt; <a class="el" href="classcaffe2_1_1OperatorBase.html">OperatorBase</a> &gt;, const OperatorDef &amp;, <a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>OperatorRegistry</b></td></tr>
<tr class="separator:aada76412edcca7a9bada88b46160ecbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0319f6f160afcb5114d1df3a04634c3"><td class="memItemLeft" align="right" valign="top"><a id="ad0319f6f160afcb5114d1df3a04634c3"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kCIFARSize</b> = 32</td></tr>
<tr class="separator:ad0319f6f160afcb5114d1df3a04634c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5f94b53611e57244dafb85926cc9c2"><td class="memItemLeft" align="right" valign="top"><a id="a5c5f94b53611e57244dafb85926cc9c2"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kCIFARImageNBytes</b> = kCIFARSize * kCIFARSize * 3</td></tr>
<tr class="separator:a5c5f94b53611e57244dafb85926cc9c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede5fd30af8dddc4d3f43207260b26ec"><td class="memItemLeft" align="right" valign="top"><a id="aede5fd30af8dddc4d3f43207260b26ec"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kCIFAR10BatchSize</b> = 10000</td></tr>
<tr class="separator:aede5fd30af8dddc4d3f43207260b26ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05867c998628fbf970478572f32a462"><td class="memItemLeft" align="right" valign="top"><a id="af05867c998628fbf970478572f32a462"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kCIFAR10TestDataSize</b> = 10000</td></tr>
<tr class="separator:af05867c998628fbf970478572f32a462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb02b581f40e6c2107cff354f93b46d"><td class="memItemLeft" align="right" valign="top"><a id="a6eb02b581f40e6c2107cff354f93b46d"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kCIFAR10TrainBatches</b> = 5</td></tr>
<tr class="separator:a6eb02b581f40e6c2107cff354f93b46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee608401867021e057c71576582c2eb"><td class="memItemLeft" align="right" valign="top"><a id="acee608401867021e057c71576582c2eb"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kCIFAR100TrainDataSize</b> = 50000</td></tr>
<tr class="separator:acee608401867021e057c71576582c2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b349deb32a7b5137e31d6297c6f28c"><td class="memItemLeft" align="right" valign="top"><a id="a86b349deb32a7b5137e31d6297c6f28c"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kCIFAR100TestDataSize</b> = 10000</td></tr>
<tr class="separator:a86b349deb32a7b5137e31d6297c6f28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae4e9ce61bc9036cb9adaf4842095cc"><td class="memItemLeft" align="right" valign="top"><a id="a7ae4e9ce61bc9036cb9adaf4842095cc"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>gCaffe2Alignment</b> = 32</td></tr>
<tr class="separator:a7ae4e9ce61bc9036cb9adaf4842095cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17803cefcc839e9256e5bf815f5d71b4"><td class="memItemLeft" align="right" valign="top"><a id="a17803cefcc839e9256e5bf815f5d71b4"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>kTensorBlobType</b> = &quot;Tensor&quot;</td></tr>
<tr class="separator:a17803cefcc839e9256e5bf815f5d71b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cd3212f419650a9034f155fdea6298"><td class="memItemLeft" align="right" valign="top"><a id="ac3cd3212f419650a9034f155fdea6298"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>kChunkIdSeparator</b> = &quot;#%&quot;</td></tr>
<tr class="separator:ac3cd3212f419650a9034f155fdea6298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56c01cfb9873b89810de07f3d09023c"><td class="memItemLeft" align="right" valign="top"><a id="ad56c01cfb9873b89810de07f3d09023c"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>kDefaultChunkSize</b> = -1</td></tr>
<tr class="separator:ad56c01cfb9873b89810de07f3d09023c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1900bca08da42b6be306f413ccd2182"><td class="memItemLeft" align="right" valign="top"><a id="ad1900bca08da42b6be306f413ccd2182"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>kNoChunking</b> = 0</td></tr>
<tr class="separator:ad1900bca08da42b6be306f413ccd2182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11301f418558bfbce8a0babda295b6bf"><td class="memItemLeft" align="right" valign="top"><a id="a11301f418558bfbce8a0babda295b6bf"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>g_caffe2_has_cuda_linked</b> = false</td></tr>
<tr class="separator:a11301f418558bfbce8a0babda295b6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016b982f98fda42e3e49f9553ad75231"><td class="memItemLeft" align="right" valign="top"><a id="a016b982f98fda42e3e49f9553ad75231"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_CUDA_NUM_THREADS</b> = 512</td></tr>
<tr class="separator:a016b982f98fda42e3e49f9553ad75231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fa97d7f04b319de6c9fe8ef11b8b6b"><td class="memItemLeft" align="right" valign="top"><a id="a27fa97d7f04b319de6c9fe8ef11b8b6b"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>CAFFE_MAXIMUM_NUM_BLOCKS</b> = 4096</td></tr>
<tr class="separator:a27fa97d7f04b319de6c9fe8ef11b8b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdeeef5246d6c9fc520df422e59c93b5"><td class="memItemLeft" align="right" valign="top"><a id="abdeeef5246d6c9fc520df422e59c93b5"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>MaxDeviceTypes</b> = DeviceType::COMPILE_TIME_MAX_DEVICE_TYPES</td></tr>
<tr class="separator:abdeeef5246d6c9fc520df422e59c93b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2169ccbd47ef3a2c06f65f7405e8e0e6"><td class="memItemLeft" align="right" valign="top"><a id="a2169ccbd47ef3a2c06f65f7405e8e0e6"></a>
std::function&lt; void(const OperatorDef &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetOperatorLogger</b> ()</td></tr>
<tr class="separator:a2169ccbd47ef3a2c06f65f7405e8e0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f308b1e218da746bab941419af4f6bd"><td class="memItemLeft" align="right" valign="top"><a id="a1f308b1e218da746bab941419af4f6bd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DoRunWithType2</b></td></tr>
<tr class="separator:a1f308b1e218da746bab941419af4f6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f0010e56a40c6f4c187301bcf8e226"><td class="memItemLeft" align="right" valign="top"><a id="ae2f0010e56a40c6f4c187301bcf8e226"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>kCannotComputeNumOutputs</b> = -1</td></tr>
<tr class="separator:ae2f0010e56a40c6f4c187301bcf8e226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabea76bd2be0a4ea36a880f7c77d5cba"><td class="memItemLeft" align="right" valign="top"><a id="aabea76bd2be0a4ea36a880f7c77d5cba"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>kQTensorBlobQType</b> = &quot;QTensor&quot;</td></tr>
<tr class="separator:aabea76bd2be0a4ea36a880f7c77d5cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9be0984306127d39c1a342c501ba83"><td class="memItemLeft" align="right" valign="top"><a id="aec9be0984306127d39c1a342c501ba83"></a>
constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>k_limit_default_</b> = 1000</td></tr>
<tr class="separator:aec9be0984306127d39c1a342c501ba83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f24af9685c1a56565b38f11dcf27978"><td class="memItemLeft" align="right" valign="top"><a id="a4f24af9685c1a56565b38f11dcf27978"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>float16</b></td></tr>
<tr class="separator:a4f24af9685c1a56565b38f11dcf27978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3127d3b8cfbde2f82b33d431e57c95"><td class="memItemLeft" align="right" valign="top"><a id="aac3127d3b8cfbde2f82b33d431e57c95"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>kBlobName</b> = &quot;blob_name&quot;</td></tr>
<tr class="separator:aac3127d3b8cfbde2f82b33d431e57c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c220ef38476c32d4208f2f45381313"><td class="memItemLeft" align="right" valign="top"><a id="ae1c220ef38476c32d4208f2f45381313"></a>
constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><b>kAddValue</b> = &quot;add_value&quot;</td></tr>
<tr class="separator:ae1c220ef38476c32d4208f2f45381313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01abe48ef568bf9479aab89ad5f253c3"><td class="memItemLeft" align="right" valign="top"><a id="a01abe48ef568bf9479aab89ad5f253c3"></a>
alternative key for the&#160;</td><td class="memItemRight" valign="bottom"><b>handler</b></td></tr>
<tr class="separator:a01abe48ef568bf9479aab89ad5f253c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534d618b697f29dbf3d1c2509f5c1309"><td class="memItemLeft" align="right" valign="top"><a id="a534d618b697f29dbf3d1c2509f5c1309"></a>
INT_MAX batch_size images will be processed GPUs can optionally be used for part of the processing The following transformations are applied to the image A bounding box is applied to the initial Number of images to output for each run of the Whether or not to do color jitter Defaults to Image brightness scale used in color jittering Defaults to Whether or not to do color lighting Defaults to&#160;</td><td class="memItemRight" valign="bottom"><b>Type</b></td></tr>
<tr class="separator:a534d618b697f29dbf3d1c2509f5c1309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569493bf1694a2e38495aac43789e98e"><td class="memItemLeft" align="right" valign="top"><a id="a569493bf1694a2e38495aac43789e98e"></a>
INT_MAX batch_size images will be processed GPUs can optionally be used for part of the processing The following transformations are applied to the image A bounding box is applied to the initial Number of images to output for each run of the Whether or not to do color jitter Defaults to Image brightness scale used in color jittering Defaults to Whether or not to do color lighting Defaults to Scale the size of the smallest dimension of the image to this Scale and minsize are mutually exclusive Must be larger than crop&#160;</td><td class="memItemRight" valign="bottom"><b>If</b></td></tr>
<tr class="separator:a569493bf1694a2e38495aac43789e98e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f7a3cfe67936ee45f02531a07da89a"><td class="memItemLeft" align="right" valign="top"><a id="a07f7a3cfe67936ee45f02531a07da89a"></a>
INT_MAX batch_size images will be processed GPUs can optionally be used for part of the processing The following transformations are applied to the image A bounding box is applied to the initial Number of images to output for each run of the Whether or not to do color jitter Defaults to Image brightness scale used in color jittering Defaults to Whether or not to do color lighting Defaults to Scale the size of the smallest dimension of the image to this Scale and minsize are mutually exclusive Must be larger than crop both dimensions of the image will be set to minsize or&#160;</td><td class="memItemRight" valign="bottom"><b>scale</b></td></tr>
<tr class="separator:a07f7a3cfe67936ee45f02531a07da89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af54f0e1dbdc5437a9af73ac9c29304bc"><td class="memItemLeft" align="right" valign="top"><a id="af54f0e1dbdc5437a9af73ac9c29304bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>otherwise</b></td></tr>
<tr class="separator:af54f0e1dbdc5437a9af73ac9c29304bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8729390024d322768e469410ead75913"><td class="memItemLeft" align="right" valign="top">the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults if the input is in Caffe format Defaults to Number of CPU decode transform threads Defaults to Name of the Type of The sizes of any outputs besides the data and shortest side desired for image resize Defaults to [-1, -1] or no random resize desired&#160;</td><td class="memItemRight" valign="bottom"><b>data</b></td></tr>
<tr class="separator:a8729390024d322768e469410ead75913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8d11ec5d2724f1b8087ed84933b65b"><td class="memItemLeft" align="right" valign="top"><a id="a4b8d11ec5d2724f1b8087ed84933b65b"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults if the input is in Caffe format Defaults to Number of CPU decode transform threads Defaults to Name of the Type of The sizes of any outputs besides the data and shortest side desired for image resize Defaults to [-1, -1] or no random resize desired <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> containing the images additional&#160;</td><td class="memItemRight" valign="bottom"><b>outputs</b></td></tr>
<tr class="separator:a4b8d11ec5d2724f1b8087ed84933b65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e25dec086376cc33e6a0f4199c96d1"><td class="memItemLeft" align="right" valign="top"><a id="a42e25dec086376cc33e6a0f4199c96d1"></a>
the other dimension is proportionally scaled Defaults to Whether or not to mirror the image Defaults to Vector of means per color Standard deviation by which to normalize color channels Defaults to Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults Bounding box coordinate Defaults if the input is in Caffe format Defaults to Number of CPU decode transform threads Defaults to Name of the Type of The sizes of any outputs besides the data and shortest side desired for image resize Defaults to [-1, -1] or no random resize desired <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> containing the images additional Any outputs after the first will be Tensors read from the input&#160;</td><td class="memItemRight" valign="bottom"><b>TensorProtos</b></td></tr>
<tr class="separator:a42e25dec086376cc33e6a0f4199c96d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9343f2b93099fd08c702c02ca9a67067"><td class="memItemLeft" align="right" valign="top"><a id="a9343f2b93099fd08c702c02ca9a67067"></a>
const char *const&#160;</td><td class="memItemRight" valign="bottom"><b>snpe_ffi_so</b> = &quot;libsnpe_ffi.so&quot;</td></tr>
<tr class="separator:a9343f2b93099fd08c702c02ca9a67067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f26c8e49cc5d96b7dc00e5389c436f0"><td class="memItemLeft" align="right" valign="top"><a id="a7f26c8e49cc5d96b7dc00e5389c436f0"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>k2b1bXBits</b> = 2</td></tr>
<tr class="separator:a7f26c8e49cc5d96b7dc00e5389c436f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c357882dcf28f5100862bb0c47bb11"><td class="memItemLeft" align="right" valign="top"><a id="a95c357882dcf28f5100862bb0c47bb11"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>kL1CacheSizeBytes</b> = 16 * 1024</td></tr>
<tr class="separator:a95c357882dcf28f5100862bb0c47bb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675c192414204207a8fbe65cc25a53bb"><td class="memItemLeft" align="right" valign="top"><a id="a675c192414204207a8fbe65cc25a53bb"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>kGEMMTileSize</b> = 64</td></tr>
<tr class="separator:a675c192414204207a8fbe65cc25a53bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec79aadd2f986b41f0e9e1eaf3c4ec96"><td class="memItemLeft" align="right" valign="top"><a id="aec79aadd2f986b41f0e9e1eaf3c4ec96"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>kGEMMTileDepthBytes</b> = 16</td></tr>
<tr class="separator:aec79aadd2f986b41f0e9e1eaf3c4ec96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c99e50a77791b25972e3612dfa4e80"><td class="memItemLeft" align="right" valign="top">element wise DOC&#160;</td><td class="memItemRight" valign="bottom"><b>output</b></td></tr>
<tr class="separator:ac3c99e50a77791b25972e3612dfa4e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf3bc12ac0ef15877db474d92746fcf"><td class="memItemLeft" align="right" valign="top"><a id="a8cf3bc12ac0ef15877db474d92746fcf"></a>
element wise DOC The absolute value of the input tensor computed element&#160;</td><td class="memItemRight" valign="bottom"><b>wise</b></td></tr>
<tr class="separator:a8cf3bc12ac0ef15877db474d92746fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33e5e712c84972a4ee6363f01b4dbd8"><td class="memItemLeft" align="right" valign="top"><a id="ae33e5e712c84972a4ee6363f01b4dbd8"></a>
we add to&#160;</td><td class="memItemRight" valign="bottom"><b>it</b></td></tr>
<tr class="separator:ae33e5e712c84972a4ee6363f01b4dbd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60bb1ecfdbe7cf126c0dda627e6a64a"><td class="memItemLeft" align="right" valign="top"><a id="aa60bb1ecfdbe7cf126c0dda627e6a64a"></a>
we first initialize the output tensor to all&#160;</td><td class="memItemRight" valign="bottom"><b>zeros</b></td></tr>
<tr class="separator:aa60bb1ecfdbe7cf126c0dda627e6a64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8468fd4022bfba791d59c26b212ece9f"><td class="memItemLeft" align="right" valign="top"><a id="a8468fd4022bfba791d59c26b212ece9f"></a>
we first initialize the output tensor to all and then do accumulation Any further calls to the&#160;</td><td class="memItemRight" valign="bottom"><b>input</b></td></tr>
<tr class="separator:a8468fd4022bfba791d59c26b212ece9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a00fe1ad689b92d705d3c388305c10"><td class="memItemLeft" align="right" valign="top"><a id="ae6a00fe1ad689b92d705d3c388305c10"></a>
we first initialize the output tensor to all and then do accumulation Any further calls to the The input tensor that has to be accumulated to the output tensor If the output size is not the same as input&#160;</td><td class="memItemRight" valign="bottom"><b>size</b> = 1</td></tr>
<tr class="separator:ae6a00fe1ad689b92d705d3c388305c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba29b97f6823d9ed5883d821873234e"><td class="memItemLeft" align="right" valign="top"><a id="a5ba29b97f6823d9ed5883d821873234e"></a>
we first initialize the output tensor to all and then do accumulation Any further calls to the The input tensor that has to be accumulated to the output tensor If the output size is not the same as input the output tensor is first reshaped and initialized to&#160;</td><td class="memItemRight" valign="bottom"><b>zero</b></td></tr>
<tr class="separator:a5ba29b97f6823d9ed5883d821873234e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c76ef55e49cc26412c5c8d03a357a38"><td class="memItemLeft" align="right" valign="top"><a id="a5c76ef55e49cc26412c5c8d03a357a38"></a>
we first initialize the output tensor to all and then do accumulation Any further calls to the The input tensor that has to be accumulated to the output tensor If the output size is not the same as input the output tensor is first reshaped and initialized to and only&#160;</td><td class="memItemRight" valign="bottom"><b>then</b></td></tr>
<tr class="separator:a5c76ef55e49cc26412c5c8d03a357a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a323067eaaeed246ded875e236e7044"><td class="memItemLeft" align="right" valign="top"><a id="a9a323067eaaeed246ded875e236e7044"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ints</b></td></tr>
<tr class="separator:a9a323067eaaeed246ded875e236e7044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d98876427d4557667979998e7df90a"><td class="memItemLeft" align="right" valign="top"><a id="a60d98876427d4557667979998e7df90a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>longs</b></td></tr>
<tr class="separator:a60d98876427d4557667979998e7df90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4010e0a5486f263b21fbb30c8d3f14"><td class="memItemLeft" align="right" valign="top"><a id="a9a4010e0a5486f263b21fbb30c8d3f14"></a>
or long longs and checks if all values are true when coerced into a boolean In other&#160;</td><td class="memItemRight" valign="bottom"><b>words</b></td></tr>
<tr class="separator:a9a4010e0a5486f263b21fbb30c8d3f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e20361269928187b6a5625204805051"><td class="memItemLeft" align="right" valign="top">const vector&lt; TensorShape &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>in</b></td></tr>
<tr class="separator:a6e20361269928187b6a5625204805051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5bd2edb1b25606fad752a6791de8f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcaffe2_1_1ArgumentHelper.html">ArgumentHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><b>helper</b> (def)</td></tr>
<tr class="separator:a7e5bd2edb1b25606fad752a6791de8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91681eb0a87ce99272cd3d0f1116c19"><td class="memItemLeft" align="right" valign="top"><a id="af91681eb0a87ce99272cd3d0f1116c19"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>output_dims</b></td></tr>
<tr class="separator:af91681eb0a87ce99272cd3d0f1116c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ba257bf31ceca956d71205df79f53c"><td class="memItemLeft" align="right" valign="top"><a id="a33ba257bf31ceca956d71205df79f53c"></a>
const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>data_dims</b> = GetDimsVector(in[0])</td></tr>
<tr class="separator:a33ba257bf31ceca956d71205df79f53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad960afee248a027651483f33a368ec46"><td class="memItemLeft" align="right" valign="top"><a id="ad960afee248a027651483f33a368ec46"></a>
const auto &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>indices_dims</b> = GetDimsVector(in[1])</td></tr>
<tr class="separator:ad960afee248a027651483f33a368ec46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48262a78819cac51ddd04a6d020a0baa"><td class="memItemLeft" align="right" valign="top"><a id="a48262a78819cac51ddd04a6d020a0baa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>out</b> [0] = CreateTensorShape(output_dims, TensorProto::FLOAT)</td></tr>
<tr class="separator:a48262a78819cac51ddd04a6d020a0baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722222b86b523937511604f110d8c18e"><td class="memItemLeft" align="right" valign="top"><a id="a722222b86b523937511604f110d8c18e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>DATA</b></td></tr>
<tr class="separator:a722222b86b523937511604f110d8c18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04e8baeca5dcb4f675a99f815264363"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> of rank&#160;</td><td class="memItemRight" valign="bottom"><b>r</b></td></tr>
<tr class="separator:af04e8baeca5dcb4f675a99f815264363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e4fe6b7771867d3b5f9753141155cf"><td class="memItemLeft" align="right" valign="top"><a id="aa2e4fe6b7771867d3b5f9753141155cf"></a>
indices&#160;</td><td class="memItemRight" valign="bottom"><b>vector</b></td></tr>
<tr class="separator:aa2e4fe6b7771867d3b5f9753141155cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0d66c92e7159ad7563d50297971887"><td class="memItemLeft" align="right" valign="top"><a id="aac0d66c92e7159ad7563d50297971887"></a>
indices and values vector Each element in lengths indices should not have duplicate number For&#160;</td><td class="memItemRight" valign="bottom"><b>example</b></td></tr>
<tr class="separator:aac0d66c92e7159ad7563d50297971887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659684f47d7140896b4567e6c1527ee2"><td class="memItemLeft" align="right" valign="top"><a id="a659684f47d7140896b4567e6c1527ee2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>The</b></td></tr>
<tr class="separator:a659684f47d7140896b4567e6c1527ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1548e3b7972c57f8116fc4e0149b256a"><td class="memItemLeft" align="right" valign="top"><a id="a1548e3b7972c57f8116fc4e0149b256a"></a>
original data tensor&#160;</td><td class="memItemRight" valign="bottom"><b>masked_data</b></td></tr>
<tr class="separator:a1548e3b7972c57f8116fc4e0149b256a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b8c3114e2c624ebe45f009a56af4fc"><td class="memItemLeft" align="right" valign="top"><a id="ab2b8c3114e2c624ebe45f009a56af4fc"></a>
return the segment lengths of a corresponding segmented tensor after BooleanMask is applied DOC&#160;</td><td class="memItemRight" valign="bottom"><b>mask</b></td></tr>
<tr class="separator:ab2b8c3114e2c624ebe45f009a56af4fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af414c251ce4da8ff38f5355a092635e1"><td class="memItemLeft" align="right" valign="top"><a id="af414c251ce4da8ff38f5355a092635e1"></a>
const float&#160;</td><td class="memItemRight" valign="bottom"><b>minf</b> = -1.0f * std::numeric_limits&lt;float&gt;::infinity()</td></tr>
<tr class="separator:af414c251ce4da8ff38f5355a092635e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afe873d9d7b23e7c40cf97f1136366b"><td class="memItemLeft" align="right" valign="top"><a id="a3afe873d9d7b23e7c40cf97f1136366b"></a>
reconstruct values together according to masks A comprehensive&#160;</td><td class="memItemRight" valign="bottom"><b>False</b></td></tr>
<tr class="separator:a3afe873d9d7b23e7c40cf97f1136366b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11c1b5f26f85c316d813e2b572f889c1"><td class="memItemLeft" align="right" valign="top"><a id="a11c1b5f26f85c316d813e2b572f889c1"></a>
reconstruct values together according to masks A comprehensive&#160;</td><td class="memItemRight" valign="bottom"><b>True</b></td></tr>
<tr class="separator:a11c1b5f26f85c316d813e2b572f889c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68ebbb5a439f3f1214bdd28a6b1c69c"><td class="memItemLeft" align="right" valign="top"><a id="aa68ebbb5a439f3f1214bdd28a6b1c69c"></a>
reconstruct values together according to masks A comprehensive False&#160;</td><td class="memItemRight" valign="bottom"><b>values1</b> = 1.0</td></tr>
<tr class="separator:aa68ebbb5a439f3f1214bdd28a6b1c69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ce822052940b564fe8a18b36043a46"><td class="memItemLeft" align="right" valign="top"><a id="ad1ce822052940b564fe8a18b36043a46"></a>
reconstruct values together according to masks A comprehensive False&#160;</td><td class="memItemRight" valign="bottom"><b>mask2</b> = False</td></tr>
<tr class="separator:ad1ce822052940b564fe8a18b36043a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6bf36770de6197a0500da244b4d49f"><td class="memItemLeft" align="right" valign="top">reconstruct values together according to masks A comprehensive False False&#160;</td><td class="memItemRight" valign="bottom"><b>values2</b></td></tr>
<tr class="separator:acc6bf36770de6197a0500da244b4d49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8243c546a33a687ac9b0b5065c40b7c9"><td class="memItemLeft" align="right" valign="top"><a id="a8243c546a33a687ac9b0b5065c40b7c9"></a>
reconstruct values together according to masks A comprehensive False False True&#160;</td><td class="memItemRight" valign="bottom"><b>values3</b> = 4.0</td></tr>
<tr class="separator:a8243c546a33a687ac9b0b5065c40b7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f58537928e93ce4dea86b12e17980d"><td class="memItemLeft" align="right" valign="top"><a id="ad3f58537928e93ce4dea86b12e17980d"></a>
reconstruct values together according to masks A comprehensive False False True Reconstruct&#160;</td><td class="memItemRight" valign="bottom"><b>by</b></td></tr>
<tr class="separator:ad3f58537928e93ce4dea86b12e17980d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3518699eb3c6de62fc0804d8bf4d35ab"><td class="memItemLeft" align="right" valign="top"><a id="a3518699eb3c6de62fc0804d8bf4d35ab"></a>
reconstruct values together according to masks A comprehensive False False True Reconstruct&#160;</td><td class="memItemRight" valign="bottom"><b>mask3</b></td></tr>
<tr class="separator:a3518699eb3c6de62fc0804d8bf4d35ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2209e73667e5137d0f648c9284112b80"><td class="memItemLeft" align="right" valign="top"><a id="a2209e73667e5137d0f648c9284112b80"></a>
reconstruct values together according to masks A comprehensive False False True Reconstruct We&#160;</td><td class="memItemRight" valign="bottom"><b>get</b></td></tr>
<tr class="separator:a2209e73667e5137d0f648c9284112b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87846d407e440c05437cc708f53d3b53"><td class="memItemLeft" align="right" valign="top"><a id="a87846d407e440c05437cc708f53d3b53"></a>
reconstruct values together according to masks A comprehensive False False True Reconstruct We Note that for all mask&#160;</td><td class="memItemRight" valign="bottom"><b>positions</b></td></tr>
<tr class="separator:a87846d407e440c05437cc708f53d3b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df0ce75f8c358e9bb0b277d149c530f"><td class="memItemLeft" align="right" valign="top"><a id="a2df0ce75f8c358e9bb0b277d149c530f"></a>
reconstruct values together according to masks A comprehensive False False True Reconstruct We Note that for all mask there must be at least one True If for a field there are multiple True&#160;</td><td class="memItemRight" valign="bottom"><b>s</b></td></tr>
<tr class="separator:a2df0ce75f8c358e9bb0b277d149c530f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5205e5927822adb8687a095d5b80dc40"><td class="memItemLeft" align="right" valign="top"><a id="a5205e5927822adb8687a095d5b80dc40"></a>
The data type to which the elements of the input tensor are cast Strictly must be one of the types from DataType enum in TensorProto Output tensor with the same shape as input with type specified by the to&#160;</td><td class="memItemRight" valign="bottom"><b>argument</b></td></tr>
<tr class="separator:a5205e5927822adb8687a095d5b80dc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2069850bb2c06fd98dd2142a18e0441"><td class="memItemLeft" align="right" valign="top"><a id="ac2069850bb2c06fd98dd2142a18e0441"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>kv_handler</b></td></tr>
<tr class="separator:ac2069850bb2c06fd98dd2142a18e0441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e00679abaa908d00e7c8fc71e0499cf"><td class="memItemLeft" align="right" valign="top"><a id="a2e00679abaa908d00e7c8fc71e0499cf"></a>
Key value handler for&#160;</td><td class="memItemRight" valign="bottom"><b>comm_world</b></td></tr>
<tr class="separator:a2e00679abaa908d00e7c8fc71e0499cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9c1871d705fa9e8aa558644f102386"><td class="memItemLeft" align="right" valign="top"><a id="aae9c1871d705fa9e8aa558644f102386"></a>
Key value handler for A common world for collective operations int rank of this node in the common&#160;</td><td class="memItemRight" valign="bottom"><b>world</b></td></tr>
<tr class="separator:aae9c1871d705fa9e8aa558644f102386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20774c05b863ca8fbda1b27507e18d11"><td class="memItemLeft" align="right" valign="top"><a id="a20774c05b863ca8fbda1b27507e18d11"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>existing_comm_world</b></td></tr>
<tr class="separator:a20774c05b863ca8fbda1b27507e18d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4131b6de924c49ed98ffacf3f4e387b"><td class="memItemLeft" align="right" valign="top"><a id="ae4131b6de924c49ed98ffacf3f4e387b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>common_world</b></td></tr>
<tr class="separator:ae4131b6de924c49ed98ffacf3f4e387b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95bc248f963a13dfcca20bd71e88995"><td class="memItemLeft" align="right" valign="top"><a id="ae95bc248f963a13dfcca20bd71e88995"></a>
The common world to be&#160;</td><td class="memItemRight" valign="bottom"><b>destroyed</b></td></tr>
<tr class="separator:ae95bc248f963a13dfcca20bd71e88995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053e0c50f9ef094d0afd26e762fb25b0"><td class="memItemLeft" align="right" valign="top"><a id="a053e0c50f9ef094d0afd26e762fb25b0"></a>
The common world&#160;</td><td class="memItemRight" valign="bottom"><b>X</b> = in[0]</td></tr>
<tr class="separator:a053e0c50f9ef094d0afd26e762fb25b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b183777bd2271c4355db5cb2585519f"><td class="memItemLeft" align="right" valign="top"><a id="a3b183777bd2271c4355db5cb2585519f"></a>
The common world&#160;</td><td class="memItemRight" valign="bottom"><b>Y</b></td></tr>
<tr class="separator:a3b183777bd2271c4355db5cb2585519f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22a34562d580125c148133482def750"><td class="memItemLeft" align="right" valign="top"><a id="af22a34562d580125c148133482def750"></a>
The common world The reduced result on&#160;</td><td class="memItemRight" valign="bottom"><b>root</b></td></tr>
<tr class="separator:af22a34562d580125c148133482def750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967ffe373d585be2dbbe1d6e64cb60ab"><td class="memItemLeft" align="right" valign="top"><a id="a967ffe373d585be2dbbe1d6e64cb60ab"></a>
The common world The allreduced&#160;</td><td class="memItemRight" valign="bottom"><b>tensor</b></td></tr>
<tr class="separator:a967ffe373d585be2dbbe1d6e64cb60ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977aabc758f9d7a2b65c796fbf433d83"><td class="memItemLeft" align="right" valign="top"><a id="a977aabc758f9d7a2b65c796fbf433d83"></a>
The common world The allreduced same on all&#160;</td><td class="memItemRight" valign="bottom"><b>nodes</b></td></tr>
<tr class="separator:a977aabc758f9d7a2b65c796fbf433d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24fa41c4f9a7caf2045720dec1ab894"><td class="memItemLeft" align="right" valign="top"><a id="ad24fa41c4f9a7caf2045720dec1ab894"></a>
The common world&#160;</td><td class="memItemRight" valign="bottom"><b>dst</b></td></tr>
<tr class="separator:ad24fa41c4f9a7caf2045720dec1ab894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4100b31fea680091fc72ee3c63a3356"><td class="memItemLeft" align="right" valign="top"><a id="aa4100b31fea680091fc72ee3c63a3356"></a>
The common world An int CPUtensor of size specifying the rank If&#160;</td><td class="memItemRight" valign="bottom"><b>given</b></td></tr>
<tr class="separator:aa4100b31fea680091fc72ee3c63a3356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec0c3ada1f730fc97a3fd46174cc53f"><td class="memItemLeft" align="right" valign="top"><a id="a9ec0c3ada1f730fc97a3fd46174cc53f"></a>
The common world An int CPUtensor of size specifying the rank If this overrides the to argument of the op The rank to send the tensor to bool if&#160;</td><td class="memItemRight" valign="bottom"><b>set</b></td></tr>
<tr class="separator:a9ec0c3ada1f730fc97a3fd46174cc53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca87e17a9274257b1f0cc98eacdf2a0"><td class="memItemLeft" align="right" valign="top"><a id="a6ca87e17a9274257b1f0cc98eacdf2a0"></a>
The common world An int CPUtensor of size specifying the rank If this overrides the to argument of the op The rank to send the tensor to bool if only send the content and assume that the receiver has already known the tensor s shape and&#160;</td><td class="memItemRight" valign="bottom"><b>information</b></td></tr>
<tr class="separator:a6ca87e17a9274257b1f0cc98eacdf2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b6d7036f64365eb3a654735bc5f1b2"><td class="memItemLeft" align="right" valign="top"><a id="ad8b6d7036f64365eb3a654735bc5f1b2"></a>
The common world&#160;</td><td class="memItemRight" valign="bottom"><b>src</b></td></tr>
<tr class="separator:ad8b6d7036f64365eb3a654735bc5f1b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1641229ee1edeff1d9d378be9dceb4"><td class="memItemLeft" align="right" valign="top"><a id="a9d1641229ee1edeff1d9d378be9dceb4"></a>
The common world An int CPUtensor of size specifying the rank If this overrides the from argument of the op The received tensor&#160;</td><td class="memItemRight" valign="bottom"><b>tag</b></td></tr>
<tr class="separator:a9d1641229ee1edeff1d9d378be9dceb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e0de90e4aae812c0feab58d2baad3e"><td class="memItemLeft" align="right" valign="top"><a id="a89e0de90e4aae812c0feab58d2baad3e"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>split</b></td></tr>
<tr class="separator:a89e0de90e4aae812c0feab58d2baad3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538ab2114a9dbe0a8349c0149288a14e"><td class="memItemLeft" align="right" valign="top"><a id="a538ab2114a9dbe0a8349c0149288a14e"></a>
INT_MAX Optional list of output Which axis to split on Either NHWC or&#160;</td><td class="memItemRight" valign="bottom"><b>NCWH</b></td></tr>
<tr class="separator:a538ab2114a9dbe0a8349c0149288a14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544e450c246510c64c62fefbe3af76c7"><td class="memItemLeft" align="right" valign="top">INT_MAX Optional list of output Which axis to split on Either NHWC or will split on C&#160;</td><td class="memItemRight" valign="bottom"><b>axis</b></td></tr>
<tr class="separator:a544e450c246510c64c62fefbe3af76c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c31e73fdb2e293a08bfcc8e29688c6"><td class="memItemLeft" align="right" valign="top"><a id="a25c31e73fdb2e293a08bfcc8e29688c6"></a>
Which axis to concat on Pass to add the axis specified in arg axis to all input tensors&#160;</td><td class="memItemRight" valign="bottom"><b>concat_result</b></td></tr>
<tr class="separator:a25c31e73fdb2e293a08bfcc8e29688c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0489286b5b37e795f5465cdf33c71233"><td class="memItemLeft" align="right" valign="top"><a id="a0489286b5b37e795f5465cdf33c71233"></a>
apply conditional&#160;</td><td class="memItemRight" valign="bottom"><b>DataT</b></td></tr>
<tr class="separator:a0489286b5b37e795f5465cdf33c71233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07ea3a223f8cadbeae2e6e1c7bc43d7"><td class="memItemLeft" align="right" valign="top"><a id="ad07ea3a223f8cadbeae2e6e1c7bc43d7"></a>
apply conditional Data to use when True&#160;</td><td class="memItemRight" valign="bottom"><b>DataO</b></td></tr>
<tr class="separator:ad07ea3a223f8cadbeae2e6e1c7bc43d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39bd36f7f7391084aa8952ec062fb56c"><td class="memItemLeft" align="right" valign="top"><a id="a39bd36f7f7391084aa8952ec062fb56c"></a>
apply conditional Data to use when True Output data after applying&#160;</td><td class="memItemRight" valign="bottom"><b>ConditionalOp</b></td></tr>
<tr class="separator:a39bd36f7f7391084aa8952ec062fb56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c2938a533274cb9b74a72e0428d419"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><b>kConvDoc</b></td></tr>
<tr class="separator:ab5c2938a533274cb9b74a72e0428d419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fabd51d8e2bb1be34162923e8452749"><td class="memItemLeft" align="right" valign="top"><a id="a7fabd51d8e2bb1be34162923e8452749"></a>
the filter&#160;</td><td class="memItemRight" valign="bottom"><b>blob</b></td></tr>
<tr class="separator:a7fabd51d8e2bb1be34162923e8452749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039d1b6280ba35e31510fa7343ee2b0f"><td class="memItemLeft" align="right" valign="top"><a id="a039d1b6280ba35e31510fa7343ee2b0f"></a>
the filter and the bias and computes the output Note that other&#160;</td><td class="memItemRight" valign="bottom"><b>parameters</b></td></tr>
<tr class="separator:a039d1b6280ba35e31510fa7343ee2b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9696ea867938b2ca4a401457c87214c"><td class="memItemLeft" align="right" valign="top"><a id="ad9696ea867938b2ca4a401457c87214c"></a>
the filter and the bias and computes the output Note that other such as the stride and kernel or the pads sizes in each direction are not necessary for input because they are provided by the ConvTransposeUnpoolOpBase&#160;</td><td class="memItemRight" valign="bottom"><b>operator. Various dimension checks are done implicitly, and the sizes are specified in the Input docs for this operator. As is expected, the filter is deconvolved with a subset of the image and the bias is added</b></td></tr>
<tr class="separator:ad9696ea867938b2ca4a401457c87214c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef7c7e01c62304c3bf69c8a3e290385"><td class="memItemLeft" align="right" valign="top"><a id="afef7c7e01c62304c3bf69c8a3e290385"></a>
this is done throughout the image data and the output is computed As a side note on the implementation&#160;</td><td class="memItemRight" valign="bottom"><b>layout</b></td></tr>
<tr class="separator:afef7c7e01c62304c3bf69c8a3e290385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabbb26e87550ec50e4874868f1df0ff"><td class="memItemLeft" align="right" valign="top"><a id="adabbb26e87550ec50e4874868f1df0ff"></a>
this is done throughout the image data and the output is computed As a side note on the implementation which is why they are separate files DOC&#160;</td><td class="memItemRight" valign="bottom"><b>filter</b></td></tr>
<tr class="separator:adabbb26e87550ec50e4874868f1df0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe1f42b96e01292b15ad28c02bd1adb4"><td class="memItemLeft" align="right" valign="top"><a id="abe1f42b96e01292b15ad28c02bd1adb4"></a>
this is done throughout the image data and the output is computed As a side note on the implementation which is why they are separate files DOC The filter blob that will be used in the transposed&#160;</td><td class="memItemRight" valign="bottom"><b>convolution</b></td></tr>
<tr class="separator:abe1f42b96e01292b15ad28c02bd1adb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2edac4bc4b850734ee3b31a10344c9b4"><td class="memItemLeft" align="right" valign="top"><a id="a2edac4bc4b850734ee3b31a10344c9b4"></a>
has where C is the number of&#160;</td><td class="memItemRight" valign="bottom"><b>channels</b></td></tr>
<tr class="separator:a2edac4bc4b850734ee3b31a10344c9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad88e3171d9002bb911dc07c92fe849f7"><td class="memItemLeft" align="right" valign="top"><a id="ad88e3171d9002bb911dc07c92fe849f7"></a>
has where C is the number of and kH and kW are the height and width of the kernel Output data blob that contains the result of the transposed convolution The output dimensions are functions of the kernel stride and pad&#160;</td><td class="memItemRight" valign="bottom"><b>lengths</b></td></tr>
<tr class="separator:ad88e3171d9002bb911dc07c92fe849f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7026acab05a17cb8d768dae95f0434aa"><td class="memItemLeft" align="right" valign="top"><a id="a7026acab05a17cb8d768dae95f0434aa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>counter</b></td></tr>
<tr class="separator:a7026acab05a17cb8d768dae95f0434aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0dc6109c91a09d40376248cf2286018"><td class="memItemLeft" align="right" valign="top"><a id="ae0dc6109c91a09d40376248cf2286018"></a>
A blob pointing to an instance of a new counter Resets counter to this&#160;</td><td class="memItemRight" valign="bottom"><b>value</b></td></tr>
<tr class="separator:ae0dc6109c91a09d40376248cf2286018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af100b41879760c73a0a8e5984d2bd253"><td class="memItemLeft" align="right" valign="top"><a id="af100b41879760c73a0a8e5984d2bd253"></a>
Input blob from the previous&#160;</td><td class="memItemRight" valign="bottom"><b>layer</b></td></tr>
<tr class="separator:af100b41879760c73a0a8e5984d2bd253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e55d9b0e6c5dbac2d4b8001322931ab"><td class="memItemLeft" align="right" valign="top"><a id="a1e55d9b0e6c5dbac2d4b8001322931ab"></a>
Input blob from the previous which is almost always the result of a softmax&#160;</td><td class="memItemRight" valign="bottom"><b>operation</b></td></tr>
<tr class="separator:a1e55d9b0e6c5dbac2d4b8001322931ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bd3b602fcb3c68be16ff7ca400d623"><td class="memItemLeft" align="right" valign="top"><a id="a94bd3b602fcb3c68be16ff7ca400d623"></a>
X is a array of size N x&#160;</td><td class="memItemRight" valign="bottom"><b>D</b></td></tr>
<tr class="separator:a94bd3b602fcb3c68be16ff7ca400d623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6cb10710fc184e6cc616caf6182d66"><td class="memItemLeft" align="right" valign="top"><a id="a8a6cb10710fc184e6cc616caf6182d66"></a>
X is a array of size N x where N is the batch size and D is the number of classes Output blob after the cross entropy&#160;</td><td class="memItemRight" valign="bottom"><b>computation</b></td></tr>
<tr class="separator:a8a6cb10710fc184e6cc616caf6182d66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f5c1e3a19a6d6a5d1c14aef36a7663b"><td class="memItemLeft" align="right" valign="top"><a id="a3f5c1e3a19a6d6a5d1c14aef36a7663b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>logits</b> = in[0]</td></tr>
<tr class="separator:a3f5c1e3a19a6d6a5d1c14aef36a7663b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fe76d250f625cac01228c609b9754a"><td class="memItemLeft" align="right" valign="top"><a id="a65fe76d250f625cac01228c609b9754a"></a>
matrix of logits for each example and class&#160;</td><td class="memItemRight" valign="bottom"><b>xentropy</b></td></tr>
<tr class="separator:a65fe76d250f625cac01228c609b9754a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03278b0203e4f159132b34ed7b513c4a"><td class="memItemLeft" align="right" valign="top"><a id="a03278b0203e4f159132b34ed7b513c4a"></a>
matrix of logits for each example and class&#160;</td><td class="memItemRight" valign="bottom"><b>weights</b></td></tr>
<tr class="separator:a03278b0203e4f159132b34ed7b513c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e84d76cd6fb8c90b44f5fe5913183a1"><td class="memItemLeft" align="right" valign="top"><a id="a4e84d76cd6fb8c90b44f5fe5913183a1"></a>
or input tensor&#160;</td><td class="memItemRight" valign="bottom"><b>Z</b></td></tr>
<tr class="separator:a4e84d76cd6fb8c90b44f5fe5913183a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670980437aa26d14148d2e1d5aa3be04"><td class="memItemLeft" align="right" valign="top"><a id="a670980437aa26d14148d2e1d5aa3be04"></a>
Y with different shapes and produces one output float tensor of the dot product between X and Y We currently support two kinds of strategies to achieve this Before doing normal dot_product pad the smaller Y must be equal Only the second dimension of X or Y can be padded DOC or input tensor whether to replicate the smaller tensor or&#160;</td><td class="memItemRight" valign="bottom"><b>not</b></td></tr>
<tr class="separator:a670980437aa26d14148d2e1d5aa3be04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e10186bd5c4b61d0501819044b6119c"><td class="memItemLeft" align="right" valign="top"><a id="a0e10186bd5c4b61d0501819044b6119c"></a>
INT_MAX Subnet with blob bindings Indices of corresponding outer workspace&#160;</td><td class="memItemRight" valign="bottom"><b>blobs</b></td></tr>
<tr class="separator:a0e10186bd5c4b61d0501819044b6119c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2a34a424811068acf175bd0272749c"><td class="memItemLeft" align="right" valign="top">INT_MAX Subnet with blob bindings Indices of corresponding outer workspace in&#160;</td><td class="memItemRight" valign="bottom"><b>order</b></td></tr>
<tr class="separator:afb2a34a424811068acf175bd0272749c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c572cb5522ce6bbfdd93781bdcac5b"><td class="memItemLeft" align="right" valign="top"><a id="a45c572cb5522ce6bbfdd93781bdcac5b"></a>
INT_MAX Subnet with blob bindings Indices of corresponding outer workspace in List of blobs from the forward Do int out&#160;</td><td class="memItemRight" valign="bottom"><b>bool</b> { return true</td></tr>
<tr class="separator:a45c572cb5522ce6bbfdd93781bdcac5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65868e3ebf153459a7dc65217a7bad9"><td class="memItemLeft" align="right" valign="top"><a id="aa65868e3ebf153459a7dc65217a7bad9"></a>
<a class="el" href="classcaffe2_1_1ArgumentHelper.html">ArgumentHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><b>argsHelper</b> (def)</td></tr>
<tr class="separator:aa65868e3ebf153459a7dc65217a7bad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a1d130dec2d7bc6056118f81cadb7f"><td class="memItemLeft" align="right" valign="top"><a id="a25a1d130dec2d7bc6056118f81cadb7f"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>output_mask</b> = !argsHelper.GetSingleArgument&lt;bool&gt;(&quot;is_test&quot;, 0)</td></tr>
<tr class="separator:a25a1d130dec2d7bc6056118f81cadb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf63f11effe6678599a35f8a7dd5c41d"><td class="memItemLeft" align="right" valign="top"><a id="aaf63f11effe6678599a35f8a7dd5c41d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>float</b></td></tr>
<tr class="separator:aaf63f11effe6678599a35f8a7dd5c41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80bf284e0ee2cc6952f973c6b5bdcdc"><td class="memItemLeft" align="right" valign="top"><a id="ac80bf284e0ee2cc6952f973c6b5bdcdc"></a>
default the ratio of random dropout The input data as <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> The output mask If is_test is&#160;</td><td class="memItemRight" valign="bottom"><b>nonzero</b></td></tr>
<tr class="separator:ac80bf284e0ee2cc6952f973c6b5bdcdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad514b4db7086e54d5fc79c7bf31ea19d"><td class="memItemLeft" align="right" valign="top"><a id="ad514b4db7086e54d5fc79c7bf31ea19d"></a>
default the ratio of random dropout The input data as <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> The output mask If is_test is this output is not&#160;</td><td class="memItemRight" valign="bottom"><b>filled</b></td></tr>
<tr class="separator:ad514b4db7086e54d5fc79c7bf31ea19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f347dfcbd0ffbd16a980fa75231913a"><td class="memItemLeft" align="right" valign="top">describes the axis of the&#160;</td><td class="memItemRight" valign="bottom"><b>inputs</b></td></tr>
<tr class="separator:a6f347dfcbd0ffbd16a980fa75231913a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a445f23f61fff37bb57625359fe08cc46"><td class="memItemLeft" align="right" valign="top">defaults to one because the axis most likely describes the&#160;</td><td class="memItemRight" valign="bottom"><b>batch_size</b></td></tr>
<tr class="separator:a445f23f61fff37bb57625359fe08cc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0c33ee34c77cd3e3e16734e5991d87"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><b>kBroadcastDoc</b></td></tr>
<tr class="separator:a6e0c33ee34c77cd3e3e16734e5991d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e3d9c45a7261ea359c0626b47c447c"><td class="memItemLeft" align="right" valign="top"><a id="a86e3d9c45a7261ea359c0626b47c447c"></a>
and the dimensions of the second input is the contiguous subset of the dimensions of the first For the following tensor shapes are&#160;</td><td class="memItemRight" valign="bottom"><b>supported</b></td></tr>
<tr class="separator:a86e3d9c45a7261ea359c0626b47c447c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98688e03bca94af1143033ef9a62d245"><td class="memItemLeft" align="right" valign="top"><a id="a98688e03bca94af1143033ef9a62d245"></a>
in which case the sum will be done in place and results will be accumulated in input0 All inputs and outputs must have the same shape and data type DOC&#160;</td><td class="memItemRight" valign="bottom"><b>sum</b></td></tr>
<tr class="separator:a98688e03bca94af1143033ef9a62d245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccf5560bbe932330ac819bb50ddc719"><td class="memItemLeft" align="right" valign="top"><a id="a0ccf5560bbe932330ac819bb50ddc719"></a>
element wise This operation can be done in an in place fashion&#160;</td><td class="memItemRight" valign="bottom"><b>too</b></td></tr>
<tr class="separator:a0ccf5560bbe932330ac819bb50ddc719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3847845b7bab34c0ac034a003e75de96"><td class="memItemLeft" align="right" valign="top"><a id="a3847845b7bab34c0ac034a003e75de96"></a>
the data type of value is used The output tensor shape is specified by the shape argument If the number of input&#160;</td><td class="memItemRight" valign="bottom"><b>is</b></td></tr>
<tr class="separator:a3847845b7bab34c0ac034a003e75de96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe227faccd1ee13a1fc73cea53dcb7dd"><td class="memItemLeft" align="right" valign="top"><a id="afe227faccd1ee13a1fc73cea53dcb7dd"></a>
the data type of value is used The output tensor shape is specified by the shape argument If the number of input the shape will be identical to that of the input at run time with optional additional dimensions appended at the end as specified by extra_shape argument In that case the shape argument should not be set If input_as_shape is set to&#160;</td><td class="memItemRight" valign="bottom"><b>true</b></td></tr>
<tr class="separator:afe227faccd1ee13a1fc73cea53dcb7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb35f7b3bb97822c1fc4a1a54b21e10e"><td class="memItemLeft" align="right" valign="top"><a id="adb35f7b3bb97822c1fc4a1a54b21e10e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>index</b> = 0</td></tr>
<tr class="separator:adb35f7b3bb97822c1fc4a1a54b21e10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48184f626f27c032d0422bf8cbf662b4"><td class="memItemLeft" align="right" valign="top"><a id="a48184f626f27c032d0422bf8cbf662b4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>query</b></td></tr>
<tr class="separator:a48184f626f27c032d0422bf8cbf662b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766dbf71da6f0018a6008cce7b3a95ea"><td class="memItemLeft" align="right" valign="top"><a id="a766dbf71da6f0018a6008cce7b3a95ea"></a>
TIndex&#160;</td><td class="memItemRight" valign="bottom"><b>outer</b> = 1</td></tr>
<tr class="separator:a766dbf71da6f0018a6008cce7b3a95ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80c584df6cbb5d2a753947e77b45720"><td class="memItemLeft" align="right" valign="top"><a id="ae80c584df6cbb5d2a753947e77b45720"></a>
TIndex&#160;</td><td class="memItemRight" valign="bottom"><b>inner</b> = 1</td></tr>
<tr class="separator:ae80c584df6cbb5d2a753947e77b45720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984c2d4fbe3b1b9e1602f2ec24fe135f"><td class="memItemLeft" align="right" valign="top">A tensor of&#160;</td><td class="memItemRight" valign="bottom"><b>rank</b></td></tr>
<tr class="separator:a984c2d4fbe3b1b9e1602f2ec24fe135f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6983994631763a3136899aae48027a"><td class="memItemLeft" align="right" valign="top"><a id="a0f6983994631763a3136899aae48027a"></a>
in a sequence length aware fashion&#160;</td><td class="memItemRight" valign="bottom"><b>Concretely</b></td></tr>
<tr class="separator:a0f6983994631763a3136899aae48027a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bbf8f3ec52ccd3913154c386b75a9e"><td class="memItemLeft" align="right" valign="top"><a id="a79bbf8f3ec52ccd3913154c386b75a9e"></a>
in a sequence length aware fashion given the previous hidden and the sequence computes the GRU&#160;</td><td class="memItemRight" valign="bottom"><b>activations</b></td></tr>
<tr class="separator:a79bbf8f3ec52ccd3913154c386b75a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019e70013d9197422138abe4913baa67"><td class="memItemLeft" align="right" valign="top"><a id="a019e70013d9197422138abe4913baa67"></a>
in a sequence length aware fashion given the previous hidden and the sequence computes the GRU avoiding computation if the input is Bool to determine if hidden state is zeroes or passed along for timesteps past the given sequence_length&#160;</td><td class="memItemRight" valign="bottom"><b>gates</b></td></tr>
<tr class="separator:a019e70013d9197422138abe4913baa67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ce5a02a90f02aac5324920e24ccfd5"><td class="memItemLeft" align="right" valign="top"><a id="ae1ce5a02a90f02aac5324920e24ccfd5"></a>
in a sequence length aware fashion given the previous hidden and the sequence computes the GRU avoiding computation if the input is Bool to determine if hidden state is zeroes or passed along for timesteps past the given sequence_length Unactivated gate outputs from&#160;</td><td class="memItemRight" valign="bottom"><b>forget</b></td></tr>
<tr class="separator:ae1ce5a02a90f02aac5324920e24ccfd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e5da5cdcd95ca28ec9501fa791326e"><td class="memItemLeft" align="right" valign="top"><a id="ad0e5da5cdcd95ca28ec9501fa791326e"></a>
in a sequence length aware fashion given the previous hidden and the sequence computes the GRU avoiding computation if the input is Bool to determine if hidden state is zeroes or passed along for timesteps past the given sequence_length Unactivated gate outputs from&#160;</td><td class="memItemRight" valign="bottom"><b>update</b></td></tr>
<tr class="separator:ad0e5da5cdcd95ca28ec9501fa791326e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218c1e40fee4183bff563f824ff34377"><td class="memItemLeft" align="right" valign="top"><a id="a218c1e40fee4183bff563f824ff34377"></a>
in a sequence length aware fashion given the previous hidden and the sequence computes the GRU avoiding computation if the input is Bool to determine if hidden state is zeroes or passed along for timesteps past the given sequence_length Unactivated gate outputs from and output pre activation&#160;</td><td class="memItemRight" valign="bottom"><b>t</b></td></tr>
<tr class="separator:a218c1e40fee4183bff563f824ff34377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75af76b9adf6d15343f3c87937d96132"><td class="memItemLeft" align="right" valign="top"><a id="a75af76b9adf6d15343f3c87937d96132"></a>
INT_MAX Net executed when condition is true&#160;</td><td class="memItemRight" valign="bottom"><b>condition</b></td></tr>
<tr class="separator:a75af76b9adf6d15343f3c87937d96132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3191fe8913602861ca2e39b0a67ed9"><td class="memItemLeft" align="right" valign="top"><a id="a8e3191fe8913602861ca2e39b0a67ed9"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>pad</b> = helper.GetSingleArgument&lt;int&gt;(&quot;pad&quot;, 0)</td></tr>
<tr class="separator:a8e3191fe8913602861ca2e39b0a67ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b9abe1c69fb306a265046144f3c385"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>kernel_h</b></td></tr>
<tr class="separator:ac2b9abe1c69fb306a265046144f3c385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaed860c253cc3623218f5e049f56807"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>kernel_w</b></td></tr>
<tr class="separator:aaaed860c253cc3623218f5e049f56807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6813549291034e22b8c23512190e36e1"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>dilation_h</b></td></tr>
<tr class="separator:a6813549291034e22b8c23512190e36e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8bd7d72a9b3c36434015674bc13cd7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>dilation_w</b></td></tr>
<tr class="separator:a0a8bd7d72a9b3c36434015674bc13cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433ab69df61deb5e78008f2017514433"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>stride_h</b></td></tr>
<tr class="separator:a433ab69df61deb5e78008f2017514433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f24cb994d9da9475e824cc5715772d"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>stride_w</b></td></tr>
<tr class="separator:a28f24cb994d9da9475e824cc5715772d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af099ee4ee7c78151eb49c18aa60795b4"><td class="memItemLeft" align="right" valign="top"><a id="af099ee4ee7c78151eb49c18aa60795b4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>N</b> = 0</td></tr>
<tr class="separator:af099ee4ee7c78151eb49c18aa60795b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae189538801086127a94afccdbdb0f38f"><td class="memItemLeft" align="right" valign="top"><a id="ae189538801086127a94afccdbdb0f38f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>C</b> = 0</td></tr>
<tr class="separator:ae189538801086127a94afccdbdb0f38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72e7eedcfaa48d1b7be4a5bf5a4c8be"><td class="memItemLeft" align="right" valign="top"><a id="af72e7eedcfaa48d1b7be4a5bf5a4c8be"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>H</b> = 0</td></tr>
<tr class="separator:af72e7eedcfaa48d1b7be4a5bf5a4c8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d5f5c721ebeff0c349e45a5c1b5bd4"><td class="memItemLeft" align="right" valign="top"><a id="a38d5f5c721ebeff0c349e45a5c1b5bd4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>W</b> = 0</td></tr>
<tr class="separator:a38d5f5c721ebeff0c349e45a5c1b5bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1967cf82937108e793eb54b0b67f21b0"><td class="memItemLeft" align="right" valign="top"><a id="a1967cf82937108e793eb54b0b67f21b0"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>dkernel_h</b> = dilation_h * (kernel_h - 1) + 1</td></tr>
<tr class="separator:a1967cf82937108e793eb54b0b67f21b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15994695a9f9cdadf3630c54ad6b80b"><td class="memItemLeft" align="right" valign="top"><a id="af15994695a9f9cdadf3630c54ad6b80b"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>dkernel_w</b> = dilation_w * (kernel_w - 1) + 1</td></tr>
<tr class="separator:af15994695a9f9cdadf3630c54ad6b80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac949bdc75720d6d87772574ddfa39974"><td class="memItemLeft" align="right" valign="top"><a id="ac949bdc75720d6d87772574ddfa39974"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>out_h</b> = (H + 2 * pad - dkernel_h) / stride_h + 1</td></tr>
<tr class="separator:ac949bdc75720d6d87772574ddfa39974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0262e3344411b113a3733e7bc902e2e"><td class="memItemLeft" align="right" valign="top"><a id="ae0262e3344411b113a3733e7bc902e2e"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>out_w</b> = (W + 2 * pad - dkernel_w) / stride_w + 1</td></tr>
<tr class="separator:ae0262e3344411b113a3733e7bc902e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4163bdb6c6ed9c3f5ca8a54ae7af557"><td class="memItemLeft" align="right" valign="top"><a id="ac4163bdb6c6ed9c3f5ca8a54ae7af557"></a>
Max number of&#160;</td><td class="memItemRight" valign="bottom"><b>elements</b></td></tr>
<tr class="separator:ac4163bdb6c6ed9c3f5ca8a54ae7af557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0a29cc27c9bbf99aa8d8f6676f5879"><td class="memItemLeft" align="right" valign="top"><a id="a1c0a29cc27c9bbf99aa8d8f6676f5879"></a>
return an Int tensor of same shape containing the indices for each of the keys If the index is&#160;</td><td class="memItemRight" valign="bottom"><b>frozen</b></td></tr>
<tr class="separator:a1c0a29cc27c9bbf99aa8d8f6676f5879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b458a9c12db9cd3c46e7dc915fa127"><td class="memItemLeft" align="right" valign="top"><a id="a96b458a9c12db9cd3c46e7dc915fa127"></a>
return an Int tensor of same shape containing the indices for each of the keys If the index is unknown entries are given index&#160;</td><td class="memItemRight" valign="bottom"><b>Otherwise</b></td></tr>
<tr class="separator:a96b458a9c12db9cd3c46e7dc915fa127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32d2691bcb314721c42ac8efbf00d542"><td class="memItemLeft" align="right" valign="top"><a id="a32d2691bcb314721c42ac8efbf00d542"></a>
return an Int tensor of same shape containing the indices for each of the keys If the index is unknown entries are given index new entries are added into the index If an insert is necessary but max_elements has been&#160;</td><td class="memItemRight" valign="bottom"><b>reached</b></td></tr>
<tr class="separator:a32d2691bcb314721c42ac8efbf00d542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add92182063935ff83c56d664bebe6cc6"><td class="memItemLeft" align="right" valign="top"><a id="add92182063935ff83c56d664bebe6cc6"></a>
return an Int tensor of same shape containing the indices for each of the keys If the index is unknown entries are given index new entries are added into the index If an insert is necessary but max_elements has been fail DOC&#160;</td><td class="memItemRight" valign="bottom"><b>keys</b></td></tr>
<tr class="separator:add92182063935ff83c56d664bebe6cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b22611ea21528b9c509b99a53125d9"><td class="memItemLeft" align="right" valign="top"><a id="a69b22611ea21528b9c509b99a53125d9"></a>
disallowing creation of new index entries Should not be called concurrently with IndexGet DOC&#160;</td><td class="memItemRight" valign="bottom"><b>handle</b></td></tr>
<tr class="separator:a69b22611ea21528b9c509b99a53125d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd5f74034dd7155bb25a22d33d17f23"><td class="memItemLeft" align="right" valign="top"><a id="a4bd5f74034dd7155bb25a22d33d17f23"></a>
Pointer to an <a class="el" href="structcaffe2_1_1Index.html">Index</a> instance The input handle If skips the first entry of the tensor This allows to load tensors that are aligned with an&#160;</td><td class="memItemRight" valign="bottom"><b>embedding</b></td></tr>
<tr class="separator:a4bd5f74034dd7155bb25a22d33d17f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4f69ab33688c8da3f998b535e8560c"><td class="memItemLeft" align="right" valign="top"><a id="a1f4f69ab33688c8da3f998b535e8560c"></a>
Pointer to an <a class="el" href="structcaffe2_1_1Index.html">Index</a> instance The input handle If skips the first entry of the tensor This allows to load tensors that are aligned with an where the first entry corresponds to the default index&#160;</td><td class="memItemRight" valign="bottom"><b>entry</b></td></tr>
<tr class="separator:a1f4f69ab33688c8da3f998b535e8560c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7960ab3a5bdbf445c0cc1ea8bc90bb6"><td class="memItemLeft" align="right" valign="top"><a id="ac7960ab3a5bdbf445c0cc1ea8bc90bb6"></a>
the first element of the output tensor will be element of index DOC&#160;</td><td class="memItemRight" valign="bottom"><b>items</b></td></tr>
<tr class="separator:ac7960ab3a5bdbf445c0cc1ea8bc90bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6875db97deb54ba11f0eea9b6ef95a84"><td class="memItemLeft" align="right" valign="top"><a id="a6875db97deb54ba11f0eea9b6ef95a84"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>input_dims_long</b> = GetDimsVector(in[0])</td></tr>
<tr class="separator:a6875db97deb54ba11f0eea9b6ef95a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833087f682593970e7914e0992e5d3df"><td class="memItemLeft" align="right" valign="top">const auto&#160;</td><td class="memItemRight" valign="bottom"><b>canonical_axis</b></td></tr>
<tr class="separator:a833087f682593970e7914e0992e5d3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f248edb335c7db3f943e3b778aa2ae"><td class="memItemLeft" align="right" valign="top"><a id="a68f248edb335c7db3f943e3b778aa2ae"></a>
int default&#160;</td><td class="memItemRight" valign="bottom"><b>to</b></td></tr>
<tr class="separator:a68f248edb335c7db3f943e3b778aa2ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7ee5ca45d083c80de818b3b666a25e"><td class="memItemLeft" align="right" valign="top"><a id="afa7ee5ca45d083c80de818b3b666a25e"></a>
Describes axis of the inputs Defaults to one because the axis most likely describes the batch size Input tensor which layer normalization will be applied to&#160;</td><td class="memItemRight" valign="bottom"><b>mean</b></td></tr>
<tr class="separator:afa7ee5ca45d083c80de818b3b666a25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0da689d8212224b47e12a018391ebfa"><td class="memItemLeft" align="right" valign="top"><a id="ae0da689d8212224b47e12a018391ebfa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>m_2</b></td></tr>
<tr class="separator:ae0da689d8212224b47e12a018391ebfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb37478836eb6c97f2c3b98af5b83b2"><td class="memItemLeft" align="right" valign="top"><a id="aebb37478836eb6c97f2c3b98af5b83b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>m_n</b></td></tr>
<tr class="separator:aebb37478836eb6c97f2c3b98af5b83b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2535a732c1ece7df1aaf184b8c9089de"><td class="memItemLeft" align="right" valign="top">reshape it into matrix of we compute&#160;</td><td class="memItemRight" valign="bottom"><b>scale_i</b></td></tr>
<tr class="separator:a2535a732c1ece7df1aaf184b8c9089de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f344d80280c15df7d0c165e69e12e4b"><td class="memItemLeft" align="right" valign="top"><a id="a3f344d80280c15df7d0c165e69e12e4b"></a>
reshape it into matrix of we compute where min_i and max_i minimum and maximum elements of i th&#160;</td><td class="memItemRight" valign="bottom"><b>row</b></td></tr>
<tr class="separator:a3f344d80280c15df7d0c165e69e12e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc9b7cc28c1e368ab79d928e9ae438f1"><td class="memItemLeft" align="right" valign="top">reshape it into matrix of we compute where min_i and max_i minimum and maximum elements of i th and quantize each element&#160;</td><td class="memItemRight" valign="bottom"><b>r_</b></td></tr>
<tr class="separator:afc9b7cc28c1e368ab79d928e9ae438f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ba68ae37acc6c8d1c4ef5741d5482c"><td class="memItemLeft" align="right" valign="top"><a id="a80ba68ae37acc6c8d1c4ef5741d5482c"></a>
reshape it into matrix of we compute where min_i and max_i minimum and maximum elements of i th and quantize each element each row r_i of which stores a pair&#160;</td><td class="memItemRight" valign="bottom"><b>s_i</b></td></tr>
<tr class="separator:a80ba68ae37acc6c8d1c4ef5741d5482c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e03ec9f80df496fa9cc57097a53280c"><td class="memItemLeft" align="right" valign="top"><a id="a6e03ec9f80df496fa9cc57097a53280c"></a>
reshape it into matrix of we compute where min_i and max_i minimum and maximum elements of i th and quantize each element each row r_i of which stores a pair&#160;</td><td class="memItemRight" valign="bottom"><b>b_i</b></td></tr>
<tr class="separator:a6e03ec9f80df496fa9cc57097a53280c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15db7db5c2b5cf0082bdcbeefcc1bad"><td class="memItemLeft" align="right" valign="top"><a id="ad15db7db5c2b5cf0082bdcbeefcc1bad"></a>
and LENGTHS tensor of duplicate each entry of the outer most dimension of DATA according to&#160;</td><td class="memItemRight" valign="bottom"><b>LENGTHS</b></td></tr>
<tr class="separator:ad15db7db5c2b5cf0082bdcbeefcc1bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a0db4af58de5f768499e496ab7a29c"><td class="memItemLeft" align="right" valign="top"><a id="a41a0db4af58de5f768499e496ab7a29c"></a>
and LENGTHS tensor of duplicate each entry of the outer most dimension of DATA according to and concatenate them in an output tensor of rank r&#160;</td><td class="memItemRight" valign="bottom"><b>Example</b></td></tr>
<tr class="separator:a41a0db4af58de5f768499e496ab7a29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad935f957cc82d96f8de98d0a4d0d6b92"><td class="memItemLeft" align="right" valign="top"><a id="ad935f957cc82d96f8de98d0a4d0d6b92"></a>
where segments are defined by their and concatenate them in an output tensor of&#160;</td><td class="memItemRight" valign="bottom"><b>shape</b> =(SIZE(LENGTHs), k). In case there's less than k values in a segment</td></tr>
<tr class="separator:ad935f957cc82d96f8de98d0a4d0d6b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87e96d4c7b59961d67e39a6b1c8b84c"><td class="memItemLeft" align="right" valign="top"><a id="af87e96d4c7b59961d67e39a6b1c8b84c"></a>
where segments are defined by their and concatenate them in an output tensor of the output value will be padded and the corresponding output indices will be padded by DOC <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> of int32 lengths of rank&#160;</td><td class="memItemRight" valign="bottom"><b>TopKIndices</b></td></tr>
<tr class="separator:af87e96d4c7b59961d67e39a6b1c8b84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae025e8482eec57d2f947daf162265e81"><td class="memItemLeft" align="right" valign="top"><a id="ae025e8482eec57d2f947daf162265e81"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>exists</b></td></tr>
<tr class="separator:ae025e8482eec57d2f947daf162265e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a539ca45c2e0532614691edbef5115"><td class="memItemLeft" align="right" valign="top"><a id="a26a539ca45c2e0532614691edbef5115"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>int</b></td></tr>
<tr class="separator:a26a539ca45c2e0532614691edbef5115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca6d38fee66f487b9d4494ae5358fd7"><td class="memItemLeft" align="right" valign="top"><a id="a4ca6d38fee66f487b9d4494ae5358fd7"></a>
INT_MAX default if use the db path directly and do not prepend the current root folder of the workspace&#160;</td><td class="memItemRight" valign="bottom"><b>string</b></td></tr>
<tr class="separator:a4ca6d38fee66f487b9d4494ae5358fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba5dd7b582b38ee4365b23decf8e6cd"><td class="memItemLeft" align="right" valign="top">INT_MAX default if use the db path directly and do not prepend the current root folder of the workspace&#160;</td><td class="memItemRight" valign="bottom"><b>default</b></td></tr>
<tr class="separator:adba5dd7b582b38ee4365b23decf8e6cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f5fe4728e1b8a42ff90c79dbb7c11a"><td class="memItemLeft" align="right" valign="top"><a id="ad5f5fe4728e1b8a42ff90c79dbb7c11a"></a>
but allows one to save to db every few&#160;</td><td class="memItemRight" valign="bottom"><b>iterations</b></td></tr>
<tr class="separator:ad5f5fe4728e1b8a42ff90c79dbb7c11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd8f8eaacd4ddb2a9217445821478f7"><td class="memItemLeft" align="right" valign="top"><a id="a7dd8f8eaacd4ddb2a9217445821478f7"></a>
stride&#160;</td><td class="memItemRight" valign="bottom"><b>sizes</b></td></tr>
<tr class="separator:a7dd8f8eaacd4ddb2a9217445821478f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f5f539715d65f5c68f344c868355d5"><td class="memItemLeft" align="right" valign="top"><a id="aa8f5f539715d65f5c68f344c868355d5"></a>
stride and pad lengths defined by the <a class="el" href="classcaffe2_1_1ConvPoolOpBase.html">ConvPoolOpBase</a> Output data tensor from L p pooling across the input tensor Dimensions will vary based on various&#160;</td><td class="memItemRight" valign="bottom"><b>kernel</b></td></tr>
<tr class="separator:aa8f5f539715d65f5c68f344c868355d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedcf06f00cafa9c79c0b1ac1c3f8106"><td class="memItemLeft" align="right" valign="top"><a id="afedcf06f00cafa9c79c0b1ac1c3f8106"></a>
stride and pad lengths defined by the <a class="el" href="classcaffe2_1_1ConvPoolOpBase.html">ConvPoolOpBase</a> Output data tensor from L p pooling across the input tensor Dimensions will vary based on various&#160;</td><td class="memItemRight" valign="bottom"><b>stride</b></td></tr>
<tr class="separator:afedcf06f00cafa9c79c0b1ac1c3f8106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2e799eef5663bc0ac3e9103493c53d"><td class="memItemLeft" align="right" valign="top"><a id="aee2e799eef5663bc0ac3e9103493c53d"></a>
in a sequence length aware fashion given the previous cell and the sequence computes the LSTM avoiding computation if the input is Bias term to add in while calculating forget&#160;</td><td class="memItemRight" valign="bottom"><b>gate</b></td></tr>
<tr class="separator:aee2e799eef5663bc0ac3e9103493c53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27fa78c467fba5c61c550605162022c"><td class="memItemLeft" align="right" valign="top">and label is applied to the tensor elementwise If&#160;</td><td class="memItemRight" valign="bottom"><b>y</b></td></tr>
<tr class="separator:af27fa78c467fba5c61c550605162022c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a332cb22714eba8bb0fdef14c34030d"><td class="memItemLeft" align="right" valign="top"><a id="a7a332cb22714eba8bb0fdef14c34030d"></a>
<a class="el" href="classcaffe2_1_1ArgumentHelper.html">ArgumentHelper</a>&#160;</td><td class="memItemRight" valign="bottom"><b>arg_helper</b> (def)</td></tr>
<tr class="separator:a7a332cb22714eba8bb0fdef14c34030d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbc7a0971315979347ee50dd9b153b2"><td class="memItemLeft" align="right" valign="top"><a id="afdbc7a0971315979347ee50dd9b153b2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>axis_a</b> = arg_helper.GetSingleArgument&lt;int&gt;(&quot;axis_a&quot;, 1)</td></tr>
<tr class="separator:afdbc7a0971315979347ee50dd9b153b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974f589c507849a1391d7dc6d652795d"><td class="memItemLeft" align="right" valign="top"><a id="a974f589c507849a1391d7dc6d652795d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>axis_b</b> = arg_helper.GetSingleArgument&lt;int&gt;(&quot;axis_b&quot;, 1)</td></tr>
<tr class="separator:a974f589c507849a1391d7dc6d652795d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebecc3bf57cafeb8faa1a924893b6e3e"><td class="memItemLeft" align="right" valign="top"><a id="aebecc3bf57cafeb8faa1a924893b6e3e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>trans_a</b> = arg_helper.GetSingleArgument&lt;bool&gt;(&quot;trans_a&quot;, false)</td></tr>
<tr class="separator:aebecc3bf57cafeb8faa1a924893b6e3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cae62b6a05427609c18f31bde7b452a"><td class="memItemLeft" align="right" valign="top"><a id="a7cae62b6a05427609c18f31bde7b452a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>trans_b</b> = arg_helper.GetSingleArgument&lt;bool&gt;(&quot;trans_b&quot;, false)</td></tr>
<tr class="separator:a7cae62b6a05427609c18f31bde7b452a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a445908fa33836b816544f0bf3c4c1"><td class="memItemLeft" align="right" valign="top"><a id="a88a445908fa33836b816544f0bf3c4c1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>canonical_axis_a</b> = canonical_axis_index_(axis_a, in[0].dims().size())</td></tr>
<tr class="separator:a88a445908fa33836b816544f0bf3c4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29606596277dd30518b88d66b63c4979"><td class="memItemLeft" align="right" valign="top"><a id="a29606596277dd30518b88d66b63c4979"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>canonical_axis_b</b> = canonical_axis_index_(axis_b, in[0].dims().size())</td></tr>
<tr class="separator:a29606596277dd30518b88d66b63c4979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eda6ae4fc6876444d4e435bc7fc1149"><td class="memItemLeft" align="right" valign="top"><a id="a9eda6ae4fc6876444d4e435bc7fc1149"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>M</b> = size_to_dim_(canonical_axis_a, GetDimsVector(in[0]))</td></tr>
<tr class="separator:a9eda6ae4fc6876444d4e435bc7fc1149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37306cd3376aac0448ddc53315551bc1"><td class="memItemLeft" align="right" valign="top"><a id="a37306cd3376aac0448ddc53315551bc1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>A</b></td></tr>
<tr class="separator:a37306cd3376aac0448ddc53315551bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f5228af31085e0986b62a8161fc3eb"><td class="memItemLeft" align="right" valign="top"><a id="a40f5228af31085e0986b62a8161fc3eb"></a>
matrix of&#160;</td><td class="memItemRight" valign="bottom"><b>B</b></td></tr>
<tr class="separator:a40f5228af31085e0986b62a8161fc3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7f63133167d59328c15c4ce234b50a"><td class="memItemLeft" align="right" valign="top"><a id="a4f7f63133167d59328c15c4ce234b50a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>data_0</b></td></tr>
<tr class="separator:a4f7f63133167d59328c15c4ce234b50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a972833e2089ab4cb0b33f5e9d43b7e3c"><td class="memItemLeft" align="right" valign="top"><a id="a972833e2089ab4cb0b33f5e9d43b7e3c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>prediction</b></td></tr>
<tr class="separator:a972833e2089ab4cb0b33f5e9d43b7e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594cf996b8817ed8d72c760e8e9c804b"><td class="memItemLeft" align="right" valign="top"><a id="a594cf996b8817ed8d72c760e8e9c804b"></a>
D float i&#160;</td><td class="memItemRight" valign="bottom"><b>e</b></td></tr>
<tr class="separator:a594cf996b8817ed8d72c760e8e9c804b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b699a0901714ff53746bce0243dd643"><td class="memItemLeft" align="right" valign="top"><a id="a1b699a0901714ff53746bce0243dd643"></a>
D float i batch size D is number of possible classes labels&#160;</td><td class="memItemRight" valign="bottom"><b>accuracies</b></td></tr>
<tr class="separator:a1b699a0901714ff53746bce0243dd643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcd9c1d66f538e1000206e7b9b26574"><td class="memItemLeft" align="right" valign="top"><a id="a8bcd9c1d66f538e1000206e7b9b26574"></a>
axis to&#160;</td><td class="memItemRight" valign="bottom"><b>normalize</b></td></tr>
<tr class="separator:a8bcd9c1d66f538e1000206e7b9b26574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b28b26806c1ddee8436edfc223357a0"><td class="memItemLeft" align="right" valign="top"><a id="a7b28b26806c1ddee8436edfc223357a0"></a>
bucketize it based on the boundary values and then do one hot encoding The lengths specifies the number of boundary values for each column The final number of buckets is this number plus This would also be the expanded feature size boundaries specifies all the boundary values Note that each bucket is right inclusive That given boundary&#160;</td><td class="memItemRight" valign="bottom"><b>values</b> [b1, b2, b3]</td></tr>
<tr class="separator:a7b28b26806c1ddee8436edfc223357a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c795ac7b5679d106913d1e43f1ede8"><td class="memItemLeft" align="right" valign="top"><a id="af6c795ac7b5679d106913d1e43f1ede8"></a>
d int long tensor contains the length in each of the output&#160;</td><td class="memItemRight" valign="bottom"><b>packed_tensor</b></td></tr>
<tr class="separator:af6c795ac7b5679d106913d1e43f1ede8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d058cb2d3aecab8aa693b25b1e7ab33"><td class="memItemLeft" align="right" valign="top"><a id="a4d058cb2d3aecab8aa693b25b1e7ab33"></a>
d int long tensor contains the length in each of the output N dim <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> where&#160;</td><td class="memItemRight" valign="bottom"><b>presence_mask</b></td></tr>
<tr class="separator:a4d058cb2d3aecab8aa693b25b1e7ab33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582a59c237d9eb43bcbf72d14b26269e"><td class="memItemLeft" align="right" valign="top"><a id="a582a59c237d9eb43bcbf72d14b26269e"></a>
d int long tensor contains the length in each of the output N dim <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> where dim boolean false where packed_tensor is&#160;</td><td class="memItemRight" valign="bottom"><b>padded</b></td></tr>
<tr class="separator:a582a59c237d9eb43bcbf72d14b26269e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a316f28455ca932b1950c268bdd2ec"><td class="memItemLeft" align="right" valign="top"><a id="a93a316f28455ca932b1950c268bdd2ec"></a>
d int long tensor contains the length in each of the input N dim&#160;</td><td class="memItemRight" valign="bottom"><b>Tensor</b></td></tr>
<tr class="separator:a93a316f28455ca932b1950c268bdd2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44dcb44f4ea48621f7963d6e79a4e86"><td class="memItemLeft" align="right" valign="top"><a id="ae44dcb44f4ea48621f7963d6e79a4e86"></a>
<a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> ::PadTensorInference Input data tensor from the previous&#160;</td><td class="memItemRight" valign="bottom"><b>operator</b></td></tr>
<tr class="separator:ae44dcb44f4ea48621f7963d6e79a4e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0a98ae5bc51ac68c5fecf74846a08d"><td class="memItemLeft" align="right" valign="top"><a id="aba0a98ae5bc51ac68c5fecf74846a08d"></a>
dimensions depend on whether the NCHW or NHWC operators are being used For in the&#160;</td><td class="memItemRight" valign="bottom"><b>former</b></td></tr>
<tr class="separator:aba0a98ae5bc51ac68c5fecf74846a08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f923b87087a980366cac5fc9938fa4"><td class="memItemLeft" align="right" valign="top"><a id="a24f923b87087a980366cac5fc9938fa4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>probabilities</b></td></tr>
<tr class="separator:a24f923b87087a980366cac5fc9938fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb88ea06e7c7786f7fccf89856c939b"><td class="memItemLeft" align="right" valign="top"><a id="aaeb88ea06e7c7786f7fccf89856c939b"></a>
a D or D slopes and intercepts The output tensor has the same shape of input predictions and contains the predictions transformed by the piecewise linear functions Each column of predictions has its own piecewise linear transformation functions Therefore the size of piecewise function parameters are pieces x&#160;</td><td class="memItemRight" valign="bottom"><b>prediction_dimensions</b></td></tr>
<tr class="separator:aaeb88ea06e7c7786f7fccf89856c939b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0dd04e683afcc83fca64b8cdb7f2d4"><td class="memItemLeft" align="right" valign="top"><a id="afe0dd04e683afcc83fca64b8cdb7f2d4"></a>
a D or D slopes and intercepts The output tensor has the same shape of input predictions and contains the predictions transformed by the piecewise linear functions Each column of predictions has its own piecewise linear transformation functions Therefore the size of piecewise function parameters are pieces x except for binary predictions where only the positive prediction needs them Note that in each&#160;</td><td class="memItemRight" valign="bottom"><b>piece</b></td></tr>
<tr class="separator:afe0dd04e683afcc83fca64b8cdb7f2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07067d0cf60007501b36e4723269c04"><td class="memItemLeft" align="right" valign="top"><a id="ae07067d0cf60007501b36e4723269c04"></a>
a D or D slopes and intercepts The output tensor has the same shape of input predictions and contains the predictions transformed by the piecewise linear functions Each column of predictions has its own piecewise linear transformation functions Therefore the size of piecewise function parameters are pieces x except for binary predictions where only the positive prediction needs them Note that in each low bound is excluded while high bound is included Also the piecewise linear function must be continuous Notes If the input is binary set the binary arg to true so that one group of piecewise linear functions is&#160;</td><td class="memItemRight" valign="bottom"><b>slopes</b></td></tr>
<tr class="separator:ae07067d0cf60007501b36e4723269c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44d0d1acf67e19a840413070a7ff482"><td class="memItemLeft" align="right" valign="top"><a id="ae44d0d1acf67e19a840413070a7ff482"></a>
a D or D slopes and intercepts The output tensor has the same shape of input predictions and contains the predictions transformed by the piecewise linear functions Each column of predictions has its own piecewise linear transformation functions Therefore the size of piecewise function parameters are pieces x except for binary predictions where only the positive prediction needs them Note that in each low bound is excluded while high bound is included Also the piecewise linear function must be continuous Notes If the input is binary set the binary arg to true so that one group of piecewise linear functions is intercepts can be passed either through args or through input blobs If we have multiple groups of piecewise linear&#160;</td><td class="memItemRight" valign="bottom"><b>functions</b></td></tr>
<tr class="separator:ae44d0d1acf67e19a840413070a7ff482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c055b4bef5e52acb925112a7e4bae8d"><td class="memItemLeft" align="right" valign="top"><a id="a5c055b4bef5e52acb925112a7e4bae8d"></a>
a D or D slopes and intercepts The output tensor has the same shape of input predictions and contains the predictions transformed by the piecewise linear functions Each column of predictions has its own piecewise linear transformation functions Therefore the size of piecewise function parameters are pieces x except for binary predictions where only the positive prediction needs them Note that in each low bound is excluded while high bound is included Also the piecewise linear function must be continuous Notes If the input is binary set the binary arg to true so that one group of piecewise linear functions is intercepts can be passed either through args or through input blobs If we have multiple groups of piecewise linear each group has the same number of pieces If a prediction is out of the&#160;</td><td class="memItemRight" valign="bottom"><b>bounds</b></td></tr>
<tr class="separator:a5c055b4bef5e52acb925112a7e4bae8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa771dd5c684177749fac98017f820793"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><b>kAveragePoolDoc</b></td></tr>
<tr class="separator:aa771dd5c684177749fac98017f820793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a955b975554d5a59f51b580ac5ca05"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><b>kMaxPoolDoc</b></td></tr>
<tr class="separator:af8a955b975554d5a59f51b580ac5ca05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ae51abe6d2ce42e6c8dd18d0faaea9"><td class="memItemLeft" align="right" valign="top"><a id="aa3ae51abe6d2ce42e6c8dd18d0faaea9"></a>
and produces one output is applied to the data tensor elementwise DOC&#160;</td><td class="memItemRight" valign="bottom"><b>Slope</b></td></tr>
<tr class="separator:aa3ae51abe6d2ce42e6c8dd18d0faaea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75335d9753ecb69e051ed5d231330b3a"><td class="memItemLeft" align="right" valign="top"><a id="a75335d9753ecb69e051ed5d231330b3a"></a>
Size of the dimension to prepend&#160;</td><td class="memItemRight" valign="bottom"><b>reshaped</b></td></tr>
<tr class="separator:a75335d9753ecb69e051ed5d231330b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf414ec5335b860871be92441009791"><td class="memItemLeft" align="right" valign="top"><a id="aabf414ec5335b860871be92441009791"></a>
Prefix string to prepend extracted blobs&#160;</td><td class="memItemRight" valign="bottom"><b>blob_names</b></td></tr>
<tr class="separator:aabf414ec5335b860871be92441009791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6063e6bcaed3c21cfc5ba2a2d4a42db"><td class="memItemLeft" align="right" valign="top"><a id="ad6063e6bcaed3c21cfc5ba2a2d4a42db"></a>
Prefix string to prepend extracted blobs tensor of strings containing extracted blob&#160;</td><td class="memItemRight" valign="bottom"><b>names</b></td></tr>
<tr class="separator:ad6063e6bcaed3c21cfc5ba2a2d4a42db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc85df67937009da8c9b40f8e200a67"><td class="memItemLeft" align="right" valign="top"><a id="affc85df67937009da8c9b40f8e200a67"></a>
the implementation takes an the hidden state the cell and a weight&#160;</td><td class="memItemRight" valign="bottom"><b>TxNxD</b></td></tr>
<tr class="separator:affc85df67937009da8c9b40f8e200a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc4cd73d7a27e1f7a87b8472166f860"><td class="memItemLeft" align="right" valign="top"><a id="a3dc4cd73d7a27e1f7a87b8472166f860"></a>
the implementation takes an the hidden state the cell and a weight the final hidden cell&#160;</td><td class="memItemRight" valign="bottom"><b>bidirectional</b></td></tr>
<tr class="separator:a3dc4cd73d7a27e1f7a87b8472166f860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265eb912ecfd3e936faaa35ffc48fe5a"><td class="memItemLeft" align="right" valign="top"><a id="a265eb912ecfd3e936faaa35ffc48fe5a"></a>
the implementation takes an the hidden state the cell and a weight the final hidden cell&#160;</td><td class="memItemRight" valign="bottom"><b>num_layers</b></td></tr>
<tr class="separator:a265eb912ecfd3e936faaa35ffc48fe5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a14739188d2f98346f4b2fe102fcf0"><td class="memItemLeft" align="right" valign="top"><a id="ab1a14739188d2f98346f4b2fe102fcf0"></a>
the implementation takes an the hidden state the cell and a weight the final hidden cell&#160;</td><td class="memItemRight" valign="bottom"><b>rnn_mode</b></td></tr>
<tr class="separator:ab1a14739188d2f98346f4b2fe102fcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb0697a8c7a31db09034b492c3926f6"><td class="memItemLeft" align="right" valign="top"><a id="addb0697a8c7a31db09034b492c3926f6"></a>
the implementation takes an the hidden state the cell and a weight the final hidden cell input_mode are passed directly through to CuDNN&#160;</td><td class="memItemRight" valign="bottom"><b>DOC</b></td></tr>
<tr class="separator:addb0697a8c7a31db09034b492c3926f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb5b511557f03896c001185e3672999"><td class="memItemLeft" align="right" valign="top"><a id="a4fb5b511557f03896c001185e3672999"></a>
R recurrent or input R&#160;</td><td class="memItemRight" valign="bottom"><b>all_params</b></td></tr>
<tr class="separator:a4fb5b511557f03896c001185e3672999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed098459630802109ed29afd323aec5b"><td class="memItemLeft" align="right" valign="top"><a id="aed098459630802109ed29afd323aec5b"></a>
the value to replace&#160;</td><td class="memItemRight" valign="bottom"><b>NaN</b></td></tr>
<tr class="separator:aed098459630802109ed29afd323aec5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873d61b7001d72065b6aa1e703c9cce5"><td class="memItemLeft" align="right" valign="top"><a id="a873d61b7001d72065b6aa1e703c9cce5"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>actualNewShape</b> = helper.GetRepeatedArgument&lt;int64_t&gt;(&quot;shape&quot;)</td></tr>
<tr class="separator:a873d61b7001d72065b6aa1e703c9cce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a806608620d39e6b1ecaf34a1b255b"><td class="memItemLeft" align="right" valign="top"><a id="a37a806608620d39e6b1ecaf34a1b255b"></a>
int64_t&#160;</td><td class="memItemRight" valign="bottom"><b>totalSize</b> = 1</td></tr>
<tr class="separator:a37a806608620d39e6b1ecaf34a1b255b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb85f525131e24b7d5b2eb229911f7f"><td class="memItemLeft" align="right" valign="top"><a id="a8eb85f525131e24b7d5b2eb229911f7f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>unknownIdx</b> = -1</td></tr>
<tr class="separator:a8eb85f525131e24b7d5b2eb229911f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc042919e612ec50e763098e9a6a10c4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><b>else</b></td></tr>
<tr class="separator:abc042919e612ec50e763098e9a6a10c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ff1dd7d50d2d4138f13b74a62f161f"><td class="memItemLeft" align="right" valign="top"><a id="a99ff1dd7d50d2d4138f13b74a62f161f"></a>
an extra argument shape must be specified It outputs the reshaped tensor as well as the original shape At most one dimension of the new shape can be In this&#160;</td><td class="memItemRight" valign="bottom"><b>case</b></td></tr>
<tr class="separator:a99ff1dd7d50d2d4138f13b74a62f161f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9fe9e9bbdae383308b3b1d80966b74"><td class="memItemLeft" align="right" valign="top"><a id="afd9fe9e9bbdae383308b3b1d80966b74"></a>
an extra argument shape must be specified It outputs the reshaped tensor as well as the original shape At most one dimension of the new shape can be In this the value is inferred from the size of the tensor and the remaining dimensions A dimension could also&#160;</td><td class="memItemRight" valign="bottom"><b>be</b></td></tr>
<tr class="separator:afd9fe9e9bbdae383308b3b1d80966b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3398bd4207d1a0cae41a0709ca8bf19a"><td class="memItemLeft" align="right" valign="top"><a id="a3398bd4207d1a0cae41a0709ca8bf19a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>segments</b></td></tr>
<tr class="separator:a3398bd4207d1a0cae41a0709ca8bf19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade68c67fc2c092431b76e601447c8a10"><td class="memItemLeft" align="right" valign="top"><a id="ade68c67fc2c092431b76e601447c8a10"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>embeddings</b></td></tr>
<tr class="separator:ade68c67fc2c092431b76e601447c8a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894bce6c1cc63d0c81412c6b226c5507"><td class="memItemLeft" align="right" valign="top"><a id="a894bce6c1cc63d0c81412c6b226c5507"></a>
default the scale to&#160;</td><td class="memItemRight" valign="bottom"><b>apply</b></td></tr>
<tr class="separator:a894bce6c1cc63d0c81412c6b226c5507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76dde945e8c293e42578695bb73fa128"><td class="memItemLeft" align="right" valign="top"><a id="a76dde945e8c293e42578695bb73fa128"></a>
affects the activation function itself This should go with the weight initialization in the paper See&#160;</td><td class="memItemRight" valign="bottom"><b>https</b></td></tr>
<tr class="separator:a76dde945e8c293e42578695bb73fa128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8b1bab2a5f35af628d126d4c9b42b3e"><td class="memItemLeft" align="right" valign="top"><a id="aa8b1bab2a5f35af628d126d4c9b42b3e"></a>
affects the activation function itself&#160;</td><td class="memItemRight" valign="bottom"><b>dY</b></td></tr>
<tr class="separator:aa8b1bab2a5f35af628d126d4c9b42b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e0ab7bd353bf53fdb04b239c3ec035"><td class="memItemLeft" align="right" valign="top"><a id="a64e0ab7bd353bf53fdb04b239c3ec035"></a>
Number of copies of padding to add around each range&#160;</td><td class="memItemRight" valign="bottom"><b>data_in</b></td></tr>
<tr class="separator:a64e0ab7bd353bf53fdb04b239c3ec035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a79f074ae71be18c7b8ea3cf43ce9b7"><td class="memItemLeft" align="right" valign="top"><a id="a9a79f074ae71be18c7b8ea3cf43ce9b7"></a>
Number of copies of padding to add around each range T&lt; N, D1..., Dn &gt; Input data&#160;</td><td class="memItemRight" valign="bottom"><b>start_padding</b></td></tr>
<tr class="separator:a9a79f074ae71be18c7b8ea3cf43ce9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26361d416bfb03f08ffdcd39b05a4450"><td class="memItemLeft" align="right" valign="top"><a id="a26361d416bfb03f08ffdcd39b05a4450"></a>
Number of copies of padding to add around each range T&lt; N, D1..., Dn &gt; Input data T&lt; D1..., Dn &gt; Padding data for range start&#160;</td><td class="memItemRight" valign="bottom"><b>data_out</b></td></tr>
<tr class="separator:a26361d416bfb03f08ffdcd39b05a4450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074c9a0e8cde128f1ec5dc8087e66917"><td class="memItemLeft" align="right" valign="top"><a id="a074c9a0e8cde128f1ec5dc8087e66917"></a>
Outer size of padding present around each range T&lt; N, D1..., Dn &gt; Padded input data&#160;</td><td class="memItemRight" valign="bottom"><b>padding_sum</b></td></tr>
<tr class="separator:a074c9a0e8cde128f1ec5dc8087e66917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955f20693c31916293168aa86432578f"><td class="memItemLeft" align="right" valign="top"><a id="a955f20693c31916293168aa86432578f"></a>
Outer size of padding present around each range T&lt; N, D1..., Dn &gt; Padded input data Sum of all start&#160;</td><td class="memItemRight" valign="bottom"><b>paddings</b></td></tr>
<tr class="separator:a955f20693c31916293168aa86432578f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c98c7350def0accacb05ea1e3989425"><td class="memItemLeft" align="right" valign="top"><a id="a8c98c7350def0accacb05ea1e3989425"></a>
only slicing in a single dimension is supported Slices are passed as vectors or as two keyword argument lists with starting and end indices for each dimension of the input data tensor If a negative value is passed for any of the start or end&#160;</td><td class="memItemRight" valign="bottom"><b>indices</b></td></tr>
<tr class="separator:a8c98c7350def0accacb05ea1e3989425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96894028253b5436881789e477c8a8d"><td class="memItemLeft" align="right" valign="top"><a id="af96894028253b5436881789e477c8a8d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>rather</b></td></tr>
<tr class="separator:af96894028253b5436881789e477c8a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f51cf0e7a7c3688d879508f69477aa"><td class="memItemLeft" align="right" valign="top"><a id="a26f51cf0e7a7c3688d879508f69477aa"></a>
it will be coerced into one For an arbitrary n dimensional tensor X in [a_0, a_1,..., a_{k-1}, a_k,..., a_{n-1}] and k is the axis&#160;</td><td class="memItemRight" valign="bottom"><b>provided</b></td></tr>
<tr class="separator:a26f51cf0e7a7c3688d879508f69477aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829682c62586b61a20fb61d27e6b30cc"><td class="memItemLeft" align="right" valign="top"><a id="a829682c62586b61a20fb61d27e6b30cc"></a>
it will be coerced into one For an arbitrary n dimensional tensor X in [a_0, a_1,..., a_{k-1}, a_k,..., a_{n-1}] and k is the axis then X will be coerced into a dimensional tensor with dimensions [a_0 *... *a_{k-1}, a_k *... *a_{n-1}] For the default case where this means the X tensor will be coerced into a tensor of&#160;</td><td class="memItemRight" valign="bottom"><b>dimensions</b> [a_0, a_1 *... *a_{n-1}]</td></tr>
<tr class="separator:a829682c62586b61a20fb61d27e6b30cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341e96535f826465053b5a6b94ec55ed"><td class="memItemLeft" align="right" valign="top"><a id="a341e96535f826465053b5a6b94ec55ed"></a>
it will be coerced into one For an arbitrary n dimensional tensor X in [a_0, a_1,..., a_{k-1}, a_k,..., a_{n-1}] and k is the axis then X will be coerced into a dimensional tensor with dimensions [a_0 *... *a_{k-1}, a_k *... *a_{n-1}] For the default case where this means the X tensor will be coerced into a tensor of where a_0 is often the batch size In this&#160;</td><td class="memItemRight" valign="bottom"><b>situation</b></td></tr>
<tr class="separator:a341e96535f826465053b5a6b94ec55ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34174f2652b1ceed8b21e82dc5401de4"><td class="memItemLeft" align="right" valign="top">it will be coerced into one For an arbitrary n dimensional tensor X in [a_0, a_1,..., a_{k-1}, a_k,..., a_{n-1}] and k is the axis then X will be coerced into a dimensional tensor with dimensions [a_0 *... *a_{k-1}, a_k *... *a_{n-1}] For the default case where this means the X tensor will be coerced into a tensor of where a_0 is often the batch size In this we must have&#160;</td><td class="memItemRight" valign="bottom"><b>a_0</b></td></tr>
<tr class="separator:a34174f2652b1ceed8b21e82dc5401de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604e082bcc8b73505ba61d78fb2e0e1e"><td class="memItemLeft" align="right" valign="top"><a id="a604e082bcc8b73505ba61d78fb2e0e1e"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>labels</b> = in[1]</td></tr>
<tr class="separator:a604e082bcc8b73505ba61d78fb2e0e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ec3d8b4f17b4e26fdfd0f339e64089"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><b>num_classes</b></td></tr>
<tr class="separator:a22ec3d8b4f17b4e26fdfd0f339e64089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa469f4d6a64b3c06be07c93816218588"><td class="memItemLeft" align="right" valign="top"><a id="aa469f4d6a64b3c06be07c93816218588"></a>
Unscaled log probabilities&#160;</td><td class="memItemRight" valign="bottom"><b>weight_tensor</b></td></tr>
<tr class="separator:aa469f4d6a64b3c06be07c93816218588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85b6fb0d3694c42d65ecb0cfafbe479"><td class="memItemLeft" align="right" valign="top"><a id="ad85b6fb0d3694c42d65ecb0cfafbe479"></a>
Unscaled log probabilities Optional blob to be used to weight the samples for the loss&#160;</td><td class="memItemRight" valign="bottom"><b>loss</b></td></tr>
<tr class="separator:ad85b6fb0d3694c42d65ecb0cfafbe479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1f4700a29ab07e83f2da42d5d78ec2"><td class="memItemLeft" align="right" valign="top"><a id="a1f1f4700a29ab07e83f2da42d5d78ec2"></a>
this op outputs a copy of the input tensor where values from the height and width dimensions are moved to the batch dimension After the zero&#160;</td><td class="memItemRight" valign="bottom"><b>padding</b></td></tr>
<tr class="separator:a1f1f4700a29ab07e83f2da42d5d78ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc109e6351665ebf886eff4bff7615ef"><td class="memItemLeft" align="right" valign="top"><a id="abc109e6351665ebf886eff4bff7615ef"></a>
followed by cropping This is the reverse transformation of SpaceToBatch More&#160;</td><td class="memItemRight" valign="bottom"><b>specifically</b></td></tr>
<tr class="separator:abc109e6351665ebf886eff4bff7615ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c0ceac2d49bca5216c9907ac507867"><td class="memItemLeft" align="right" valign="top"><a id="aa5c0ceac2d49bca5216c9907ac507867"></a>
value represented as indices vector and values tensor into a compacted tensor where the first dimension is determined by the first dimension of the input if it is given or the max index Missing values are filled with zeros The op supports duplicated indices and performs summation over corresponding values This behavior is useful for converting GradientSlices into dense representation After running this&#160;</td><td class="memItemRight" valign="bottom"><b>op</b></td></tr>
<tr class="separator:aa5c0ceac2d49bca5216c9907ac507867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de4b212a0e77899730111b72a268394"><td class="memItemLeft" align="right" valign="top"><a id="a8de4b212a0e77899730111b72a268394"></a>
Unscaled log probabilities Optional blob to be used to weight the samples for the loss With spatial weighting is by&#160;</td><td class="memItemRight" valign="bottom"><b>x</b></td></tr>
<tr class="separator:a8de4b212a0e77899730111b72a268394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea2db89e5ced97847aea14ff2699ae6"><td class="memItemLeft" align="right" valign="top"><a id="aaea2db89e5ced97847aea14ff2699ae6"></a>
A <a class="el" href="classcaffe2_1_1Blob.html">Blob</a> pointing to the newly created&#160;</td><td class="memItemRight" valign="bottom"><b>StatRegistry</b></td></tr>
<tr class="separator:aaea2db89e5ced97847aea14ff2699ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d30c53af125f5297c370ca526670c0"><td class="memItemLeft" align="right" valign="top"><a id="a12d30c53af125f5297c370ca526670c0"></a>
If export values from given <a class="el" href="classcaffe2_1_1StatRegistry.html">StatRegistry</a> export values from the global singleton <a class="el" href="classcaffe2_1_1StatRegistry.html">StatRegistry</a> int64 tensor with exported values default true Whether to atomically reset the counters&#160;</td><td class="memItemRight" valign="bottom"><b>afterwards</b></td></tr>
<tr class="separator:a12d30c53af125f5297c370ca526670c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0de79bd753711e5065b68a1a5c484e4"><td class="memItemLeft" align="right" valign="top"><a id="ab0de79bd753711e5065b68a1a5c484e4"></a>
returning a pointer to it The timer is stopped by calling TimerEnd DOC&#160;</td><td class="memItemRight" valign="bottom"><b>timer</b></td></tr>
<tr class="separator:ab0de79bd753711e5065b68a1a5c484e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55376edd3fd71ff9886aca6c84958384"><td class="memItemLeft" align="right" valign="top"><a id="a55376edd3fd71ff9886aca6c84958384"></a>
returning a pointer to it The timer is stopped by calling TimerEnd DOC Pointer to to be passed to&#160;</td><td class="memItemRight" valign="bottom"><b>TimerEnd</b></td></tr>
<tr class="separator:a55376edd3fd71ff9886aca6c84958384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fdfe6cb8c3f03bcfdf46bea8e63d5f"><td class="memItemLeft" align="right" valign="top"><a id="a83fdfe6cb8c3f03bcfdf46bea8e63d5f"></a>
stops the timer publishing a CAFFE_EVENT DOC&#160;</td><td class="memItemRight" valign="bottom"><b>nanos</b></td></tr>
<tr class="separator:a83fdfe6cb8c3f03bcfdf46bea8e63d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04d7ded24af143786e328cd13aab7c8"><td class="memItemLeft" align="right" valign="top"><a id="ab04d7ded24af143786e328cd13aab7c8"></a>
stops the timer publishing a CAFFE_EVENT DOC nanoseconds in&#160;</td><td class="memItemRight" valign="bottom"><b>int64</b></td></tr>
<tr class="separator:ab04d7ded24af143786e328cd13aab7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa978788e9d6c9e09eb3acd82761cb8"><td class="memItemLeft" align="right" valign="top"><a id="a0aa978788e9d6c9e09eb3acd82761cb8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>utilization</b></td></tr>
<tr class="separator:a0aa978788e9d6c9e09eb3acd82761cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062d7098f120443935eba6e90066ac86"><td class="memItemLeft" align="right" valign="top"><a id="a062d7098f120443935eba6e90066ac86"></a>
Delta in max CPU utilization&#160;</td><td class="memItemRight" valign="bottom"><b>observed</b></td></tr>
<tr class="separator:a062d7098f120443935eba6e90066ac86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c73ac9943897bcfeb42694f09bdffbd"><td class="memItemLeft" align="right" valign="top"><a id="a3c73ac9943897bcfeb42694f09bdffbd"></a>
default flag to indicate if the summarized statistics have to be written to a log file D&#160;</td><td class="memItemRight" valign="bottom"><b>max</b></td></tr>
<tr class="separator:a3c73ac9943897bcfeb42694f09bdffbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd265702e7a42e4caf263cf1764ddb1e"><td class="memItemLeft" align="right" valign="top"><a id="afd265702e7a42e4caf263cf1764ddb1e"></a>
default flag to indicate if the summarized statistics have to be written to a log file D mean and standard&#160;</td><td class="memItemRight" valign="bottom"><b>deviation</b></td></tr>
<tr class="separator:afd265702e7a42e4caf263cf1764ddb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cfbc8efd5c995523881c02ef435780"><td class="memItemLeft" align="right" valign="top"><a id="a95cfbc8efd5c995523881c02ef435780"></a>
constexpr char&#160;</td><td class="memItemRight" valign="bottom"><b>kSummaryzeOpExtension</b> [] = &quot;.summary&quot;</td></tr>
<tr class="separator:a95cfbc8efd5c995523881c02ef435780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b725d863847481a51222a0f828682a"><td class="memItemLeft" align="right" valign="top"><a id="a95b725d863847481a51222a0f828682a"></a>
auto&#160;</td><td class="memItemRight" valign="bottom"><b>tiles</b> = helper.GetSingleArgument&lt;int32_t&gt;(&quot;tiles&quot;, 1)</td></tr>
<tr class="separator:a95b725d863847481a51222a0f828682a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83c94a49114ef26a688f7b93630d8a9"><td class="memItemLeft" align="right" valign="top"><a id="aa83c94a49114ef26a688f7b93630d8a9"></a>
Number of replicas The input tensor optional Axis to replicate&#160;</td><td class="memItemRight" valign="bottom"><b>tiled_data</b></td></tr>
<tr class="separator:aa83c94a49114ef26a688f7b93630d8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417744630a98bb0d68f55d26cc0dc019"><td class="memItemLeft" align="right" valign="top"><a id="a417744630a98bb0d68f55d26cc0dc019"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>a_2</b></td></tr>
<tr class="separator:a417744630a98bb0d68f55d26cc0dc019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27dfcc5dcc47931e1f34d40af2268a4"><td class="memItemLeft" align="right" valign="top"><a id="ac27dfcc5dcc47931e1f34d40af2268a4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>a_n</b></td></tr>
<tr class="separator:ac27dfcc5dcc47931e1f34d40af2268a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8ddcda9f75a80dfa630faafc917c81"><td class="memItemLeft" align="right" valign="top"><a id="a6e8ddcda9f75a80dfa630faafc917c81"></a>
r and integer argument&#160;</td><td class="memItemRight" valign="bottom"><b>k</b></td></tr>
<tr class="separator:a6e8ddcda9f75a80dfa630faafc917c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2b750e65c5bc2bf187321b03037677"><td class="memItemLeft" align="right" valign="top"><a id="a6d2b750e65c5bc2bf187321b03037677"></a>
r and integer argument return two k which contains the values of the top k elements along the last dimension <a class="el" href="structcaffe2_1_1Index.html">Index</a> tensor of shape [a_1, a_2,..., a_n, k] which contains the indices of the top k this&#160;</td><td class="memItemRight" valign="bottom"><b>Values</b></td></tr>
<tr class="separator:a6d2b750e65c5bc2bf187321b03037677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8fcb29d5e9fa7ea899c169b44b5d9e"><td class="memItemLeft" align="right" valign="top"><a id="acc8fcb29d5e9fa7ea899c169b44b5d9e"></a>
vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>axes</b> = helper.GetRepeatedArgument&lt;int&gt;(&quot;axes&quot;)</td></tr>
<tr class="separator:acc8fcb29d5e9fa7ea899c169b44b5d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b77424afcbc65c3b1971194b6c5e84"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><b>valid_axes</b></td></tr>
<tr class="separator:a45b77424afcbc65c3b1971194b6c5e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08b3d1ffa31eb8bf73ec5a7d92a3475"><td class="memItemLeft" align="right" valign="top"><a id="aa08b3d1ffa31eb8bf73ec5a7d92a3475"></a>
A list of integers By reverse the otherwise permute the axes according to the values given&#160;</td><td class="memItemRight" valign="bottom"><b>transposed</b></td></tr>
<tr class="separator:aa08b3d1ffa31eb8bf73ec5a7d92a3475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3294f46f45a52ac75939d3e6239c9021"><td class="memItemLeft" align="right" valign="top"><a id="a3294f46f45a52ac75939d3e6239c9021"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>time</b></td></tr>
<tr class="separator:a3294f46f45a52ac75939d3e6239c9021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a9a81af86f2fc412c0a0260bac35f6"><td class="memItemLeft" align="right" valign="top"><a id="a64a9a81af86f2fc412c0a0260bac35f6"></a>
The time in&#160;</td><td class="memItemRight" valign="bottom"><b>nanoseconds</b></td></tr>
<tr class="separator:a64a9a81af86f2fc412c0a0260bac35f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade73067b9ad02d9b13ecacbc0ed4fbb"><td class="memItemLeft" align="right" valign="top"><a id="aade73067b9ad02d9b13ecacbc0ed4fbb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>if</b></td></tr>
<tr class="separator:aade73067b9ad02d9b13ecacbc0ed4fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ff253c52b3d44ad91706a0c24aeea4"><td class="memItemLeft" align="right" valign="top"><a id="a93ff253c52b3d44ad91706a0c24aeea4"></a>
bool saves contents to the root folder of the current&#160;</td><td class="memItemRight" valign="bottom"><b>workspace</b></td></tr>
<tr class="separator:a93ff253c52b3d44ad91706a0c24aeea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a3b3661ddd176f90ad9b9c5520e893"><td class="memItemLeft" align="right" valign="top"><a id="a65a3b3661ddd176f90ad9b9c5520e893"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>total</b> = 1</td></tr>
<tr class="separator:a65a3b3661ddd176f90ad9b9c5520e893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5095fc1c0ecda28ca55e4eea5ff37116"><td class="memItemLeft" align="right" valign="top"><a id="a5095fc1c0ecda28ca55e4eea5ff37116"></a>
A tensor of sharing its&#160;</td><td class="memItemRight" valign="bottom"><b>storage</b></td></tr>
<tr class="separator:a5095fc1c0ecda28ca55e4eea5ff37116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a684970edd0e97223b523a614393ed"><td class="memItemLeft" align="right" valign="top"><a id="a97a684970edd0e97223b523a614393ed"></a>
weight tensor pairs Input should be in the form&#160;</td><td class="memItemRight" valign="bottom"><b>X_0</b></td></tr>
<tr class="separator:a97a684970edd0e97223b523a614393ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c446b785a118216262c002ede1a0a4"><td class="memItemLeft" align="right" valign="top"><a id="af8c446b785a118216262c002ede1a0a4"></a>
weight tensor pairs Input should be in the form&#160;</td><td class="memItemRight" valign="bottom"><b>weight_0</b></td></tr>
<tr class="separator:af8c446b785a118216262c002ede1a0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcc0b1f14d9920273ebc94fb7610f43"><td class="memItemLeft" align="right" valign="top"><a id="a0bcc0b1f14d9920273ebc94fb7610f43"></a>
weight tensor pairs Input should be in the form&#160;</td><td class="memItemRight" valign="bottom"><b>X_1</b></td></tr>
<tr class="separator:a0bcc0b1f14d9920273ebc94fb7610f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e4d7fb6844992f3ff95a3dbccd1b8e"><td class="memItemLeft" align="right" valign="top"><a id="aa1e4d7fb6844992f3ff95a3dbccd1b8e"></a>
weight tensor pairs Input should be in the form&#160;</td><td class="memItemRight" valign="bottom"><b>weight_1</b></td></tr>
<tr class="separator:aa1e4d7fb6844992f3ff95a3dbccd1b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c21a1fa027620da6bc066dfabde121"><td class="memItemLeft" align="right" valign="top"><a id="a96c21a1fa027620da6bc066dfabde121"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>INT_MAX</b></td></tr>
<tr class="separator:a96c21a1fa027620da6bc066dfabde121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3f980520494eda17e8b5e9dc660c3c"><td class="memItemLeft" align="right" valign="top"><a id="a2d3f980520494eda17e8b5e9dc660c3c"></a>
<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>INDICES</b></td></tr>
<tr class="separator:a2d3f980520494eda17e8b5e9dc660c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ac630098d19dad90cfa1551aa1aa22"><td class="memItemLeft" align="right" valign="top"><a id="a63ac630098d19dad90cfa1551aa1aa22"></a>
<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> to be updated D list of indices on the first dimension of X_0 that need to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>Weight_1</b></td></tr>
<tr class="separator:a63ac630098d19dad90cfa1551aa1aa22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2749e9cbc1df89b52d0424767c485f"><td class="memItemLeft" align="right" valign="top"><a id="ace2749e9cbc1df89b52d0424767c485f"></a>
<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>SLICES</b></td></tr>
<tr class="separator:ace2749e9cbc1df89b52d0424767c485f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0cba0b7d70951edceded2d42db0d09"><td class="memItemLeft" align="right" valign="top"><a id="a6e0cba0b7d70951edceded2d42db0d09"></a>
<a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> to be updated Update&#160;</td><td class="memItemRight" valign="bottom"><b>slices</b></td></tr>
<tr class="separator:a6e0cba0b7d70951edceded2d42db0d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d06086ac8ff6ede90d0b42dad0812ce"><td class="memItemLeft" align="right" valign="top"><a id="a4d06086ac8ff6ede90d0b42dad0812ce"></a>
const char&#160;</td><td class="memItemRight" valign="bottom"><b>kPrintFileExtension</b> [] = &quot;.log&quot;</td></tr>
<tr class="separator:a4d06086ac8ff6ede90d0b42dad0812ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496eed23a8db93ec6c2fe45c5af8ce33"><td class="memItemLeft" align="right" valign="top"><a id="a496eed23a8db93ec6c2fe45c5af8ce33"></a>
an index is randomly sampled from the distribution given by the weights of the corresponding batch The output is a D&#160;</td><td class="memItemRight" valign="bottom"><b>sampling_weights</b></td></tr>
<tr class="separator:a496eed23a8db93ec6c2fe45c5af8ce33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61df92065656c8bf671cdc692e34942b"><td class="memItemLeft" align="right" valign="top"><a id="a61df92065656c8bf671cdc692e34942b"></a>
an index is randomly sampled from the distribution given by the weights of the corresponding batch The output is a D A D <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; float &gt; of&#160;</td><td class="memItemRight" valign="bottom"><b>sampling_values</b></td></tr>
<tr class="separator:a61df92065656c8bf671cdc692e34942b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1b3412c235ff2351300e03a78bea2f"><td class="memItemLeft" align="right" valign="top"><a id="aae1b3412c235ff2351300e03a78bea2f"></a>
an index is randomly sampled from the distribution given by the weights of the corresponding batch The output is a D A D <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; float &gt; of An optional D <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; float &gt; of&#160;</td><td class="memItemRight" valign="bottom"><b>sampled_indexes</b></td></tr>
<tr class="separator:aae1b3412c235ff2351300e03a78bea2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140300568fdaa9c9051605cf9b123fe2"><td class="memItemLeft" align="right" valign="top"><a id="a140300568fdaa9c9051605cf9b123fe2"></a>
an index is randomly sampled from the distribution given by the weights of the corresponding batch The output is a D A D <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; float &gt; of An optional D <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a>&lt; float &gt; of The output tensor contains&#160;</td><td class="memItemRight" valign="bottom"><b>sampled_values</b></td></tr>
<tr class="separator:a140300568fdaa9c9051605cf9b123fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7413dcb9a1fabf1a7cec4c9404bd7396"><td class="memItemLeft" align="right" valign="top"><a id="a7413dcb9a1fabf1a7cec4c9404bd7396"></a>
Timeout in&#160;</td><td class="memItemRight" valign="bottom"><b>secs</b></td></tr>
<tr class="separator:a7413dcb9a1fabf1a7cec4c9404bd7396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c354f476240f392ab010204294ec95"><td class="memItemLeft" align="right" valign="top"><a id="a73c354f476240f392ab010204294ec95"></a>
Timeout in&#160;</td><td class="memItemRight" valign="bottom"><b>queue</b></td></tr>
<tr class="separator:a73c354f476240f392ab010204294ec95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edb91da059b55443b1e1da62ede5d8e"><td class="memItemLeft" align="right" valign="top"><a id="a7edb91da059b55443b1e1da62ede5d8e"></a>
The shared pointer for the&#160;</td><td class="memItemRight" valign="bottom"><b>BlobsQueue</b></td></tr>
<tr class="separator:a7edb91da059b55443b1e1da62ede5d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d0e7956b663833f254e29316fd8937"><td class="memItemLeft" align="right" valign="top"><a id="a95d0e7956b663833f254e29316fd8937"></a>
the output status will be set to true which can be used as exit criteria for execution step The input is the queue and the last output is the status The rest are data blobs DOC The shared pointer for the <a class="el" href="classcaffe2_1_1BlobsQueue.html">BlobsQueue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>status</b></td></tr>
<tr class="separator:a95d0e7956b663833f254e29316fd8937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f8a500a75314ea467a2106a53c34cb"><td class="memItemLeft" align="right" valign="top"><a id="a29f8a500a75314ea467a2106a53c34cb"></a>
the output status will be set to true which can be used as exit criteria for execution step The input is the queue and the last output is the status The rest are data blobs DOC The shared pointer for the <a class="el" href="classcaffe2_1_1BlobsQueue.html">BlobsQueue</a> Is set to depending on the success of&#160;</td><td class="memItemRight" valign="bottom"><b>dequeue</b></td></tr>
<tr class="separator:a29f8a500a75314ea467a2106a53c34cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a3f06084ea8051300fb0e43a837c58"><td class="memItemLeft" align="right" valign="top"><a id="ab7a3f06084ea8051300fb0e43a837c58"></a>
INT_MAX Weights for sampling from multiple&#160;</td><td class="memItemRight" valign="bottom"><b>queues</b></td></tr>
<tr class="separator:ab7a3f06084ea8051300fb0e43a837c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa762c75d4e46531704cfa03cdaf723ac"><td class="memItemLeft" align="right" valign="top"><a id="aa762c75d4e46531704cfa03cdaf723ac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>param</b></td></tr>
<tr class="separator:aa762c75d4e46531704cfa03cdaf723ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b2361594237f0e46c48218e03999df"><td class="memItemLeft" align="right" valign="top"><a id="a22b2361594237f0e46c48218e03999df"></a>
Parameters to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>grad</b></td></tr>
<tr class="separator:a22b2361594237f0e46c48218e03999df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76351eacbd2e27f4c16e4f8c8cc0ad27"><td class="memItemLeft" align="right" valign="top"><a id="a76351eacbd2e27f4c16e4f8c8cc0ad27"></a>
Parameters to be updated Gradient computed&#160;</td><td class="memItemRight" valign="bottom"><b>output_param</b></td></tr>
<tr class="separator:a76351eacbd2e27f4c16e4f8c8cc0ad27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a081ca1b630006767cc0ec781ca78a27d"><td class="memItemLeft" align="right" valign="top"><a id="a081ca1b630006767cc0ec781ca78a27d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>moment</b></td></tr>
<tr class="separator:a081ca1b630006767cc0ec781ca78a27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273ccf387f0345956ca0c2d5f89fe673"><td class="memItemLeft" align="right" valign="top"><a id="a273ccf387f0345956ca0c2d5f89fe673"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>lr</b></td></tr>
<tr class="separator:a273ccf387f0345956ca0c2d5f89fe673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaacd1999594e9f6e2699c09387f4709"><td class="memItemLeft" align="right" valign="top"><a id="afaacd1999594e9f6e2699c09387f4709"></a>
runs the dense AdaGrad update and Parameters to be updated Sparse indices learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>output_moment_1</b></td></tr>
<tr class="separator:afaacd1999594e9f6e2699c09387f4709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251233b68c7c802ac10e823fd131a1d9"><td class="memItemLeft" align="right" valign="top"><a id="a251233b68c7c802ac10e823fd131a1d9"></a>
runs a modified sparse Adagrad update and where moment is a tensor with length equal to the number of rows in and the new moment is calculated by adding the average squared sum of gradients across each row Note that indices must also be a tensor indexing into the rows of param DOC Moment history Gradient computed Updated parameters&#160;</td><td class="memItemRight" valign="bottom"><b>Default</b></td></tr>
<tr class="separator:a251233b68c7c802ac10e823fd131a1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03dd84a062642ec91cb5e9ead4992387"><td class="memItemLeft" align="right" valign="top"><a id="a03dd84a062642ec91cb5e9ead4992387"></a>
Parameters to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>moment_2</b></td></tr>
<tr class="separator:a03dd84a062642ec91cb5e9ead4992387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cfde5e010336b6dfa0c945b58fd9417"><td class="memItemLeft" align="right" valign="top"><a id="a9cfde5e010336b6dfa0c945b58fd9417"></a>
Parameters to be updated Second moment history learning rate Updated parameters&#160;</td><td class="memItemRight" valign="bottom"><b>output_moment_2</b></td></tr>
<tr class="separator:a9cfde5e010336b6dfa0c945b58fd9417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e4129a5ffe6e161591d258fbcac7f7"><td class="memItemLeft" align="right" valign="top"><a id="ac2e4129a5ffe6e161591d258fbcac7f7"></a>
Parameters to be updated Second moment history Gradient computed&#160;</td><td class="memItemRight" valign="bottom"><b>iter</b></td></tr>
<tr class="separator:ac2e4129a5ffe6e161591d258fbcac7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32eefe979dd1aa0a3bcffe5bae25b2e3"><td class="memItemLeft" align="right" valign="top"><a id="a32eefe979dd1aa0a3bcffe5bae25b2e3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>mutex</b></td></tr>
<tr class="separator:a32eefe979dd1aa0a3bcffe5bae25b2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5c1997a586b412366282e3d5c36ed8"><td class="memItemLeft" align="right" valign="top"><a id="aff5c1997a586b412366282e3d5c36ed8"></a>
given&#160;</td><td class="memItemRight" valign="bottom"><b>nesterov</b></td></tr>
<tr class="separator:aff5c1997a586b412366282e3d5c36ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d580ff9f43830a1a4910e1374df359e"><td class="memItemLeft" align="right" valign="top"><a id="a3d580ff9f43830a1a4910e1374df359e"></a>
given&#160;</td><td class="memItemRight" valign="bottom"><b>computes</b></td></tr>
<tr class="separator:a3d580ff9f43830a1a4910e1374df359e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d84a24ebe7bd6eb94a08f04bc6f5d5"><td class="memItemLeft" align="right" valign="top"><a id="a83d84a24ebe7bd6eb94a08f04bc6f5d5"></a>
given&#160;</td><td class="memItemRight" valign="bottom"><b>adjusted_gradient</b></td></tr>
<tr class="separator:a83d84a24ebe7bd6eb94a08f04bc6f5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983f6c0370710aa3fee309be4042f2de"><td class="memItemLeft" align="right" valign="top"><a id="a983f6c0370710aa3fee309be4042f2de"></a>
given param&#160;</td><td class="memItemRight" valign="bottom"><b>momentum</b></td></tr>
<tr class="separator:a983f6c0370710aa3fee309be4042f2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f18bb49a8ab18db4eb71615e96ce71"><td class="memItemLeft" align="right" valign="top"><a id="ad1f18bb49a8ab18db4eb71615e96ce71"></a>
given param parameter Note the difference to&#160;</td><td class="memItemRight" valign="bottom"><b>MomentumSGD</b></td></tr>
<tr class="separator:ad1f18bb49a8ab18db4eb71615e96ce71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f6a72d88af45a62ebade1938f893bc"><td class="memItemLeft" align="right" valign="top"><a id="a13f6a72d88af45a62ebade1938f893bc"></a>
GradientSlice with gradients for updated indices Learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>output_grad</b></td></tr>
<tr class="separator:a13f6a72d88af45a62ebade1938f893bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e753c4409d91d8b8b316a4a3740105"><td class="memItemLeft" align="right" valign="top"><a id="aa9e753c4409d91d8b8b316a4a3740105"></a>
GradientSlice with gradients for updated indices Learning rate Adjusted gradient Updated parameter boolean Whether to use Nesterov Accelerated&#160;</td><td class="memItemRight" valign="bottom"><b>Gradient</b></td></tr>
<tr class="separator:aa9e753c4409d91d8b8b316a4a3740105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7122aa4ca0f9404d6371137d86062608"><td class="memItemLeft" align="right" valign="top"><a id="a7122aa4ca0f9404d6371137d86062608"></a>
Parameters to be updated Learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>curv_win</b></td></tr>
<tr class="separator:a7122aa4ca0f9404d6371137d86062608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a9855e8d5726f19a8cb00c750a2785"><td class="memItemLeft" align="right" valign="top"><a id="a07a9855e8d5726f19a8cb00c750a2785"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges&#160;</td><td class="memItemRight" valign="bottom"><b>g2_avg</b></td></tr>
<tr class="separator:a07a9855e8d5726f19a8cb00c750a2785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e124b5cc6833c47766b8591badedcac"><td class="memItemLeft" align="right" valign="top"><a id="a4e124b5cc6833c47766b8591badedcac"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed Parameters to be updated&#160;</td><td class="memItemRight" valign="bottom"><b>output_lr</b></td></tr>
<tr class="separator:a4e124b5cc6833c47766b8591badedcac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad634dc96d52b1398e9a9962f54f90999"><td class="memItemLeft" align="right" valign="top"><a id="ad634dc96d52b1398e9a9962f54f90999"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed Parameters to be updated Output learning rate&#160;</td><td class="memItemRight" valign="bottom"><b>output_curv_win</b></td></tr>
<tr class="separator:ad634dc96d52b1398e9a9962f54f90999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e9a5a40ec5af5f25ebed9ccf8cdab6"><td class="memItemLeft" align="right" valign="top"><a id="a26e9a5a40ec5af5f25ebed9ccf8cdab6"></a>
Parameters to be updated Learning rate Memory for latest curvature ranges Moving average of squared gradient Gradient computed Parameters to be updated Output learning rate Output memory for latest curvature ranges&#160;</td><td class="memItemRight" valign="bottom"><b>output_g2_avg</b></td></tr>
<tr class="separator:a26e9a5a40ec5af5f25ebed9ccf8cdab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52ad980b4534788ecf0b74ccb620cd9"><td class="memItemLeft" align="right" valign="top"><a id="ad52ad980b4534788ecf0b74ccb620cd9"></a>
INT_MAX&#160;</td><td class="memItemRight" valign="bottom"><b>compressed</b></td></tr>
<tr class="separator:ad52ad980b4534788ecf0b74ccb620cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6628a6811afecb701315bbe9f4f69a0"><td class="memItemLeft" align="right" valign="top"><a id="ad6628a6811afecb701315bbe9f4f69a0"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>kDefaultMinWorkSize</b> = 80</td></tr>
<tr class="separator:ad6628a6811afecb701315bbe9f4f69a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fda0a33e913bd4c1b4b8eba8ca6d0c8"><td class="memItemLeft" align="right" valign="top"><a id="a2fda0a33e913bd4c1b4b8eba8ca6d0c8"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>kCacheLineSize</b> = 64</td></tr>
<tr class="separator:a2fda0a33e913bd4c1b4b8eba8ca6d0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d07a4973050cd3d4b5cc90e0b1c422b"><td class="memItemLeft" align="right" valign="top"><a id="a4d07a4973050cd3d4b5cc90e0b1c422b"></a>
constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>kGEMMLOWPCacheLineSize</b> = 64</td></tr>
<tr class="separator:a4d07a4973050cd3d4b5cc90e0b1c422b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01c330ff817b47ce5d3f2af7860c9ca"><td class="memItemLeft" align="right" valign="top"><a id="ac01c330ff817b47ce5d3f2af7860c9ca"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>kMaxBusyWaitNOPs</b> = 32 * 1000 * 1000</td></tr>
<tr class="separator:ac01c330ff817b47ce5d3f2af7860c9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77e45da6e74449c1c3748a79d3b9d05"><td class="memItemLeft" align="right" valign="top"><a id="af77e45da6e74449c1c3748a79d3b9d05"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>crop</b> = helper.GetSingleArgument&lt;int&gt;(&quot;crop&quot;, -1)</td></tr>
<tr class="separator:af77e45da6e74449c1c3748a79d3b9d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba43031f8809a11231620949a0762fc9"><td class="memItemLeft" align="right" valign="top"><a id="aba43031f8809a11231620949a0762fc9"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>length</b> = helper.GetSingleArgument&lt;int&gt;(&quot;length&quot;, -1)</td></tr>
<tr class="separator:aba43031f8809a11231620949a0762fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c33bed605aab2c070e03d280174c5e"><td class="memItemLeft" align="right" valign="top"><a id="ad5c33bed605aab2c070e03d280174c5e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>multiple_label</b> = helper.GetSingleArgument&lt;int&gt;(&quot;multiple_label&quot;, 0)</td></tr>
<tr class="separator:ad5c33bed605aab2c070e03d280174c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Copyright (c) 2016-present, Facebook, Inc. </p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. A global dictionary that holds information about what Caffe2 modules have been loaded in the current runtime, and also utility functions to load modules.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Simple registry implementation in Caffe2 that uses static variables to register object creators during program initialization time.</p>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Copyright 2016 Facebook </p><dl class="section author"><dt>Author</dt><dd>Tudor Bosman (<a href="#" onclick="location.href='mai'+'lto:'+'tud'+'or'+'b@f'+'b.'+'com'; return false;">tudor<span style="display: none;">.nosp@m.</span>b@fb<span style="display: none;">.nosp@m.</span>.com</a>)</dd></dl>
<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><pre class="fragment">http://www.apache.org/licenses/LICENSE-2.0
</pre><p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>Copyright (c) 2016, NVIDIA CORPORATION, All rights reserved</p>
<p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p>
<ol type="1">
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li>
<li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li>
</ol>
<p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a3c84075c5d69ce9499450fbbb3f72965"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c84075c5d69ce9499450fbbb3f72965">&#9670;&nbsp;</a></span>UnaryElementwiseOp</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputTypes , class Context , class Functor , class OutputType  = SameTypeAsInput&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecaffe2.html#a3c84075c5d69ce9499450fbbb3f72965">caffe2::UnaryElementwiseOp</a> = typedef <a class="el" href="classcaffe2_1_1UnaryElementwiseWithArgsOp.html">UnaryElementwiseWithArgsOp</a>&lt; InputTypes, Context, <a class="el" href="structcaffe2_1_1WithDefaultConstructor.html">WithDefaultConstructor</a>&lt;Functor&gt;, OutputType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>UnaryElementwiseOp is a wrapper around <a class="el" href="classcaffe2_1_1UnaryElementwiseWithArgsOp.html">UnaryElementwiseWithArgsOp</a>, with the difference that it takes a functor with default constructor, e.g. </p>
<p>that does not need to take into consideration any arguments during operator creation. </p>

<p class="definition">Definition at line <a class="el" href="elementwise__op_8h_source.html#l00108">108</a> of file <a class="el" href="elementwise__op_8h_source.html">elementwise_op.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af6850a4a5f4298a5c825238cfb0de688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6850a4a5f4298a5c825238cfb0de688">&#9670;&nbsp;</a></span>CaffeCudaGetDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int caffe2::CaffeCudaGetDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current GPU id. </p>
<p>This is a simple wrapper around cudaGetDevice(). </p>

<p class="definition">Definition at line <a class="el" href="common__gpu_8cc_source.html#l00124">124</a> of file <a class="el" href="common__gpu_8cc_source.html">common_gpu.cc</a>.</p>

</div>
</div>
<a id="aff145698c872153a4e117f0e2101f09a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff145698c872153a4e117f0e2101f09a">&#9670;&nbsp;</a></span>CaffeCudaSetDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void caffe2::CaffeCudaSetDevice </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current GPU id. </p>
<p>This is a simple wrapper around cudaGetDevice(). </p>

<p class="definition">Definition at line <a class="el" href="common__gpu_8cc_source.html#l00137">137</a> of file <a class="el" href="common__gpu_8cc_source.html">common_gpu.cc</a>.</p>

</div>
</div>
<a id="aa9463003c6ef9000d089ffeaf9296c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9463003c6ef9000d089ffeaf9296c05">&#9670;&nbsp;</a></span>CreateNet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classcaffe2_1_1NetBase.html">NetBase</a> &gt; caffe2::CreateNet </td>
          <td>(</td>
          <td class="paramtype">const NetDef &amp;&#160;</td>
          <td class="paramname"><em>net_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *&#160;</td>
          <td class="paramname"><em>ws</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a network, accessing / creating blobs in the given workspace. </p>
<p>Note that this is different from <a class="el" href="classcaffe2_1_1Workspace.html#ac8c465ceb6cecbd5a2311f3d5bf4c35e" title="Creates a network with the given NetDef, and returns the pointer to the network. ">Workspace::CreateNet</a>. The latter adds the created net object to the workspace's net map, while this function returns a standalone net object. </p>

<p class="definition">Definition at line <a class="el" href="net_8cc_source.html#l00117">117</a> of file <a class="el" href="net_8cc_source.html">net.cc</a>.</p>

</div>
</div>
<a id="af626e8bd4defd97004472e4618071467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af626e8bd4defd97004472e4618071467">&#9670;&nbsp;</a></span>createRNNExecutor&lt; CPUContext &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classcaffe2_1_1RecurrentNetworkExecutorBase.html">RecurrentNetworkExecutorBase</a>&gt; caffe2::createRNNExecutor&lt; <a class="el" href="classcaffe2_1_1CPUContext.html">CPUContext</a> &gt; </td>
          <td>(</td>
          <td class="paramtype">const NetDef &amp;&#160;</td>
          <td class="paramname"><em>step_net_def</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; string, string &gt; &amp;&#160;</td>
          <td class="paramname"><em>recurrent_input_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>timestep_blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcaffe2_1_1ArgumentHelper.html">ArgumentHelper</a>&#160;</td>
          <td class="paramname"><em>rnn_args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of RecurrentNetworkExecutor that uses thread pool for multithreaded execution of RNNs. </p>
<p>Used with CPU. </p>

<p class="definition">Definition at line <a class="el" href="recurrent__network__executor_8cc_source.html#l00029">29</a> of file <a class="el" href="recurrent__network__executor_8cc_source.html">recurrent_network_executor.cc</a>.</p>

</div>
</div>
<a id="a5bab26d8f00817d54cb0d975ea633123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bab26d8f00817d54cb0d975ea633123">&#9670;&nbsp;</a></span>createSharedBuffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Context &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void caffe2::createSharedBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcaffe2_1_1Workspace.html">Workspace</a> *&#160;</td>
          <td class="paramname"><em>ws</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a mutex and shared buffer in the workspace. </p>
<p>Not thread-safe, must be called from the constructor. </p>

</div>
</div>
<a id="a2015a66b1fe9fccf95985a1b9de6d31c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2015a66b1fe9fccf95985a1b9de6d31c">&#9670;&nbsp;</a></span>CurrentModules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const CaffeMap&lt; string, const <a class="el" href="classcaffe2_1_1ModuleSchema.html">ModuleSchema</a> * &gt; &amp; caffe2::CurrentModules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current Modules present in the Caffe2 runtime. </p>
<p>Returns: map: a map of modules and (optionally) their description. The key is the module name, and the value is the description for that module. The module name is recommended to be the part that constitutes the trunk of the dynamic library: for example, a module called libcaffe2_db_rocksdb.so should have the name "caffe2_db_rocksdb". The reason we do not use "lib" is because it's somewhat redundant, and the reason we do not include ".so" is for cross-platform compatibility on platforms like mac os. </p>

<p class="definition">Definition at line <a class="el" href="module_8cc_source.html#l00043">43</a> of file <a class="el" href="module_8cc_source.html">module.cc</a>.</p>

</div>
</div>
<a id="a5df473adce0513ec1ed647ed7673fab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df473adce0513ec1ed647ed7673fab5">&#9670;&nbsp;</a></span>EmbeddingLookup()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType , typename InType , typename OutType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void caffe2::EmbeddingLookup </td>
          <td>(</td>
          <td class="paramtype">const TIndex&#160;</td>
          <td class="paramname"><em>block_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex&#160;</td>
          <td class="paramname"><em>output_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex&#160;</td>
          <td class="paramname"><em>index_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TIndex&#160;</td>
          <td class="paramname"><em>data_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InType *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexType *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>scale_bias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>normalize_by_lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutType *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Embedding lookup with reduction. </p>
<p><code>input</code> of size data_size * block_size <code>indices</code> of size index_size <code>lengths</code> of size output_size <code>weights</code> nullptr or array of size index_size <code>out</code> of size output_size * block_size sum(lengths[i]) == index_size</p>
<p>Behavior is roughly equivalent to pseudocode:</p>
<p>pos = 0 for (i = 0..index_size-1) for (k = 0..block_size-1) out[i*block_size + k] = 0 for (j = 0..lengths[i]-1) for (k = 0..block_size-1) out[i*block_size + k] += input[indices[pos]*block_size + k] * (weights ? weights[pos] : 1.0) pos += 1 if (normalize_weights &amp;&amp; lengths[i] &gt; 0) for (k = 0..block_size-1) out[i*block_size + k] /= lengths[i] </p>

</div>
</div>
<a id="ad37066071313fa865f8b2d22b900b3a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37066071313fa865f8b2d22b900b3a3">&#9670;&nbsp;</a></span>GetCudaMemoryPoolType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CudaMemoryPoolType caffe2::GetCudaMemoryPoolType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the current memory pool type used by Caffe2. </p>
<p>The memory pool is set up during <a class="el" href="namespacecaffe2.html" title="Copyright (c) 2016-present, Facebook, Inc. ">caffe2</a>'s global initialization time. </p>

</div>
</div>
<a id="a446da244aca2a8c6808963912cd5cdfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446da244aca2a8c6808963912cd5cdfc">&#9670;&nbsp;</a></span>GetCudaPeerAccessPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool caffe2::GetCudaPeerAccessPattern </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; bool &gt; &gt; *&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a peer access pattern by returning a matrix (in the format of a nested vector) of boolean values specifying whether peer access is possible. </p>
<p>This function returns false if anything wrong happens during the query of the GPU access pattern. </p>

<p class="definition">Definition at line <a class="el" href="common__gpu_8cc_source.html#l00233">233</a> of file <a class="el" href="common__gpu_8cc_source.html">common_gpu.cc</a>.</p>

</div>
</div>
<a id="ad461b286b4d2322c82a6f43fa00c8034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad461b286b4d2322c82a6f43fa00c8034">&#9670;&nbsp;</a></span>GetDeviceProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const cudaDeviceProp &amp; caffe2::GetDeviceProperty </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the device property for the given device. </p>
<p>This function is thread safe. </p>

<p class="definition">Definition at line <a class="el" href="common__gpu_8cc_source.html#l00181">181</a> of file <a class="el" href="common__gpu_8cc_source.html">common_gpu.cc</a>.</p>

</div>
</div>
<a id="af70b04a01a1779ddd61f9ef1e0a141b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70b04a01a1779ddd61f9ef1e0a141b7">&#9670;&nbsp;</a></span>GlobalInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool caffe2::GlobalInit </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pargc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the global environment of <a class="el" href="namespacecaffe2.html" title="Copyright (c) 2016-present, Facebook, Inc. ">caffe2</a>. </p>
<p>Caffe2 uses a registration pattern for initialization functions. Custom initialization functions should take the signature bool (<em>func)(int</em>, char***) where the pointers to argc and argv are passed in. Caffe2 then runs the initialization in three phases: (1) Functions registered with REGISTER_CAFFE2_EARLY_INIT_FUNCTION. Note that since it is possible the logger is not initialized yet, any logging in such early init functions may not be printed correctly. (2) Parses Caffe-specific commandline flags, and initializes caffe logging. (3) Functions registered with REGISTER_CAFFE2_INIT_FUNCTION. If there is something wrong at each stage, the function returns false. If the global initialization has already been run, the function returns false as well. </p>

<p class="definition">Definition at line <a class="el" href="init_8cc_source.html#l00034">34</a> of file <a class="el" href="init_8cc_source.html">init.cc</a>.</p>

</div>
</div>
<a id="aca313bd69abda6cc82792348e1d64cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca313bd69abda6cc82792348e1d64cc1">&#9670;&nbsp;</a></span>GlobalMPIComm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPI_Comm caffe2::GlobalMPIComm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the global MPI communicator used by Caffe2. </p>
<p>In default, this is MPI_COMM_WORLD unless you call <a class="el" href="namespacecaffe2.html#a1eaa1a07583fa2d94c3e66a7496f4790" title="Sets the global MPI communicator. ">SetGlobalMPIComm()</a>. </p>

<p class="definition">Definition at line <a class="el" href="mpi__common_8cc_source.html#l00036">36</a> of file <a class="el" href="mpi__common_8cc_source.html">mpi_common.cc</a>.</p>

</div>
</div>
<a id="a48638afbef9a25309bf7ef40a6e97919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48638afbef9a25309bf7ef40a6e97919">&#9670;&nbsp;</a></span>HasCudaGPU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool caffe2::HasCudaGPU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the current running session has a cuda gpu present. </p>
<p>Note that this is different from having <a class="el" href="namespacecaffe2.html" title="Copyright (c) 2016-present, Facebook, Inc. ">caffe2</a> built with cuda. Building Caffe2 with cuda only guarantees that this function exists. If there are no cuda gpus present in the machine, or there are hardware configuration problems like an insufficient driver, this function will still return false, meaning that there is no usable GPU present.</p>
<p>In the open source build, it is possible that Caffe2's GPU code is dynamically loaded, and as a result a library could be only linked to the CPU code, but want to test if cuda is later available or not. In this case, one should use HasCudaRuntime() from common.h. </p>

<p class="definition">Definition at line <a class="el" href="common__gpu_8h_source.html#l00115">115</a> of file <a class="el" href="common__gpu_8h_source.html">common_gpu.h</a>.</p>

</div>
</div>
<a id="ae721966f8a4a41ea13ac717698e09672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae721966f8a4a41ea13ac717698e09672">&#9670;&nbsp;</a></span>IdenticalTypeAndShape()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">caffe2::IdenticalTypeAndShape </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= alpha * (exp(x) - 1.) for x &lt;</div><div class="line">0`, `f(x) = x for x &gt;= 0`.</div></div><!-- fragment -->
</div>
</div>
<a id="ad9f3bdc17d263b9070079af7c9248b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f3bdc17d263b9070079af7c9248b97">&#9670;&nbsp;</a></span>LoadModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void caffe2::LoadModule </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a module. </p>
<p>Inputs: name: a module name or a path name. It is recommended that you use the name of the module, and leave the full path option to only experimental modules. filename: (optional) a filename that serves as a hint to load the module. </p>

<p class="definition">Definition at line <a class="el" href="module_8cc_source.html#l00068">68</a> of file <a class="el" href="module_8cc_source.html">module.cc</a>.</p>

</div>
</div>
<a id="a12ebf399716fbf0ba249317657150790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ebf399716fbf0ba249317657150790">&#9670;&nbsp;</a></span>MakeGuard()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcaffe2_1_1detail_1_1ScopeGuardImpl.html">detail::ScopeGuardImplDecay</a>&lt;F&gt; caffe2::MakeGuard </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ScopeGuard is a general implementation of the "Initialization is
Resource Acquisition" idiom. </p>
<p>Basically, it guarantees that a function is executed upon leaving the currrent scope unless otherwise told.</p>
<p>The <a class="el" href="namespacecaffe2.html#a12ebf399716fbf0ba249317657150790" title="ScopeGuard is a general implementation of the &quot;Initialization is Resource Acquisition&quot; idiom...">MakeGuard()</a> function is used to create a new ScopeGuard object. It can be instantiated with a lambda function, a std::function&lt;void()&gt;, a functor, or a void(*)() function pointer.</p>
<p>Usage example: Add a friend to memory iff it is also added to the db.</p>
<p>void User::addFriend(User&amp; newFriend) { // add the friend to memory friends_.push_back(&amp;newFriend);</p>
<p>// If the db insertion that follows fails, we should // remove it from memory. auto guard = MakeGuard([&amp;] { friends_.pop_back(); });</p>
<p>// this will throw an exception upon error, which // makes the ScopeGuard execute UserCont::pop_back() // once the Guard's destructor is called. db_-&gt;addFriend(GetName(), newFriend.GetName());</p>
<p>// an exception was not thrown, so don't execute // the Guard. guard.dismiss(); }</p>
<p>Examine ScopeGuardTest.cpp for some more sample usage.</p>
<p>Stolen from: Andrei's and Petru Marginean's CUJ article: <a href="http://drdobbs.com/184403758">http://drdobbs.com/184403758</a> and the loki library: <a href="http://loki-lib.sourceforge.net/index.php?n=Idioms.ScopeGuardPointer">http://loki-lib.sourceforge.net/index.php?n=Idioms.ScopeGuardPointer</a> and triendl.kj article: <a href="http://www.codeproject.com/KB/cpp/scope_guard.aspx">http://www.codeproject.com/KB/cpp/scope_guard.aspx</a> </p>

<p class="definition">Definition at line <a class="el" href="scope__guard_8h_source.html#l00169">169</a> of file <a class="el" href="scope__guard_8h_source.html">scope_guard.h</a>.</p>

</div>
</div>
<a id="ae0b7e581ccd292b6b16296966cfbd7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b7e581ccd292b6b16296966cfbd7ff">&#9670;&nbsp;</a></span>MatchStrings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool caffe2::MatchStrings </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This allows for the use of * and | to match operator types, engines, or any other property that is represented by strings. </p>
<p>For example, if we wanted to match an operator to Conv or FC, we can give: "Conv|FC" as the type() of that op. </p>

<p class="definition">Definition at line <a class="el" href="graph_8cc_source.html#l00230">230</a> of file <a class="el" href="graph_8cc_source.html">graph.cc</a>.</p>

</div>
</div>
<a id="a4dc2404153d4045abf87562f016a7fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc2404153d4045abf87562f016a7fa4">&#9670;&nbsp;</a></span>MPISetupPeers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void caffe2::MPISetupPeers </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>replicas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>job_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function used to perform peer setup so one does not need to use mpirun / mpiexec to run the binary. </p>
<p>Note that if you use mpirun or mpiexec to set up the common world, do not use this function - MPI_Init would have already set that up.</p>
<p>This also assumes that you have a common path (like NFS) that multiple instances can read from.</p>
<p>Inputs: replicas (int): the number of replicas that mpi will run with. role (string): the role of this process, "server" or "client". job_path (string): a file name that the server will write its port into and the clients will read the server's port from. </p>

<p class="definition">Definition at line <a class="el" href="mpi__common_8cc_source.html#l00110">110</a> of file <a class="el" href="mpi__common_8cc_source.html">mpi_common.cc</a>.</p>

</div>
</div>
<a id="a658a8d4d5b33a86502f0fbc5d2b82541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658a8d4d5b33a86502f0fbc5d2b82541">&#9670;&nbsp;</a></span>ParseCaffeCommandLineFlags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool caffe2::ParseCaffeCommandLineFlags </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>pargc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char ***&#160;</td>
          <td class="paramname"><em>pargv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses the commandline flags. </p>
<p>This command parses all the commandline arguments passed in via pargc and argv. Once it is finished, partc and argv will contain the remaining commandline args that <a class="el" href="namespacecaffe2.html" title="Copyright (c) 2016-present, Facebook, Inc. ">caffe2</a> does not deal with. Note that following convention, argv[0] contains the binary name and is not parsed. </p>

<p class="definition">Definition at line <a class="el" href="flags_8cc_source.html#l00071">71</a> of file <a class="el" href="flags_8cc_source.html">flags.cc</a>.</p>

</div>
</div>
<a id="ad461eced97a6ba2c1959ba262f1a3a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad461eced97a6ba2c1959ba262f1a3a3c">&#9670;&nbsp;</a></span>SetDefaultGPUID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void caffe2::SetDefaultGPUID </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>deviceid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the default GPU id for Caffe2. </p>
<p>If an operator is set to run on Cuda GPU but no gpu id is given, we will use the default gpu id to run the operator. Before this function is explicitly called, GPU 0 will be the default GPU id. </p>

<p class="definition">Definition at line <a class="el" href="common__gpu_8cc_source.html#l00110">110</a> of file <a class="el" href="common__gpu_8cc_source.html">common_gpu.cc</a>.</p>

</div>
</div>
<a id="a1eaa1a07583fa2d94c3e66a7496f4790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eaa1a07583fa2d94c3e66a7496f4790">&#9670;&nbsp;</a></span>SetGlobalMPIComm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void caffe2::SetGlobalMPIComm </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>new_comm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the global MPI communicator. </p>
<p>Caffe2 takes over the ownership of the passed in communicator. </p>

<p class="definition">Definition at line <a class="el" href="mpi__common_8cc_source.html#l00040">40</a> of file <a class="el" href="mpi__common_8cc_source.html">mpi_common.cc</a>.</p>

</div>
</div>
<a id="a3123faf5c57e6b67b0d01cd2daa05bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3123faf5c57e6b67b0d01cd2daa05bf1">&#9670;&nbsp;</a></span>ShowLogInfoToStderr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void caffe2::ShowLogInfoToStderr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility to allow one to show log info to stderr after the program starts. </p>
<p>This is similar to calling GLOG's &ndash;logtostderr, or setting caffe2_log_level to smaller than INFO. You are recommended to only use this in a few sparse cases, such as when you want to write a tutorial or something. Normally, use the commandline flags to set the log level. </p>

<p class="definition">Definition at line <a class="el" href="logging_8cc_source.html#l00205">205</a> of file <a class="el" href="logging_8cc_source.html">logging.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a34174f2652b1ceed8b21e82dc5401de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34174f2652b1ceed8b21e82dc5401de4">&#9670;&nbsp;</a></span>a_0</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">it will be coerced into one For an arbitrary n dimensional tensor X in [a_0, a_1, ..., a_{k-1}, a_k, ..., a_{n-1}] and k is the axis then X will be coerced into a dimensional tensor with dimensions [a_0 * ... * a_{k-1}, a_k * ... * a_{n-1}] For the default case where this means the X tensor will be coerced into a tensor of where a_0 is often the batch size In this we must have caffe2::a_0</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= N and a_1 * ... * a_{n-1} = D.</div><div class="line">Each of these dimensions must be matched correctly</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="softmax__op_8cc_source.html#l00114">114</a> of file <a class="el" href="softmax__op_8cc_source.html">softmax_op.cc</a>.</p>

</div>
</div>
<a id="a544e450c246510c64c62fefbe3af76c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544e450c246510c64c62fefbe3af76c7">&#9670;&nbsp;</a></span>axis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Number of replicas The input tensor optional Axis to replicate <a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> that will contain input replicated along the given caffe2::axis</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=1</div><div class="line">  shape(A) = (2, 3, 2, 5)</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="concat__split__op_8cc_source.html#l00029">29</a> of file <a class="el" href="concat__split__op_8cc_source.html">concat_split_op.cc</a>.</p>

</div>
</div>
<a id="a445f23f61fff37bb57625359fe08cc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445f23f61fff37bb57625359fe08cc46">&#9670;&nbsp;</a></span>batch_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int caffe2::batch_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">              size_to_dim_(canonical_axis, GetDimsVector(logits))</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="elementwise__linear__op_8cc_source.html#l00118">118</a> of file <a class="el" href="elementwise__linear__op_8cc_source.html">elementwise_linear_op.cc</a>.</p>

</div>
</div>
<a id="a833087f682593970e7914e0992e5d3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833087f682593970e7914e0992e5d3df">&#9670;&nbsp;</a></span>canonical_axis</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const auto caffe2::canonical_axis</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">          canonical_axis_index_(axis, in[0].dims().size())</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="layer__norm__op_8cc_source.html#l00185">185</a> of file <a class="el" href="layer__norm__op_8cc_source.html">layer_norm_op.cc</a>.</p>

</div>
</div>
<a id="a8729390024d322768e469410ead75913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8729390024d322768e469410ead75913">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Number of replicas caffe2::data</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= slope * x <span class="keywordflow">for</span> x &lt; 0`,</div><div class="line">`f(x) = x <span class="keywordflow">for</span> x &gt;= 0`.</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="image__input__op_8cc_source.html#l00117">117</a> of file <a class="el" href="image__input__op_8cc_source.html">image_input_op.cc</a>.</p>

</div>
</div>
<a id="adba5dd7b582b38ee4365b23decf8e6cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba5dd7b582b38ee4365b23decf8e6cd">&#9670;&nbsp;</a></span>default</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Timeout in caffe2::default</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=\<span class="stringliteral">&quot;\&quot;) characters in the provided blob &quot;</span></div><div class="line">        <span class="stringliteral">&quot; names that match strip_prefix will be removed prior to loading.&quot;</span></div><div class="line">        <span class="stringliteral">&quot; Also, characters that precede strip_prefix will be removed. Useful &quot;</span></div><div class="line">        <span class="stringliteral">&quot; for removing device scope from blob names.&quot;</span>)</div><div class="line">    .Arg(<span class="stringliteral">&quot;db&quot;</span>, <span class="stringliteral">&quot;(string) the path to the db to load.&quot;</span>)</div><div class="line">    .Arg(</div><div class="line">        <span class="stringliteral">&quot;dbs&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;(list of strings) the paths to the dbs to load. This is used for loading&quot;</span></div><div class="line">        <span class="stringliteral">&quot; blobs from multiple databases. If it is set, argument in \&quot;db\&quot; will be&quot;</span></div><div class="line">        <span class="stringliteral">&quot; ignored.&quot;</span>)</div><div class="line">    .Arg(<span class="stringliteral">&quot;db_type&quot;</span>, <span class="stringliteral">&quot;(string) the type of the db.&quot;</span>)</div><div class="line">    .Arg(</div><div class="line">        <span class="stringliteral">&quot;keep_device&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;(int, default 0) if nonzero, the blobs are loaded into the device that &quot;</span></div><div class="line">        <span class="stringliteral">&quot;is specified in the serialized BlobProto. Otherwise, the device will be &quot;</span></div><div class="line">        <span class="stringliteral">&quot;set as the one that the Load operator is being run under.&quot;</span>)</div><div class="line">    .Arg(</div><div class="line">        <span class="stringliteral">&quot;load_all&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;(int, default 0) if nonzero, will load all blobs pointed to by the db &quot;</span></div><div class="line">        <span class="stringliteral">&quot;to the workspace overwriting/creating blobs as needed.&quot;</span>)</div><div class="line">    .Arg(</div><div class="line">        <span class="stringliteral">&quot;allow_incomplete&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;(bool, default false) if true, will allow not loading all the output &quot;</span></div><div class="line">        <span class="stringliteral">&quot;blobs specified in the outputs&quot;</span>)</div><div class="line">    .Arg(</div><div class="line">        <span class="stringliteral">&quot;source_blob_names&quot;</span>,</div><div class="line">        <span class="stringliteral">&quot;(list of strings) if set, used instead of output &quot;</span></div><div class="line">        <span class="stringliteral">&quot;blob names, to specify which blobs in the db shall be loaded. Must be &quot;</span></div><div class="line">        <span class="stringliteral">&quot;the same length as number of output blobs.&quot;</span>)</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="load__save__op_8cc_source.html#l00064">64</a> of file <a class="el" href="load__save__op_8cc_source.html">load_save_op.cc</a>.</p>

</div>
</div>
<a id="a6813549291034e22b8c23512190e36e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6813549291034e22b8c23512190e36e1">&#9670;&nbsp;</a></span>dilation_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::dilation_h</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(</div><div class="line">              <span class="stringliteral">&quot;dilation_h&quot;</span>, helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;dilation&quot;</span>, 1))</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="im2col__op_8cc_source.html#l00056">56</a> of file <a class="el" href="im2col__op_8cc_source.html">im2col_op.cc</a>.</p>

</div>
</div>
<a id="a0a8bd7d72a9b3c36434015674bc13cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8bd7d72a9b3c36434015674bc13cd7">&#9670;&nbsp;</a></span>dilation_w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::dilation_w</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(</div><div class="line">              <span class="stringliteral">&quot;dilation_w&quot;</span>, helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;dilation&quot;</span>, 1))</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="im2col__op_8cc_source.html#l00058">58</a> of file <a class="el" href="im2col__op_8cc_source.html">im2col_op.cc</a>.</p>

</div>
</div>
<a id="abc042919e612ec50e763098e9a6a10c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc042919e612ec50e763098e9a6a10c4">&#9670;&nbsp;</a></span>else</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">given param caffe2::else</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">            CAFFE_ENFORCE_EQ(</div><div class="line">                totalSize,</div><div class="line">                size,</div><div class="line">                <span class="stringliteral">&quot;Argument `shape` does not agree with the input data.&quot;</span>,</div><div class="line">                <span class="stringliteral">&quot; (&quot;</span>,</div><div class="line">                totalSize,</div><div class="line">                <span class="stringliteral">&quot; != &quot;</span>,</div><div class="line">                size,</div><div class="line">                <span class="stringliteral">&quot;)&quot;</span>)</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="reshape__op_8cc_source.html#l00104">104</a> of file <a class="el" href="reshape__op_8cc_source.html">reshape_op.cc</a>.</p>

</div>
</div>
<a id="a7e5bd2edb1b25606fad752a6791de8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e5bd2edb1b25606fad752a6791de8f2">&#9670;&nbsp;</a></span>helper</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; TensorShape &gt; &amp;<a class="el" href="classcaffe2_1_1ArgumentHelper.html">ArgumentHelper</a> caffe2::helper </td>
          <td>(</td>
          <td class="paramtype">def&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">      vector&lt;TensorShape&gt; out(2)</div></div><!-- fragment -->
</div>
</div>
<a id="a6e20361269928187b6a5625204805051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e20361269928187b6a5625204805051">&#9670;&nbsp;</a></span>in</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; TensorShape &gt; &amp; caffe2::in</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">      vector&lt;TensorShape&gt; out(1)</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="batch__gather__ops_8cc_source.html#l00028">28</a> of file <a class="el" href="batch__gather__ops_8cc_source.html">batch_gather_ops.cc</a>.</p>

</div>
</div>
<a id="a6f347dfcbd0ffbd16a980fa75231913a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f347dfcbd0ffbd16a980fa75231913a">&#9670;&nbsp;</a></span>inputs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">in which case the sum will be done in place and results will be accumulated in input0 All inputs and outputs must have the same shape and data type DOC Output tensor Same dimension as caffe2::inputs</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= X_{nd} * w_d + b_d</div><div class="line">  )DOC<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Input(0, &quot;</span>X<span class="stringliteral">&quot;, &quot;</span>2D input tensor of size (N X D) data<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Input(1, &quot;</span>w<span class="stringliteral">&quot;, &quot;</span>1D scaling factors of size D<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Input(2, &quot;</span>b<span class="stringliteral">&quot;, &quot;</span>1D biases of size D<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Output(0, &quot;</span>Y<span class="stringliteral">&quot;, &quot;</span>2D output tensor<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Arg(</span></div><div class="line"><span class="stringliteral">        &quot;</span>axis<span class="stringliteral">&quot;,</span></div><div class="line"><span class="stringliteral">        &quot;</span><span class="keywordflow">default</span> to 1</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="elementwise__linear__op_8cc_source.html#l00108">108</a> of file <a class="el" href="elementwise__linear__op_8cc_source.html">elementwise_linear_op.cc</a>.</p>

</div>
</div>
<a id="aa771dd5c684177749fac98017f820793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa771dd5c684177749fac98017f820793">&#9670;&nbsp;</a></span>kAveragePoolDoc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* caffe2::kAveragePoolDoc</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= R<span class="stringliteral">&quot;DOC(</span></div><div class="line"><span class="stringliteral">consumes an input blob X and applies average pooling across the</span></div><div class="line"><span class="stringliteral">the blob according to kernel sizes, stride sizes, and pad lengths defined by the</span></div><div class="line"><span class="stringliteral">ConvPoolOpBase operator. Average pooling consisting of averaging all values of a</span></div><div class="line"><span class="stringliteral">subset of the input tensor according to the kernel size and downsampling the</span></div><div class="line"><span class="stringliteral">data into the output blob Y for further processing.</span></div><div class="line"><span class="stringliteral">)DOC&quot;</span></div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="pool__op_8cc_source.html#l00708">708</a> of file <a class="el" href="pool__op_8cc_source.html">pool_op.cc</a>.</p>

</div>
</div>
<a id="a6e0c33ee34c77cd3e3e16734e5991d87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0c33ee34c77cd3e3e16734e5991d87">&#9670;&nbsp;</a></span>kBroadcastDoc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* caffe2::kBroadcastDoc</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= R<span class="stringliteral">&quot;DOC(</span></div><div class="line"><span class="stringliteral">If necessary the right-hand-side argument will be broadcasted to match the</span></div><div class="line"><span class="stringliteral">shape of left-hand-side argument. When broadcasting is specified, the second</span></div><div class="line"><span class="stringliteral">tensor can either be of size 1 (a scalar value), or having its shape as a</span></div><div class="line"><span class="stringliteral">contiguous subset of the first tensor&#39;s shape. The starting of the mutually</span></div><div class="line"><span class="stringliteral">equal shape is specified by the argument &quot;axis&quot;, and if it is not set, suffix</span></div><div class="line"><span class="stringliteral">matching is assumed. 1-dim expansion doesn&#39;t work yet.</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">For example, the following tensor shapes are supported (with broadcast=1):</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">  shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar</span></div><div class="line"><span class="stringliteral">  shape(A) = (2, 3, 4, 5), shape(B) = (5,)</span></div><div class="line"><span class="stringliteral">  shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)</span></div><div class="line"><span class="stringliteral">  shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1</span></div><div class="line"><span class="stringliteral">  shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0</span></div><div class="line"><span class="stringliteral"></span></div><div class="line"><span class="stringliteral">Argument `broadcast=1` needs to be passed to enable broadcasting.</span></div><div class="line"><span class="stringliteral">)DOC&quot;</span></div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="elementwise__op__schema_8cc_source.html#l00023">23</a> of file <a class="el" href="elementwise__op__schema_8cc_source.html">elementwise_op_schema.cc</a>.</p>

</div>
</div>
<a id="ab5c2938a533274cb9b74a72e0428d419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5c2938a533274cb9b74a72e0428d419">&#9670;&nbsp;</a></span>kConvDoc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* caffe2::kConvDoc</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= R<span class="stringliteral">&quot;DOC(</span></div><div class="line"><span class="stringliteral">Note that other parameters, such as the stride and</span></div><div class="line"><span class="stringliteral">kernel size, or the pads&#39; sizes in each direction are not necessary for input</span></div><div class="line"><span class="stringliteral">because they are provided by the ConvPoolOpBase operator. Various dimension</span></div><div class="line"><span class="stringliteral">checks are done implicitly, and the sizes are specified in the Input docs for</span></div><div class="line"><span class="stringliteral">this operator. As is expected, the filter is convolved with a subset of the</span></div><div class="line"><span class="stringliteral">image and the bias is added; this is done throughout the image data and the</span></div><div class="line"><span class="stringliteral">output is computed. As a side note on the implementation layout:</span></div><div class="line"><span class="stringliteral">conv_op_impl.h is the templated implementation of the conv_op.h file, which is</span></div><div class="line"><span class="stringliteral">why they are separate files.</span></div><div class="line"><span class="stringliteral">)DOC&quot;</span></div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="operators_2conv__op_8cc_source.html#l00023">23</a> of file <a class="el" href="operators_2conv__op_8cc_source.html">conv_op.cc</a>.</p>

</div>
</div>
<a id="ac2b9abe1c69fb306a265046144f3c385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2b9abe1c69fb306a265046144f3c385">&#9670;&nbsp;</a></span>kernel_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::kernel_h</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(</div><div class="line">              <span class="stringliteral">&quot;kernel_h&quot;</span>, helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;kernel&quot;</span>, 0))</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="im2col__op_8cc_source.html#l00052">52</a> of file <a class="el" href="im2col__op_8cc_source.html">im2col_op.cc</a>.</p>

</div>
</div>
<a id="aaaed860c253cc3623218f5e049f56807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaed860c253cc3623218f5e049f56807">&#9670;&nbsp;</a></span>kernel_w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::kernel_w</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(</div><div class="line">              <span class="stringliteral">&quot;kernel_w&quot;</span>, helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;kernel&quot;</span>, 0))</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="im2col__op_8cc_source.html#l00054">54</a> of file <a class="el" href="im2col__op_8cc_source.html">im2col_op.cc</a>.</p>

</div>
</div>
<a id="af8a955b975554d5a59f51b580ac5ca05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a955b975554d5a59f51b580ac5ca05">&#9670;&nbsp;</a></span>kMaxPoolDoc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* caffe2::kMaxPoolDoc</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= R<span class="stringliteral">&quot;DOC(</span></div><div class="line"><span class="stringliteral">consumes an input blob X and applies max pooling across the</span></div><div class="line"><span class="stringliteral">the blob according to kernel sizes, stride sizes, and pad lengths defined by the</span></div><div class="line"><span class="stringliteral">ConvPoolOpBase operator. Max pooling consisting of taking the maximum value of a</span></div><div class="line"><span class="stringliteral">subset of the input tensor according to the kernel size and downsampling the</span></div><div class="line"><span class="stringliteral">data into the output blob Y for further processing.</span></div><div class="line"><span class="stringliteral">)DOC&quot;</span></div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="pool__op_8cc_source.html#l00716">716</a> of file <a class="el" href="pool__op_8cc_source.html">pool_op.cc</a>.</p>

</div>
</div>
<a id="a22ec3d8b4f17b4e26fdfd0f339e64089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ec3d8b4f17b4e26fdfd0f339e64089">&#9670;&nbsp;</a></span>num_classes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::num_classes</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">              <a class="code" href="namespacecaffe2.html#a57dab6c8becb4bb52f6e74e5c1063487">size_from_dim_</a>(canonical_axis, GetDimsVector(logits))</div><div class="ttc" id="namespacecaffe2_html_a57dab6c8becb4bb52f6e74e5c1063487"><div class="ttname"><a href="namespacecaffe2.html#a57dab6c8becb4bb52f6e74e5c1063487">caffe2::size_from_dim_</a></div><div class="ttdeci">TIndex size_from_dim_(int k, vector&lt; TIndex &gt; dims)</div><div class="ttdoc">Return product of all dimensions starting from K. </div><div class="ttdef"><b>Definition:</b> <a href="tensor_8h_source.html#l00056">tensor.h:56</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="softmax__with__loss__op_8cc_source.html#l00044">44</a> of file <a class="el" href="softmax__with__loss__op_8cc_source.html">softmax_with_loss_op.cc</a>.</p>

</div>
</div>
<a id="afb2a34a424811068acf175bd0272749c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2a34a424811068acf175bd0272749c">&#9670;&nbsp;</a></span>order</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::order</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= StringToStorageOrder(</div><div class="line">              helper.GetSingleArgument&lt;<span class="keywordtype">string</span>&gt;(<span class="stringliteral">&quot;order&quot;</span>, <span class="stringliteral">&quot;NCHW&quot;</span>))</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="do__op_8cc_source.html#l00033">33</a> of file <a class="el" href="do__op_8cc_source.html">do_op.cc</a>.</p>

</div>
</div>
<a id="ac3c99e50a77791b25972e3612dfa4e80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c99e50a77791b25972e3612dfa4e80">&#9670;&nbsp;</a></span>output</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int caffe2::output</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= net.BooleanUnmask([mask1, values1, mask2, values2], [<span class="stringliteral">&quot;output&quot;</span>])</div><div class="line"></div><div class="line">We <span class="keyword">get</span>:</div><div class="line">output = 1.0</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="abs__op_8cc_source.html#l00061">61</a> of file <a class="el" href="abs__op_8cc_source.html">abs_op.cc</a>.</p>

</div>
</div>
<a id="af04e8baeca5dcb4f675a99f815264363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af04e8baeca5dcb4f675a99f815264363">&#9670;&nbsp;</a></span>r</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcaffe2_1_1Tensor.html">Tensor</a> of rank caffe2::r</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= 2.<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Input(1, &quot;</span>INDICES<span class="stringliteral">&quot;, &quot;</span><a class="code" href="structTensor.html">Tensor</a> of int32/int64 indices</div><div class="ttc" id="structTensor_html"><div class="ttname"><a href="structTensor.html">Tensor</a></div><div class="ttdoc">Copyright (c) 2016-present, Facebook, Inc. </div><div class="ttdef"><b>Definition:</b> <a href="ios__caffe__predictor_8h_source.html#l00025">ios_caffe_predictor.h:25</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="batch__gather__ops_8cc_source.html#l00045">45</a> of file <a class="el" href="batch__gather__ops_8cc_source.html">batch_gather_ops.cc</a>.</p>

</div>
</div>
<a id="afc9b7cc28c1e368ab79d928e9ae438f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc9b7cc28c1e368ab79d928e9ae438f1">&#9670;&nbsp;</a></span>r_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reshape it into matrix of we compute where min_i and max_i minimum and maximum elements of i th and quantize each element caffe2::r_</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{ij} as</div><div class="line">    0 &lt;= round(r_ij - bias_i) / scale_i) &lt; 256. Instead of input tensor</div><div class="line">    we obtain uint8 tensor and auxiliary information as scale and bias to</div><div class="line">    restore input tensor (with losses).)DOC<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Input(0, &quot;</span>input<span class="stringliteral">&quot;, &quot;</span>input<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Output(0, &quot;</span>quantized_input<span class="stringliteral">&quot;, &quot;</span>quantized_input<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Output(</span></div><div class="line"><span class="stringliteral">        1,</span></div><div class="line"><span class="stringliteral">        &quot;</span>scale_bias<span class="stringliteral">&quot;,</span></div><div class="line"><span class="stringliteral">        &quot;</span>Matrix of floats</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="lengths__reducer__rowwise__8bit__ops_8cc_source.html#l00183">183</a> of file <a class="el" href="lengths__reducer__rowwise__8bit__ops_8cc_source.html">lengths_reducer_rowwise_8bit_ops.cc</a>.</p>

</div>
</div>
<a id="a984c2d4fbe3b1b9e1602f2ec24fe135f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984c2d4fbe3b1b9e1602f2ec24fe135f">&#9670;&nbsp;</a></span>rank</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">A tensor of caffe2::rank</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= axis.<span class="stringliteral">&quot;)</span></div><div class="line"><span class="stringliteral">    .Output(</span></div><div class="line"><span class="stringliteral">        0,</span></div><div class="line"><span class="stringliteral">        &quot;</span>output<span class="stringliteral">&quot;,</span></div><div class="line"><span class="stringliteral">        &quot;</span>A 2D tensor with the contents of the input tensor</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="flatten__op_8cc_source.html#l00048">48</a> of file <a class="el" href="flatten__op_8cc_source.html">flatten_op.cc</a>.</p>

</div>
</div>
<a id="a2535a732c1ece7df1aaf184b8c9089de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2535a732c1ece7df1aaf184b8c9089de">&#9670;&nbsp;</a></span>scale_i</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reshape it into matrix of we compute caffe2::scale_i</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= (min_i - max_i) / 255 and  bias_i = min_i <span class="keywordflow">for</span></div><div class="line">    i-th row r_i of reshaped matrix</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="lengths__reducer__rowwise__8bit__ops_8cc_source.html#l00181">181</a> of file <a class="el" href="lengths__reducer__rowwise__8bit__ops_8cc_source.html">lengths_reducer_rowwise_8bit_ops.cc</a>.</p>

</div>
</div>
<a id="a433ab69df61deb5e78008f2017514433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433ab69df61deb5e78008f2017514433">&#9670;&nbsp;</a></span>stride_h</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::stride_h</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(</div><div class="line">              <span class="stringliteral">&quot;stride_h&quot;</span>, helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;stride&quot;</span>, 1))</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="im2col__op_8cc_source.html#l00060">60</a> of file <a class="el" href="im2col__op_8cc_source.html">im2col_op.cc</a>.</p>

</div>
</div>
<a id="a28f24cb994d9da9475e824cc5715772d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28f24cb994d9da9475e824cc5715772d">&#9670;&nbsp;</a></span>stride_w</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::stride_w</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(</div><div class="line">              <span class="stringliteral">&quot;stride_w&quot;</span>, helper.GetSingleArgument&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;stride&quot;</span>, 1))</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="im2col__op_8cc_source.html#l00062">62</a> of file <a class="el" href="im2col__op_8cc_source.html">im2col_op.cc</a>.</p>

</div>
</div>
<a id="a45b77424afcbc65c3b1971194b6c5e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45b77424afcbc65c3b1971194b6c5e84">&#9670;&nbsp;</a></span>valid_axes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto caffe2::valid_axes</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">            std::all_of(axes.begin(), axes.end(), [&amp;tensor_size](<span class="keywordtype">int</span>&amp; axis) {</div><div class="line">              <span class="keywordflow">return</span> axis &gt;= 0 &amp;&amp; axis &lt; tensor_size;</div><div class="line">            })</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="transpose__op_8cc_source.html#l00056">56</a> of file <a class="el" href="transpose__op_8cc_source.html">transpose_op.cc</a>.</p>

</div>
</div>
<a id="acc6bf36770de6197a0500da244b4d49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6bf36770de6197a0500da244b4d49f">&#9670;&nbsp;</a></span>values2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reconstruct values together according to masks A comprehensive False False True Reconstruct We Note that for all mask there must be at least one True If for a field there are multiple True we will accept the first value For False False False True caffe2::values2</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= 2.0</div><div class="line">mask3   = False</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="boolean__unmask__ops_8cc_source.html#l00085">85</a> of file <a class="el" href="boolean__unmask__ops_8cc_source.html">boolean_unmask_ops.cc</a>.</p>

</div>
</div>
<a id="af27fa78c467fba5c61c550605162022c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27fa78c467fba5c61c550605162022c">&#9670;&nbsp;</a></span>y</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">caffe2::y</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">== 1 then it assumed the first input should be ranked higher</div><div class="line">(have a larger value) than the second input</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="margin__ranking__criterion__op_8cc_source.html#l00096">96</a> of file <a class="el" href="margin__ranking__criterion__op_8cc_source.html">margin_ranking_criterion_op.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.14-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 16 2018 13:16:19 for Caffe2 - C++ API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
<div class="footerContainer">
  <div id="footer_wrap" class="wrapper footerWrapper">
    <div class="footerBlocks">
      <div id="fb_oss" class="footerSection fbOpenSourceFooter">
          <svg class="facebookOSSLogoSvg" viewBox="0 0 1133.9 1133.9" x="0px" y="0px" height=50 width=50>
            <g>
              <path class="logoRing outerRing" d="M 498.3 3.7 c 153.6 88.9 307.3 177.7 461.1 266.2 c 7.6 4.4 10.3 9.1 10.3 17.8 c -0.3 179.1 -0.2 358.3 0 537.4 c 0 8.1 -2.4 12.8 -9.7 17.1 c -154.5 88.9 -308.8 178.1 -462.9 267.5 c -9 5.2 -15.5 5.3 -24.6 0.1 c -153.9 -89.2 -307.9 -178 -462.1 -266.8 C 3 838.8 0 833.9 0 825.1 c 0.3 -179.1 0.2 -358.3 0 -537.4 c 0 -8.6 2.6 -13.6 10.2 -18 C 164.4 180.9 318.4 92 472.4 3 C 477 -1.5 494.3 -0.7 498.3 3.7 Z M 48.8 555.3 c 0 79.9 0.2 159.9 -0.2 239.8 c -0.1 10 3 15.6 11.7 20.6 c 137.2 78.8 274.2 157.8 411 237.3 c 9.9 5.7 17 5.7 26.8 0.1 c 137.5 -79.8 275.2 -159.2 412.9 -238.5 c 7.4 -4.3 10.5 -8.9 10.5 -17.8 c -0.3 -160.2 -0.3 -320.5 0 -480.7 c 0 -8.8 -2.8 -13.6 -10.3 -18 C 772.1 218 633.1 137.8 494.2 57.4 c -6.5 -3.8 -11.5 -4.5 -18.5 -0.5 C 336.8 137.4 197.9 217.7 58.8 297.7 c -7.7 4.4 -10.2 9.2 -10.2 17.9 C 48.9 395.5 48.8 475.4 48.8 555.3 Z" />
              <path class="logoRing middleRing" d="M 184.4 555.9 c 0 -33.3 -1 -66.7 0.3 -100 c 1.9 -48 24.1 -86 64.7 -110.9 c 54.8 -33.6 110.7 -65.5 167 -96.6 c 45.7 -25.2 92.9 -24.7 138.6 1 c 54.4 30.6 108.7 61.5 162.2 93.7 c 44 26.5 67.3 66.8 68 118.4 c 0.9 63.2 0.9 126.5 0 189.7 c -0.7 50.6 -23.4 90.7 -66.6 116.9 c -55 33.4 -110.8 65.4 -167.1 96.5 c -43.4 24 -89 24.2 -132.3 0.5 c -57.5 -31.3 -114.2 -64 -170 -98.3 c -41 -25.1 -62.9 -63.7 -64.5 -112.2 C 183.5 621.9 184.3 588.9 184.4 555.9 Z M 232.9 556.3 c 0 29.5 0.5 59.1 -0.1 88.6 c -0.8 39.2 16.9 67.1 50.2 86.2 c 51.2 29.4 102.2 59.2 153.4 88.4 c 31.4 17.9 63.6 18.3 95 0.6 c 53.7 -30.3 107.1 -61.2 160.3 -92.5 c 29.7 -17.5 45 -44.5 45.3 -78.8 c 0.6 -61.7 0.5 -123.5 0 -185.2 c -0.3 -34.4 -15.3 -61.5 -44.9 -79 C 637.7 352.6 583 320.8 527.9 290 c -27.5 -15.4 -57.2 -16.1 -84.7 -0.7 c -56.9 31.6 -113.4 64 -169.1 97.6 c -26.4 15.9 -40.7 41.3 -41.1 72.9 C 232.6 491.9 232.9 524.1 232.9 556.3 Z" />
              <path class="logoRing innerRing" d="M 484.9 424.4 c 69.8 -2.8 133.2 57.8 132.6 132 C 617 630 558.5 688.7 484.9 689.1 c -75.1 0.4 -132.6 -63.6 -132.7 -132.7 C 352.1 485 413.4 421.5 484.9 424.4 Z M 401.3 556.7 c -3.4 37.2 30.5 83.6 83 84.1 c 46.6 0.4 84.8 -37.6 84.9 -84 c 0.1 -46.6 -37.2 -84.4 -84.2 -84.6 C 432.2 472.1 397.9 518.3 401.3 556.7 Z" />
            </g>
          </svg>
        <h2>Facebook Open Source</h2>
      </div>
      <div class="footerSection">
        <a class="footerLink" href="https://code.facebook.com/projects/" target="_blank">Open Source Projects</a>
        <a class="footerLink" href="https://github.com/facebook/" target="_blank">GitHub</a>
        <a class="footerLink" href="https://twitter.com/fbOpenSource" target="_blank">Twitter</a>
      </div>
      <div class="footerSection rightAlign">
        <a class="footerLink" href="https://github.com/caffe2/caffe2" target="_blank">Contribute to this project on GitHub</a>
      </div>
    </div>
  </div>
</div>
<script type="text/javascript" src="/js/jekyll-link-anchors.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', '{{ site.gacode }}', 'auto');
  ga('send', 'pageview');
</script>
</body>
</html>
